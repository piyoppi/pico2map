{"version":3,"file":"minimum_example.bundle.js","mappings":";;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAI,IAAI,SAAI;AAC9B;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AAC4C;AACC;AACiC;AACY;AACnF,wCAAwC,2CAAU;AACzD;AACA;AACA;AACA,sCAAsC,wEAAkB;AACxD,4CAA4C,uFAAwB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,4EAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA,qCAAqC,sEAAgB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yBAAyB;AAC/C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qCAAI;AACnB;AACA;AACA,mCAAmC,mBAAmB;AACtD,mBAAmB,uBAAuB;AAC1C,oBAAoB,wBAAwB;AAC5C;;AAEA;AACA,mBAAmB,YAAY;AAC/B,oBAAoB,aAAa;AACjC,kBAAkB,sBAAsB;AACxC,iBAAiB,sBAAsB;AACvC;;AAEA;AACA,mBAAmB,YAAY;AAC/B,oBAAoB,aAAa;AACjC,kBAAkB,wBAAwB;AAC1C,iBAAiB,wBAAwB;AACzC;AACA;;AAEA;AACA,UAAU,qBAAqB,qCAAI;AACnC,sCAAsC,mBAAmB;AACzD;AACA;AACA,0BAA0B,yBAAyB;AACnD,0BAA0B,yBAAyB;AACnD;AACA;AACA,YAAY,uDAAuD,qCAAI;AACvE;AACA;AACA;AACA;AACA;AACA,eAAe,oCAAG;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,2DAAQ,GAAG,cAAc;AAC7B;AACA;AACA,IAAI,2DAAQ,GAAG,cAAc;AAC7B;AACA;AACA,IAAI,2DAAQ,GAAG,cAAc;AAC7B;AACA;AACA,IAAI,2DAAQ,GAAG,cAAc;AAC7B;AACA;AACA,IAAI,2DAAQ,GAAG,cAAc;AAC7B;AACA;AACA,IAAI,2DAAQ,GAAG,cAAc;AAC7B;AACA;AACA,IAAI,2DAAQ,GAAG,cAAc;AAC7B;AACA;AACA,IAAI,2DAAQ,GAAG,cAAc;AAC7B;;;;;;;;;;;;;;;;;;;AClSA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAI,IAAI,SAAI;AAC9B;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AAC4C;AACC;AACiC;AACS;AAChF,qCAAqC,2CAAU;AACtD;AACA;AACA;AACA,uCAAuC,wEAAkB;AACzD,6CAA6C,uFAAwB;AACrE,kCAAkC,mEAAa;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4FAAsC;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,4EAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qCAAI;AACnB;AACA;AACA,mCAAmC,mBAAmB;AACtD;;AAEA;AACA,mBAAmB,eAAe;AAClC,oBAAoB,gBAAgB;AACpC;;AAEA;AACA,mBAAmB,eAAe;AAClC,oBAAoB,gBAAgB;AACpC,kBAAkB,sBAAsB;AACxC,iBAAiB,sBAAsB;AACvC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B,oBAAoB,YAAY;AAChC;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B,oBAAoB,YAAY;AAChC;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD,yBAAyB,0BAA0B;AACnD,0BAA0B,4DAA4D;AACtF;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oCAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,2DAAQ,GAAG,cAAc;AAC7B;AACA;AACA,IAAI,2DAAQ,GAAG,cAAc;AAC7B;AACA;AACA,IAAI,2DAAQ,GAAG,eAAe;AAC9B;AACA;AACA,IAAI,2DAAQ,GAAG,cAAc;AAC7B;AACA;AACA,IAAI,2DAAQ,GAAG,cAAc;AAC7B;AACA;AACA,IAAI,2DAAQ,GAAG,cAAc;AAC7B;AACA;AACA,IAAI,2DAAQ,GAAG,cAAc;AAC7B;AACA;AACA,IAAI,2DAAQ,GAAG,cAAc;AAC7B;;;;;;;;;;;;;;;;;AC5SA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACO;AACP;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACO;AACP;AACA,kCAAkC,QAAQ;AAC1C;AACA;;;;;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAI,IAAI,SAAI;AAC9B;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AAC4C;AACC;AACiC;AACf;AACL;AACnD,iCAAiC,2CAAU;AAClD;AACA;AACA,4CAA4C,uFAAwB;AACpE,8BAA8B,+DAAS;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4FAAsC;AAC9C;AACA;AACA,0BAA0B,QAAQ;AAClC;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,+EAA0B;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,4EAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,qBAAqB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,+BAA+B;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qBAAqB;AACjD;AACA;AACA;AACA;AACA;AACA,kDAAkD,4CAA4C;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qCAAI;AACnB;AACA;AACA,mBAAmB,eAAe;AAClC,oBAAoB,gBAAgB;AACpC;AACA;;AAEA;AACA,sBAAsB,yBAAyB;AAC/C,uBAAuB,0BAA0B;AACjD,wBAAwB,4DAA4D;AACpF;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B,oBAAoB,YAAY;AAChC;AACA,UAAU,+BAA+B,qCAAI;AAC7C;AACA,yBAAyB,eAAe;AACxC,0BAA0B,gBAAgB;AAC1C,0BAA0B,YAAY;AACtC,0BAA0B,YAAY;AACtC,yBAAyB,eAAe;AACxC,2BAA2B,gDAAgD;AAC3E,4BAA4B,iDAAiD;AAC7E;AACA;AACA;AACA;AACA;AACA,eAAe,oCAAG;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,2DAAQ,GAAG,eAAe;AAC9B;AACA;AACA,IAAI,2DAAQ,GAAG,eAAe;AAC9B;AACA;AACA,IAAI,2DAAQ,GAAG,cAAc;AAC7B;AACA;AACA,IAAI,2DAAQ,GAAG,cAAc;AAC7B;AACA;AACA,IAAI,2DAAQ,GAAG,cAAc;AAC7B;AACA;AACA,IAAI,2DAAQ,GAAG,cAAc;AAC7B;AACA;AACA,IAAI,2DAAQ,GAAG,cAAc;AAC7B;AACA;AACA,IAAI,2DAAQ,GAAG,cAAc;AAC7B;AACA;AACA,IAAI,2DAAQ,GAAG,cAAc;AAC7B;AACA;AACA,IAAI,2DAAQ,GAAG,cAAc;AAC7B;AACA;AACA,IAAI,2DAAQ,GAAG,eAAe;AAC9B;;;;;;;;;;;;;;;;;;;AC7aA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAI,IAAI,SAAI;AAC9B;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AAC4C;AACC;AAC4C;AACX;AACvE,uCAAuC,2CAAU;AACxD;AACA;AACA;AACA,sCAAsC,wEAAkB;AACxD,4CAA4C,uFAAwB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,4EAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,qEAAe;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uEAAuE;AAC7F;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qCAAI;AACnB;AACA;AACA,mCAAmC,mBAAmB;AACtD,mBAAmB,kGAAkG;AACrH,oBAAoB,mGAAmG;AACvH;;AAEA;AACA,mBAAmB,eAAe;AAClC,oBAAoB,gBAAgB;AACpC,kBAAkB,sBAAsB;AACxC,iBAAiB,sBAAsB;AACvC;;AAEA;AACA,mBAAmB,mBAAmB;AACtC,oBAAoB,oBAAoB;AACxC,kBAAkB,eAAe;AACjC,iBAAiB,eAAe;AAChC;AACA;;AAEA;AACA,oCAAoC,eAAe;AACnD;AACA;AACA,wBAAwB,yBAAyB;AACjD,wBAAwB,yBAAyB;AACjD,sBAAsB,uBAAuB;AAC7C;AACA,UAAU,iBAAiB,qCAAI;AAC/B,UAAU,wEAAwE,qCAAI;AACtF;AACA;AACA;AACA;AACA,eAAe,oCAAG;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,2DAAQ,GAAG,cAAc;AAC7B;AACA;AACA,IAAI,2DAAQ,GAAG,cAAc;AAC7B;AACA;AACA,IAAI,2DAAQ,GAAG,cAAc;AAC7B;AACA;AACA,IAAI,2DAAQ,GAAG,cAAc;AAC7B;AACA;AACA,IAAI,2DAAQ,GAAG,cAAc;AAC7B;AACA;AACA,IAAI,2DAAQ,GAAG,cAAc;AAC7B;AACA;AACA,IAAI,2DAAQ,GAAG,cAAc;AAC7B;AACA;AACA,IAAI,2DAAQ,GAAG,cAAc;AAC7B;AACA;AACA,IAAI,2DAAQ,GAAG,cAAc;AAC7B;;;;;;;;;;;;;;;;;;;ACrRA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAI,IAAI,SAAI;AAC9B;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AAC4C;AACC;AACiC;AACkE;AACzI,+BAA+B,2CAAU;AAChD;AACA;AACA;AACA,sCAAsC,wEAAkB;AACxD,4CAA4C,uFAAwB;AACpE,sCAAsC;AACtC,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iGAAuC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iGAAuC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qCAAI;AACnB;AACA;AACA,mCAAmC,kBAAkB;AACrD;;AAEA;AACA,mBAAmB,eAAe;AAClC,oBAAoB,gBAAgB;AACpC;;AAEA;AACA,mBAAmB,kCAAkC;AACrD,oBAAoB,oCAAoC;AACxD,kBAAkB,sBAAsB;AACxC,iBAAiB,sBAAsB;AACvC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD,wBAAwB,yBAAyB;AACjD;AACA,UAAU,qBAAqB,qCAAI;AACnC;AACA;AACA;AACA;AACA,eAAe,oCAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,2DAAQ,GAAG,cAAc;AAC7B;AACA;AACA,IAAI,2DAAQ,GAAG,cAAc;AAC7B;AACA;AACA,IAAI,2DAAQ,GAAG,cAAc;AAC7B;AACA;AACA,IAAI,2DAAQ,GAAG,cAAc;AAC7B;AACA;AACA,IAAI,2DAAQ,GAAG,eAAe;AAC9B;AACA;AACA,IAAI,2DAAQ,GAAG,cAAc;AAC7B;AACA;AACA,IAAI,2DAAQ,GAAG,cAAc;AAC7B;AACA;AACA,IAAI,2DAAQ,GAAG,cAAc;AAC7B;AACA;AACA,IAAI,2DAAQ,GAAG,cAAc;AAC7B;AACA;AACA,IAAI,2DAAQ,GAAG,cAAc;AAC7B;;;;;;;;;;;;;;;;ACxLA;AACA;AACA;AACA;AACA;AAC4D;AACrD;AACP,QAAQ,0EAAiB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACsE;AACZ;AACc;AACL;AACb;AAC/C;AACP,kDAAkD,mEAAkB;AACpE,0DAA0D,iFAAyB;AACnF,yDAAyD,+EAAwB;AACjF,sDAAsD,4EAAsB;AAC5E,gDAAgD,+DAAgB;AAChE;AACoD;AACuC;AACnB;;;;;;;;;;;;;;;ACnBxE;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,EAAE,GAAG,EAAE;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,EAAE,GAAG,EAAE;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACrEA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;;;;;;;;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACqE;AACE;AACQ;AAC/E;AACA,IAAI,8EAA6B;AACjC,IAAI,gFAA8B;AAClC,IAAI,wFAAkC;AACtC;AACO;AACP;AACA;AACA,CAAC;;;;;;;;;;;;;;;;;AChBD;AACA;AACA;AACA;AACA;AAC4G;AACrG;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,iCAAiC,oEAAe,UAAU,oEAAe;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iEAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,+BAA+B,4BAA4B;AAC3D,mCAAmC,2BAA2B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,0EAAiB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,kDAAkD;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oEAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,kBAAkB;AAC/E;AACA;AACA;AACA;AACA;AACA,6DAA6D,kBAAkB;AAC/E;AACA;AACA;AACA;AACA;AACA,6DAA6D,kBAAkB;AAC/E;AACA;AACA;AACA;AACA;AACA,6DAA6D,kBAAkB;AAC/E;AACA;AACA;AACA;AACA;AACA,6DAA6D,kBAAkB;AAC/E;AACA;AACA;AACA;AACA;AACA,6DAA6D,kBAAkB;AAC/E;AACA;AACA,6DAA6D,kBAAkB;AAC/E;AACA;AACA,6DAA6D,kBAAkB;AAC/E;AACA;AACA,6DAA6D,kBAAkB;AAC/E;AACA;AACA,6DAA6D,kBAAkB;AAC/E;AACA;AACA;AACA,6DAA6D,kBAAkB;AAC/E;AACA;AACA,6DAA6D,kBAAkB;AAC/E;AACA;AACA,6DAA6D,kBAAkB;AAC/E;AACA;AACA,6DAA6D,kBAAkB;AAC/E;AACA;AACA,6DAA6D,kBAAkB;AAC/E;AACA;AACA;AACA,6DAA6D,kBAAkB;AAC/E;AACA;AACA;AACA;AACA,6DAA6D,kBAAkB;AAC/E;AACA;AACA;AACA;AACA,6DAA6D,kBAAkB;AAC/E;AACA;AACA;AACA;AACA,6DAA6D,kBAAkB;AAC/E;AACA;AACA;AACA;AACA,6DAA6D,kBAAkB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACpQA;AACA;AACA;AACA;AACA;AAC4D;AACc;AACnE;AACP;AACA;AACA;AACO;AACP;AACA,wCAAwC,qEAAmB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iEAAY;AAC5C;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA,gCAAgC,oCAAoC;AACpE;AACA,sDAAsD,kCAAkC;AACxF,0DAA0D,kCAAkC;AAC5F;AACA;AACA;AACA,gCAAgC,0EAAiB;AACjD;AACA;AACA;AACA;AACA,iFAAiF,MAAM;AACvF;AACA;AACA,4CAA4C,2GAA2G;AACvJ;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;AC1EA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,mCAAmC;AACzE;AACA;;;;;;;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACkD;AAC3C;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA,0BAA0B,4DAAO;AACjC,aAAa;AACb,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACsD;AACgB;AAC/D;AACP;AACA;AACA;AACO;AACP;AACA,iCAAiC,+DAAgB;AACjD,kCAAkC,+EAAwB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;ACxCA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA,sCAAsC,sBAAsB;AAC5D;AACA;;;;;;;;;;;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACuC;AACsB;AAC7D;AACA,IAAI,gDAAc;AAClB,IAAI,sEAAyB;AAC7B;AACO;AACP;AACA;AACA,CAAC;;;;;;;;;;;;;;;;ACdD;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;;;;;;;;;;;;;;;;ACjDA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,WAAW;AACxC,iCAAiC,WAAW;AAC5C,8BAA8B,MAAM;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AChDA;AACA;AACA;AACA;AACA;AAC8C;AACvC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,uDAAY;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACkD;AAC3C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,2DAAc;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACoD;AAChB;AACQ;AACgC;AACG;AACxE;AACP;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wFAAkB;AAClD;AACA,sCAAsC;AACtC;AACA;AACA;AACA,0BAA0B,6CAAG;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,6DAAe;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0DAAY;AAC5C;AACA,8BAA8B,6CAAG;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yFAAsB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACvLA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,uBAAuB,GAAG,uBAAuB,GAAG,uBAAuB,GAAG,uBAAuB;AACzI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC1DA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACyE;AACrC;AACQ;AACuB;AAC6E;AACjE;AAC/B;AAC6E;AACtH;AACP;AACA;AACA;AACA,0BAA0B,6CAAG;AAC7B,gCAAgC,wFAAkB;AAClD,sCAAsC;AACtC,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,gEAAW;AACxC,kCAAkC,yDAAa;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA,qCAAqC,oHAAoH,KAAK,gEAAgE;AAC9N,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA,gCAAgC,0DAAY;AAC5C;AACA,8BAA8B,6CAAG;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,iFAAiB;AACvD;AACA,oCAAoC,wFAAkB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yFAAsB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4FAAyB,wBAAwB,qFAAkB;AAC/E;AACA,YAAY,qFAAkB;AAC9B;AACA;AACA,YAAY,4FAAyB;AACrC;AACA;AACA,YAAY,qFAAkB;AAC9B;AACA;AACA,YAAY,sFAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,iGAAuC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iGAAuC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0EAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACrRA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AAC0D;AACnD;AACP;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC,4BAA4B,YAAY;AACxC,6CAA6C,oEAAe;AAC5D;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACvGA;AACA;AACA;AACA;AACA;AACoD;AACd;AAC/B;AACP;AACA;AACA;AACA,8BAA8B,6DAAe;AAC7C,6BAA6B,+CAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/EA;AACA;AACA;AACA;AACA;AAC0D;AACZ;AACN;AACO;AACC;AACM;AACF;AACyE;;;;;;;;;;;;;;;;ACZ7H;AACA;AACA;AACA;AACA;AAC+C;AACxC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,gEAA0B;AAC3F;AACA;AACA;;;;;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACsC;AAC/B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,+CAAQ;AACzC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,0DAAmB;AAChD;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;AC1DA;AACA;AACA;AACA;AACA;AAC+C;AACxC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,aAAa;AACtC;AACA,4BAA4B,YAAY;AACxC;AACA,0CAA0C,qDAAe;AACzD,0CAA0C,qDAAe;AACzD,0CAA0C,qDAAe;AACzD,0CAA0C,qDAAe;AACzD,0CAA0C,qDAAe;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,GAAG,GAAG,GAAG,GAAG,QAAQ;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC9KA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC7EA;AACA;AACA;AACA;AACA;AAC8C;AACvC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kEAAuB;AAC7C,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;ACjDA;AACA;AACA;AACA;AACA;AACwC;AACjC,yBAAyB,iDAAS;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AAC8C;AACvC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2DAAY;AACpB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC1EA;AACA;AACA;AACA;AACA;AAC8C;AACN;AACjC;AACP;AACA;AACA,2BAA2B,iDAAS;AACpC;AACA,2BAA2B,iDAAS;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2DAAY;AACpB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACxHA;AACA;AACA;AACA;AACA;AACqF;AAC/B;AAC/C,2BAA2B,+DAAgB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qEAA2B;AAC3C,uBAAuB,gEAA0B;AACjD;AACA,mBAAmB,wDAAkB;AACrC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC9CA;AACA;AACA;AACA;AACA;AACO;AACP,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,uBAAuB,GAAG,uBAAuB,GAAG,uBAAuB,GAAG,uBAAuB;AACzI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,yBAAyB;AACzB;AACA,yBAAyB;AACzB;AACA,yBAAyB;AACzB;AACA,yBAAyB;AACzB;AACA,yBAAyB;AACzB;AACA,yBAAyB;AACzB;AACA,yBAAyB;AACzB;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACrFA;AACA;AACA;AACA;AACA;AAC0D;AACT;AACK;AACJ;AAC3C;AACP;AACA;AACA;AACA;AACA;AACA,kCAAkC,mEAAkB;AACpD,8BAA8B,0DAAS;AACvC;AACA,6BAA6B,2DAAU;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,+DAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,0EAAuB;AACnF,yBAAyB,sEAAqB;AAC9C;AACA;AACA;AACA,2CAA2C,sHAAsH;AACjK;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7FA;AACA;AACA;AACA;AACA;AACsC;AACgB;AACR;AACY;AAC+B;AACxC;AACF;AAC0C;AACvC;AACN;AAC5C;;;;;;;;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;;AC7GA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,UAAU,0BAA0B;AACxD;AACA,sBAAsB,UAAU,4BAA4B;AAC5D;AACA;AACA,aAAa;AACb;AACO,4BAA4B,uBAAuB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;AC3CA;AACA;AACA;AACA;AACA;AAC6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,cAAc;AACrC;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,WAAW,0DAAgB;AAC3B;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;;;;;;;;;;;;;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC5FA;AACA;AACA;AACA;AACA;AAC6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,WAAW,0DAAgB;AAC3B;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;;;;;;;;;;;;;;;AC3CA;AACA;AACA;AACA;AACA;AAC6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,WAAW,0DAAgB;AAC3B;AACA;AACA;AACA,4CAA4C,oBAAoB,SAAS,oBAAoB;AAC7F;AACA,gGAAgG,SAAS;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;;;;;;;;;;;;;;;AC5DA;AACA;AACA;AACA;AACA;AAC6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,WAAW,0DAAgB;AAC3B;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;;;;;;;;;;;;;;;ACzDA;AACA;AACA;AACA;AACA;AAC6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,WAAW,0DAAgB;AAC3B;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,uEAAuE,KAAK;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;;;;;;;;;;;;;;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,WAAW,sDAAQ;AACnB;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgE;AACnC;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,eAAe;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,KAAK;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,KAAK;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,+DAAkB;AACxD;AACA;AACA;AACA,+BAA+B,+DAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wDAAW;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F,QAAQ,gFAAgF;AACnL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F,QAAQ,mFAAmF;AACtL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,MAAM;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,2BAA2B,8BAA8B;AACzD;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mGAAmG,QAAQ,6EAA6E;AACxL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F,QAAQ,8EAA8E;AACjL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA,8GAA8G,iBAAiB;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACl3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,WAAW;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACwD;AACZ;AACN;AACb;AACzB;AACA;AACO,wBAAwB,kEAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,yBAAyB,kEAAe;AAC/C;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gDAAM;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8CAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wGAAwG,YAAY;AACpH;AACA;AACA,yGAAyG,YAAY;AACrH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gFAA6B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,KAAK;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AClNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+BAA+B;AACrD;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,WAAW,MAAM,UAAU,KAAK,WAAW,IAAI,WAAW,MAAM,gBAAgB;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,iBAAiB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,gBAAgB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,eAAe;AACvD;AACA;AACA;AACA,yCAAyC,sCAAsC;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,oCAAoC;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,sCAAsC;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,MAAM,SAAS,kBAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qBAAqB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,EAAE;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnkCqe;AACre;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACDuF;AACvF;;;;;;;UCDA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;ACN4E;AACX;AACjE;AACA,gFAAe;AACf;AACA,qBAAqB,6DAAQ;AAC7B;AACA,yBAAyB,iEAAY;AACrC;AACA;AACA;AACA;AACA,IAAI,yEAAY;AAChB;AACA","sources":["webpack://@piyoppi/pico2map-samples/../map-editor-components/dist/AutoTileSelectorComponent.js","webpack://@piyoppi/pico2map-samples/../map-editor-components/dist/ColisionMarkerComponent.js","webpack://@piyoppi/pico2map-samples/../map-editor-components/dist/Events.js","webpack://@piyoppi/pico2map-samples/../map-editor-components/dist/Helpers/CursorPositionCalculator.js","webpack://@piyoppi/pico2map-samples/../map-editor-components/dist/MapCanvasComponent.js","webpack://@piyoppi/pico2map-samples/../map-editor-components/dist/MapChipSelectorComponent.js","webpack://@piyoppi/pico2map-samples/../map-editor-components/dist/MapGridComponent.js","webpack://@piyoppi/pico2map-samples/../map-editor-components/dist/PickedArrangementSelector.js","webpack://@piyoppi/pico2map-samples/../map-editor-components/dist/main.js","webpack://@piyoppi/pico2map-samples/../map-editor/dist/AutoTileSelector.js","webpack://@piyoppi/pico2map-samples/../map-editor/dist/Brushes/Arrangements/Arrangement.js","webpack://@piyoppi/pico2map-samples/../map-editor/dist/Brushes/Arrangements/Arrangements.js","webpack://@piyoppi/pico2map-samples/../map-editor/dist/Brushes/Arrangements/AutoTileArrangement.js","webpack://@piyoppi/pico2map-samples/../map-editor/dist/Brushes/Arrangements/AutoTileEraseArrangement.js","webpack://@piyoppi/pico2map-samples/../map-editor/dist/Brushes/Arrangements/ColiderArrangement.js","webpack://@piyoppi/pico2map-samples/../map-editor/dist/Brushes/Arrangements/DefaultArrangement.js","webpack://@piyoppi/pico2map-samples/../map-editor/dist/Brushes/Arrangements/DefaultEraseArrangement.js","webpack://@piyoppi/pico2map-samples/../map-editor/dist/Brushes/Arrangements/EraseArrangement.js","webpack://@piyoppi/pico2map-samples/../map-editor/dist/Brushes/Brushes.js","webpack://@piyoppi/pico2map-samples/../map-editor/dist/Brushes/Pen.js","webpack://@piyoppi/pico2map-samples/../map-editor/dist/Brushes/RectangleBrush.js","webpack://@piyoppi/pico2map-samples/../map-editor/dist/CallbackCaller.js","webpack://@piyoppi/pico2map-samples/../map-editor/dist/CallbackCallers.js","webpack://@piyoppi/pico2map-samples/../map-editor/dist/CallbackItem.js","webpack://@piyoppi/pico2map-samples/../map-editor/dist/ColiderCanvas.js","webpack://@piyoppi/pico2map-samples/../map-editor/dist/ColiderRenderer.js","webpack://@piyoppi/pico2map-samples/../map-editor/dist/CursorPositionConverter.js","webpack://@piyoppi/pico2map-samples/../map-editor/dist/GridImageGenerator.js","webpack://@piyoppi/pico2map-samples/../map-editor/dist/Injector.js","webpack://@piyoppi/pico2map-samples/../map-editor/dist/MapCanvas.js","webpack://@piyoppi/pico2map-samples/../map-editor/dist/MapChipPicker.js","webpack://@piyoppi/pico2map-samples/../map-editor/dist/MapChipSelector.js","webpack://@piyoppi/pico2map-samples/../map-editor/dist/Projects.js","webpack://@piyoppi/pico2map-samples/../map-editor/dist/main.js","webpack://@piyoppi/pico2map-samples/../tiled-map/dist/AutoTile/AutoTile.js","webpack://@piyoppi/pico2map-samples/../tiled-map/dist/AutoTile/AutoTiles.js","webpack://@piyoppi/pico2map-samples/../tiled-map/dist/AutoTile/DefaultAutoTileImportStrategy.js","webpack://@piyoppi/pico2map-samples/../tiled-map/dist/MapChip.js","webpack://@piyoppi/pico2map-samples/../tiled-map/dist/MapChipImage.js","webpack://@piyoppi/pico2map-samples/../tiled-map/dist/MapChipsCollection.js","webpack://@piyoppi/pico2map-samples/../tiled-map/dist/MapData/ColiderMap.js","webpack://@piyoppi/pico2map-samples/../tiled-map/dist/MapData/MapMatrix.js","webpack://@piyoppi/pico2map-samples/../tiled-map/dist/MapData/MapPaletteMatrix.js","webpack://@piyoppi/pico2map-samples/../tiled-map/dist/MapData/TiledMapData.js","webpack://@piyoppi/pico2map-samples/../tiled-map/dist/MapData/TransferEach.js","webpack://@piyoppi/pico2map-samples/../tiled-map/dist/MapRenderer.js","webpack://@piyoppi/pico2map-samples/../tiled-map/dist/TiledMap.js","webpack://@piyoppi/pico2map-samples/../tiled-map/dist/main.js","webpack://@piyoppi/pico2map-samples/../../node_modules/@lit/reactive-element/development/css-tag.js","webpack://@piyoppi/pico2map-samples/../../node_modules/@lit/reactive-element/development/decorators/base.js","webpack://@piyoppi/pico2map-samples/../../node_modules/@lit/reactive-element/development/decorators/custom-element.js","webpack://@piyoppi/pico2map-samples/../../node_modules/@lit/reactive-element/development/decorators/event-options.js","webpack://@piyoppi/pico2map-samples/../../node_modules/@lit/reactive-element/development/decorators/property.js","webpack://@piyoppi/pico2map-samples/../../node_modules/@lit/reactive-element/development/decorators/query-all.js","webpack://@piyoppi/pico2map-samples/../../node_modules/@lit/reactive-element/development/decorators/query-assigned-nodes.js","webpack://@piyoppi/pico2map-samples/../../node_modules/@lit/reactive-element/development/decorators/query-async.js","webpack://@piyoppi/pico2map-samples/../../node_modules/@lit/reactive-element/development/decorators/query.js","webpack://@piyoppi/pico2map-samples/../../node_modules/@lit/reactive-element/development/decorators/state.js","webpack://@piyoppi/pico2map-samples/../../node_modules/@lit/reactive-element/development/reactive-element.js","webpack://@piyoppi/pico2map-samples/../../node_modules/lit-element/development/lit-element.js","webpack://@piyoppi/pico2map-samples/../../node_modules/lit-html/development/lit-html.js","webpack://@piyoppi/pico2map-samples/../../node_modules/lit/decorators.js","webpack://@piyoppi/pico2map-samples/../../node_modules/lit/index.js","webpack://@piyoppi/pico2map-samples/webpack/bootstrap","webpack://@piyoppi/pico2map-samples/webpack/runtime/define property getters","webpack://@piyoppi/pico2map-samples/webpack/runtime/hasOwnProperty shorthand","webpack://@piyoppi/pico2map-samples/webpack/runtime/make namespace object","webpack://@piyoppi/pico2map-samples/./minimum_example/src/minimum_example.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 piyoppi\n * SPDX-License-Identifier: MIT\n */\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { LitElement, html, css } from 'lit';\nimport { property } from 'lit/decorators.js';\nimport { CursorPositionCalculator } from './Helpers/CursorPositionCalculator';\nimport { GridImageGenerator, Projects, AutoTileSelector } from '@piyoppi/pico2map-editor';\nexport class AutoTileSelectorComponent extends LitElement {\n    constructor() {\n        super(...arguments);\n        this._gridImageSrc = '';\n        this.gridImageGenerator = new GridImageGenerator();\n        this.cursorPositionCalculator = new CursorPositionCalculator();\n        this._indexImage = document.createElement('canvas');\n        this._project = null;\n        this._autoTileSelector = null;\n        this._afterAddAutoTileCallbackItem = null;\n        this._afterRemoveAutoTileCallbackItem = null;\n        this._afterReplacedMapChipImageCallbackItem = null;\n        this._projectId = -1;\n        this._width = 192;\n        this.cursorChipX = 0;\n        this.cursorChipY = 0;\n        this.selectedChipY = -1;\n        this.selectedChipX = -1;\n        this.indexImageSrc = '';\n    }\n    get gridColor() {\n        return this.gridImageGenerator.gridColor;\n    }\n    set gridColor(value) {\n        const oldValue = this.gridImageGenerator.gridColor;\n        this.gridImageGenerator.gridColor = value;\n        this.requestUpdate('gridColor', oldValue);\n    }\n    get projectId() {\n        return this._projectId;\n    }\n    set projectId(value) {\n        const oldValue = this._projectId;\n        this._projectId = value;\n        this._setupProject();\n        this.setupMapChipSelector();\n        this.requestUpdate('projectId', oldValue);\n    }\n    get width() {\n        return this._width;\n    }\n    set width(value) {\n        const oldValue = this._width;\n        this._width = value;\n        this.setupMapChipSelector();\n        this.requestUpdate('width', oldValue);\n    }\n    get project() {\n        return this._project;\n    }\n    get gridWidth() {\n        var _a;\n        return ((_a = this._project) === null || _a === void 0 ? void 0 : _a.tiledMap.chipWidth) || 0;\n    }\n    get gridHeight() {\n        var _a;\n        return ((_a = this._project) === null || _a === void 0 ? void 0 : _a.tiledMap.chipHeight) || 0;\n    }\n    get cursorPosition() {\n        return {\n            x: this.cursorChipX * this.gridWidth,\n            y: this.cursorChipY * this.gridHeight\n        };\n    }\n    get selectedPosition() {\n        return {\n            x: this.selectedChipX * this.gridWidth,\n            y: this.selectedChipY * this.gridHeight\n        };\n    }\n    get subscribedProjectEvent() {\n        return !!this._afterAddAutoTileCallbackItem && !!this._afterRemoveAutoTileCallbackItem && !!this._afterReplacedMapChipImageCallbackItem;\n    }\n    _setupProject() {\n        var _a;\n        if (((_a = this._project) === null || _a === void 0 ? void 0 : _a.projectId) === this._projectId)\n            return;\n        if (this._project) {\n            this._unsubscribeProjectEvent();\n        }\n        this._project = Projects.fromProjectId(this._projectId);\n        if (!this._project) {\n            this.reset();\n            return;\n        }\n        this._subscribeProjectEvent();\n        this._autoTileSelector = new AutoTileSelector(this.width, this._project.tiledMap.chipWidth, this._project.tiledMap.chipHeight, this._project.tiledMap.autoTiles, this._project.tiledMap.mapChipsCollection);\n        this.selectedChipX = -1;\n        this.selectedChipY = -1;\n    }\n    _subscribeProjectEvent() {\n        if (!this._project)\n            return;\n        if (!this._afterAddAutoTileCallbackItem)\n            this._afterAddAutoTileCallbackItem = this._project.setCallback('afterAddAutoTile', () => this.setupMapChipSelector());\n        if (!this._afterRemoveAutoTileCallbackItem)\n            this._afterRemoveAutoTileCallbackItem = this._project.setCallback('afterRemoveAutoTile', () => this.setupMapChipSelector());\n        if (!this._afterReplacedMapChipImageCallbackItem)\n            this._afterReplacedMapChipImageCallbackItem = this._project.setCallback('afterReplacedMapChipImage', () => this.setupMapChipSelector());\n    }\n    _unsubscribeProjectEvent() {\n        if (!this._project)\n            return;\n        if (this._afterAddAutoTileCallbackItem)\n            this._project.removeCallback('afterAddAutoTile', this._afterAddAutoTileCallbackItem);\n        if (this._afterRemoveAutoTileCallbackItem)\n            this._project.removeCallback('afterRemoveAutoTile', this._afterRemoveAutoTileCallbackItem);\n        if (this._afterReplacedMapChipImageCallbackItem)\n            this._project.removeCallback('afterReplacedMapChipImage', this._afterReplacedMapChipImageCallbackItem);\n        this._afterAddAutoTileCallbackItem = null;\n        this._afterRemoveAutoTileCallbackItem = null;\n        this._afterReplacedMapChipImageCallbackItem = null;\n    }\n    reset() {\n        this.indexImageSrc = '';\n    }\n    setupMapChipSelector() {\n        if (!this._project || !this._autoTileSelector)\n            return;\n        if (this._project.tiledMap.autoTiles.length > 0) {\n            this._autoTileSelector.canvasWidth = this.width;\n            const imageSize = this._autoTileSelector.getSizeOfIndexImage();\n            this._indexImage.width = imageSize.width;\n            this._indexImage.height = imageSize.height;\n            this._autoTileSelector.generateIndexImage(this._indexImage);\n            this.indexImageSrc = this._indexImage.toDataURL();\n        }\n        else {\n            this.reset();\n        }\n    }\n    mouseMove(e) {\n        if (!this._autoTileSelector)\n            return;\n        const mouseCursorPosition = this.cursorPositionCalculator.getMouseCursorPosition(e.pageX, e.pageY);\n        const position = this._autoTileSelector.convertFromIndexImageToChipPosition(mouseCursorPosition.x, mouseCursorPosition.y);\n        this.cursorChipX = position.x;\n        this.cursorChipY = position.y;\n    }\n    mouseDown(e) {\n        if (!this._project || !this._autoTileSelector)\n            return;\n        const mouseCursorPosition = this.cursorPositionCalculator.getMouseCursorPosition(e.pageX, e.pageY);\n        const selectedAutoTile = this._autoTileSelector.getAutoTileFragmentFromIndexImagePosition(mouseCursorPosition.x, mouseCursorPosition.y);\n        if (!selectedAutoTile)\n            return;\n        this.selectedChipX = Math.floor(mouseCursorPosition.x / this._project.tiledMap.chipWidth);\n        this.selectedChipY = Math.floor(mouseCursorPosition.y / this._project.tiledMap.chipHeight);\n        this.dispatchEvent(new CustomEvent('autotile-selected', {\n            detail: { id: selectedAutoTile.id },\n            bubbles: true,\n            composed: true\n        }));\n    }\n    firstUpdated() {\n        var _a;\n        const element = (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.getElementById('boundary');\n        if (element)\n            this.cursorPositionCalculator.setElement(element);\n    }\n    render() {\n        this.gridImageGenerator.setGridSize(this.gridWidth, this.gridHeight);\n        if (this.gridImageGenerator.changed) {\n            this._gridImageSrc = this.gridImageGenerator.generateLinePart().toDataURL();\n        }\n        const cursorWidth = this.gridWidth;\n        const cursorHeight = this.gridHeight;\n        return html `\n      <style>\n        .grid {\n          background-image: url(\"${this._gridImageSrc}\");\n          width: ${this._indexImage.width}px;\n          height: ${this._indexImage.height}px;\n        }\n\n        .cursor {\n          width: ${cursorWidth}px;\n          height: ${cursorHeight}px;\n          left: ${this.cursorPosition.x}px;\n          top: ${this.cursorPosition.y}px;\n        }\n\n        .selected {\n          width: ${cursorWidth}px;\n          height: ${cursorHeight}px;\n          left: ${this.selectedPosition.x}px;\n          top: ${this.selectedPosition.y}px;\n        }\n      </style>\n\n      <div id=\"boundary\">\n        ${this.indexImageSrc ? html `\n          <img id=\"chip-image\" src=\"${this.indexImageSrc}\">\n          <div\n            class=\"grid-image grid\"\n            @mousemove=\"${(e) => this.mouseMove(e)}\"\n            @mousedown=\"${(e) => this.mouseDown(e)}\"\n          ></div>\n          <div class=\"cursor\"></div>\n          ${(this.selectedChipX >= 0 && this.selectedChipY >= 0) ? html `<div class=\"selected\"></div>` : null}\n        ` : null}\n      </div>\n    `;\n    }\n    static get styles() {\n        return css `\n      .grid-image {\n        position: absolute;\n        top: 0;\n        left: 0;\n        background-repeat: repeat;\n      }\n\n      .cursor, .selected {\n        position: absolute;\n        border-style: solid;\n        box-sizing: border-box;\n      }\n\n      .cursor {\n        border-color: red;\n        pointer-events: none;\n      }\n\n      .selected {\n        border-color: blue;\n        pointer-events: none;\n      }\n\n      #boundary {\n        position: relative;\n      }\n\n      #chip-image {\n        display: block;\n        user-select: none;\n      }\n    `;\n    }\n    disconnectedCallback() {\n        super.disconnectedCallback();\n        this._unsubscribeProjectEvent();\n    }\n    connectedCallback() {\n        super.connectedCallback();\n        this._subscribeProjectEvent();\n    }\n}\nAutoTileSelectorComponent.Format = {\n    width: 1,\n    height: 5\n};\n__decorate([\n    property({ type: String })\n], AutoTileSelectorComponent.prototype, \"gridColor\", null);\n__decorate([\n    property({ type: Number })\n], AutoTileSelectorComponent.prototype, \"projectId\", null);\n__decorate([\n    property({ type: Number })\n], AutoTileSelectorComponent.prototype, \"width\", null);\n__decorate([\n    property({ type: Number })\n], AutoTileSelectorComponent.prototype, \"cursorChipX\", void 0);\n__decorate([\n    property({ type: Number })\n], AutoTileSelectorComponent.prototype, \"cursorChipY\", void 0);\n__decorate([\n    property({ type: Number })\n], AutoTileSelectorComponent.prototype, \"selectedChipY\", void 0);\n__decorate([\n    property({ type: Number })\n], AutoTileSelectorComponent.prototype, \"selectedChipX\", void 0);\n__decorate([\n    property({ type: String })\n], AutoTileSelectorComponent.prototype, \"indexImageSrc\", void 0);\n","/**\n * @license\n * Copyright 2021 piyoppi\n * SPDX-License-Identifier: MIT\n */\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { LitElement, html, css } from 'lit';\nimport { property } from 'lit/decorators.js';\nimport { CursorPositionCalculator } from './Helpers/CursorPositionCalculator';\nimport { GridImageGenerator, Projects, ColiderCanvas } from '@piyoppi/pico2map-editor';\nexport class ColiderMarkerComponent extends LitElement {\n    constructor() {\n        super();\n        this._gridImageSrc = '';\n        this._gridImageGenerator = new GridImageGenerator();\n        this._cursorPositionCalculator = new CursorPositionCalculator();\n        this._coliderCanvas = new ColiderCanvas();\n        this._project = null;\n        this._coliderCanvasElement = null;\n        this._secondaryCanvasElement = null;\n        this._documentMouseMoveEventCallee = null;\n        this._documentMouseUpEventCallee = null;\n        this._documentTouchMoveEventCallee = null;\n        this._documentTouchEndEventCallee = null;\n        this.cursorChipX = 0;\n        this.cursorChipY = 0;\n        this.preventDefaultContextMenu = true;\n        this._projectId = -1;\n        this._brushName = '';\n        Projects.setProjectAddCallbackFunction(() => this.setupProject());\n    }\n    get gridColor() {\n        return this._gridImageGenerator.gridColor;\n    }\n    set gridColor(value) {\n        const oldValue = this._gridImageGenerator.gridColor;\n        this._gridImageGenerator.gridColor = value;\n        this.requestUpdate('gridColor', oldValue);\n    }\n    get projectId() {\n        return this._projectId;\n    }\n    set projectId(value) {\n        const oldValue = this._projectId;\n        this._projectId = value;\n        this.setupProject();\n        this.requestUpdate('projectId', oldValue);\n    }\n    get brush() {\n        return this._brushName;\n    }\n    set brush(value) {\n        const oldValue = this._brushName;\n        this._brushName = value;\n        this._coliderCanvas.setBrushFromName(this._brushName);\n        this.requestUpdate('brush', oldValue);\n    }\n    get coliderType() {\n        return this._coliderCanvas.selectedColiderType;\n    }\n    set coliderType(value) {\n        const oldValue = value;\n        this.requestUpdate('coliderType', oldValue);\n        this._coliderCanvas.setColiderType(value);\n    }\n    get subColiderType() {\n        return this._coliderCanvas.selectedSubColiderType;\n    }\n    set subColiderType(value) {\n        const oldValue = value;\n        this.requestUpdate('subColiderType', oldValue);\n        this._coliderCanvas.setSubColiderType(value);\n    }\n    get width() {\n        return this.xCount * this.gridWidth;\n    }\n    get height() {\n        return this.yCount * this.gridHeight;\n    }\n    get xCount() {\n        var _a;\n        return ((_a = this._project) === null || _a === void 0 ? void 0 : _a.tiledMap.chipCountX) || 0;\n    }\n    get yCount() {\n        var _a;\n        return ((_a = this._project) === null || _a === void 0 ? void 0 : _a.tiledMap.chipCountY) || 0;\n    }\n    get gridWidth() {\n        var _a;\n        return ((_a = this._project) === null || _a === void 0 ? void 0 : _a.tiledMap.chipWidth) || 0;\n    }\n    get gridHeight() {\n        var _a;\n        return ((_a = this._project) === null || _a === void 0 ? void 0 : _a.tiledMap.chipHeight) || 0;\n    }\n    get cursorPosition() {\n        return {\n            x: this.cursorChipX * this.gridWidth,\n            y: this.cursorChipY * this.gridHeight\n        };\n    }\n    get coliderCanvas() {\n        return this._coliderCanvas;\n    }\n    setupProject() {\n        if (this._project && this._project.projectId === this._projectId)\n            return;\n        if (this._project) {\n            this._coliderCanvas.unsubscribeProjectEvent();\n        }\n        this._project = Projects.fromProjectId(this._projectId);\n        if (!this._project)\n            return;\n        this._coliderCanvas.setProject(this._project);\n        if (!this._coliderCanvas.isSubscribedProjectEvent)\n            this._coliderCanvas.subscribeProjectEvent();\n        this.requestUpdate();\n    }\n    firstUpdated() {\n        var _a, _b, _c;\n        const element = (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.getElementById('boundary');\n        if (element)\n            this._cursorPositionCalculator.setElement(element);\n        this._coliderCanvasElement = (_b = this.shadowRoot) === null || _b === void 0 ? void 0 : _b.getElementById('colider-canvas');\n        this._secondaryCanvasElement = (_c = this.shadowRoot) === null || _c === void 0 ? void 0 : _c.getElementById('secondary-canvas');\n        if (this._secondaryCanvasElement && this._coliderCanvasElement) {\n            this._coliderCanvas.setCanvas(this._coliderCanvasElement, this._secondaryCanvasElement);\n        }\n    }\n    mouseDown(e) {\n        const mouseCursorPosition = this._cursorPositionCalculator.getMouseCursorPosition(e.pageX, e.pageY);\n        this._coliderCanvas.mouseDown(mouseCursorPosition.x, mouseCursorPosition.y, e.button === 2);\n        this._documentMouseMoveEventCallee = e => this.mouseMove(e);\n        this._documentMouseUpEventCallee = e => this.mouseUp(e);\n        document.addEventListener('mousemove', this._documentMouseMoveEventCallee);\n        document.addEventListener('mouseup', this._documentMouseUpEventCallee);\n    }\n    mouseMove(e) {\n        const mouseCursorPosition = this._cursorPositionCalculator.getMouseCursorPosition(e.pageX, e.pageY);\n        const cursor = this._coliderCanvas.mouseMove(mouseCursorPosition.x, mouseCursorPosition.y);\n        this.cursorChipX = cursor.x;\n        this.cursorChipY = cursor.y;\n    }\n    mouseUp(e) {\n        const mouseCursorPosition = this._cursorPositionCalculator.getMouseCursorPosition(e.pageX, e.pageY);\n        this._coliderCanvas.mouseUp();\n        if (this._documentMouseMoveEventCallee)\n            document.removeEventListener('mousemove', this._documentMouseMoveEventCallee);\n        if (this._documentMouseUpEventCallee)\n            document.removeEventListener('mouseup', this._documentMouseUpEventCallee);\n        this._documentMouseMoveEventCallee = null;\n        this._documentMouseUpEventCallee = null;\n    }\n    touchStart(e) {\n        if (e.touches.length > 1) {\n            this._coliderCanvas.reset();\n            this._touchReset();\n            return;\n        }\n        const mouseCursorPosition = this._cursorPositionCalculator.getMouseCursorPosition(e.touches[0].clientX, e.touches[0].clientY);\n        this._coliderCanvas.mouseDown(mouseCursorPosition.x, mouseCursorPosition.y);\n        this._documentTouchMoveEventCallee = e => this.touchMove(e);\n        this._documentTouchEndEventCallee = e => this.touchEnd(e);\n        document.addEventListener('touchmove', this._documentTouchMoveEventCallee);\n        document.addEventListener('touchend', this._documentTouchEndEventCallee);\n    }\n    touchMove(e) {\n        const mouseCursorPosition = this._cursorPositionCalculator.getMouseCursorPosition(e.touches[0].clientX, e.touches[0].clientY);\n        this._coliderCanvas.mouseMove(mouseCursorPosition.x, mouseCursorPosition.y);\n    }\n    touchEnd(e) {\n        this._coliderCanvas.mouseUp();\n        this._touchReset();\n    }\n    _touchReset() {\n        if (this._documentTouchMoveEventCallee)\n            document.removeEventListener('touchmove', this._documentTouchMoveEventCallee);\n        if (this._documentTouchEndEventCallee)\n            document.removeEventListener('touchend', this._documentTouchEndEventCallee);\n        this._documentTouchMoveEventCallee = null;\n        this._documentTouchEndEventCallee = null;\n    }\n    render() {\n        this._gridImageGenerator.setGridSize(this.gridWidth, this.gridHeight);\n        if (this._gridImageGenerator.changed) {\n            this._gridImageSrc = this._gridImageGenerator.generateLinePart().toDataURL();\n        }\n        return html `\n      <style>\n        .grid {\n          background-image: url(\"${this._gridImageSrc}\");\n        }\n\n        #boundary {\n          width: ${this.width + 1}px;\n          height: ${this.height + 1}px;\n        }\n\n        .cursor {\n          width: ${this.gridWidth}px;\n          height: ${this.gridHeight}px;\n          left: ${this.cursorPosition.x}px;\n          top: ${this.cursorPosition.y}px;\n        }\n\n        .grid-image {\n          background-position: 1px 1px\n        }\n      </style>\n\n      <div id=\"boundary\">\n        <canvas\n          id=\"colider-canvas\"\n          width=\"${this.width}\"\n          height=\"${this.height}\"\n        ></canvas>\n        <canvas\n          id=\"secondary-canvas\"\n          width=\"${this.width}\"\n          height=\"${this.height}\"\n        ></canvas>\n        <div\n          class=\"grid-image grid\"\n          @mousedown=\"${(e) => this.mouseDown(e)}\"\n          @touchstart=\"${(e) => this.touchStart(e)}\"\n          @contextmenu=\"${(e) => this.preventDefaultContextMenu && e.preventDefault()}\"\n        ></div>\n        <div class=\"cursor\"></div>\n      </div>\n    `;\n    }\n    static get styles() {\n        return css `\n      .grid-image {\n        position: absolute;\n        top: 0;\n        left: 0;\n        background-repeat: repeat;\n        width: 100%;\n        height: 100%;\n      }\n\n      .cursor {\n        position: absolute;\n        border-style: solid;\n        box-sizing: border-box;\n        border-color: red;\n        pointer-events: none;\n      }\n\n      #boundary {\n        position: relative;\n      }\n\n      #secondary-canvas, #colider-canvas {\n        pointer-events: none;\n        position: absolute;\n        top: 0;\n        left: 0;\n      }\n    `;\n    }\n    disconnectedCallback() {\n        super.disconnectedCallback();\n        this._coliderCanvas.unsubscribeProjectEvent();\n    }\n    connectedCallback() {\n        super.connectedCallback();\n        if (this._coliderCanvas.hasProject && !this._coliderCanvas.isSubscribedProjectEvent)\n            this._coliderCanvas.subscribeProjectEvent();\n    }\n}\n__decorate([\n    property({ type: Number })\n], ColiderMarkerComponent.prototype, \"cursorChipX\", void 0);\n__decorate([\n    property({ type: Number })\n], ColiderMarkerComponent.prototype, \"cursorChipY\", void 0);\n__decorate([\n    property({ type: Boolean })\n], ColiderMarkerComponent.prototype, \"preventDefaultContextMenu\", void 0);\n__decorate([\n    property({ type: String })\n], ColiderMarkerComponent.prototype, \"gridColor\", null);\n__decorate([\n    property({ type: Number })\n], ColiderMarkerComponent.prototype, \"projectId\", null);\n__decorate([\n    property({ type: String })\n], ColiderMarkerComponent.prototype, \"brush\", null);\n__decorate([\n    property({ type: Number })\n], ColiderMarkerComponent.prototype, \"coliderType\", null);\n__decorate([\n    property({ type: Number })\n], ColiderMarkerComponent.prototype, \"subColiderType\", null);\n","/**\n * @license\n * Copyright 2021 piyoppi\n * SPDX-License-Identifier: MIT\n */\nexport class MapChipSelectedEvent extends CustomEvent {\n    constructor(detail) {\n        super('mapchip-selected', { detail });\n    }\n}\nexport class AutoTileSelectedEvent extends CustomEvent {\n    constructor(detail) {\n        super('autotile-selected', { detail });\n    }\n}\nexport class PickedMapChipEvent extends CustomEvent {\n    constructor(detail) {\n        super('mapchip-picked', { detail });\n    }\n}\n","/**\n * @license\n * Copyright 2021 piyoppi\n * SPDX-License-Identifier: MIT\n */\nexport class CursorPositionCalculator {\n    constructor() {\n        this._element = null;\n    }\n    setElement(element) {\n        this._element = element;\n    }\n    getMouseCursorPosition(pageX, pageY) {\n        if (!this._element)\n            return { x: 0, y: 0 };\n        const rect = this._element.getBoundingClientRect();\n        return {\n            x: (pageX - window.scrollX - rect.x),\n            y: (pageY - window.scrollY - rect.y)\n        };\n    }\n}\n","/**\n * @license\n * Copyright 2021 piyoppi\n * SPDX-License-Identifier: MIT\n */\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { LitElement, html, css } from 'lit';\nimport { property } from 'lit/decorators.js';\nimport { CursorPositionCalculator } from './Helpers/CursorPositionCalculator';\nimport { MapCanvas, Projects } from '@piyoppi/pico2map-editor';\nimport { MapChipFragment } from '@piyoppi/pico2map-tiled';\nexport class MapCanvasComponent extends LitElement {\n    constructor() {\n        super();\n        this.cursorPositionCalculator = new CursorPositionCalculator();\n        this._mapCanvas = new MapCanvas();\n        this._project = null;\n        this._secondaryCanvasElement = null;\n        this._canvasesOuterElement = null;\n        this._autoTileIdAttributeValue = -1;\n        this._inactiveLayerOpacity = 1.0;\n        this._appendedLayerCanvases = [];\n        this._canvasMaxIds = 1;\n        this._beforeAddLayerCallbackItem = null;\n        this._afterResizedMapCallbackItem = null;\n        this._selectedMapChipFragmentBoundarySize = { width: 1, height: 1 };\n        this._documentMouseMoveEventCallee = null;\n        this._documentMouseUpEventCallee = null;\n        this._documentTouchMoveEventCallee = null;\n        this._documentTouchEndEventCallee = null;\n        this.gridCursorHidden = false;\n        this.preventDefaultContextMenu = true;\n        this.gridColor = '#000';\n        this._projectId = -1;\n        this._brushName = '';\n        this._arrangementName = '';\n        Projects.setProjectAddCallbackFunction(() => this.setupProject());\n        this._mapCanvas.setPickedCallback((picked => {\n            this.dispatchEvent(new CustomEvent('mapchip-picked', {\n                detail: { picked },\n                bubbles: true,\n                composed: true\n            }));\n        }));\n    }\n    get inactiveLayerOpacity() {\n        return this._inactiveLayerOpacity;\n    }\n    set inactiveLayerOpacity(value) {\n        const oldValue = this._inactiveLayerOpacity;\n        this._inactiveLayerOpacity = value;\n        this.setInactiveCanvasStyle();\n        this.requestUpdate('inactiveLayerOpacity', oldValue);\n    }\n    get projectId() {\n        return this._projectId;\n    }\n    set projectId(value) {\n        const oldValue = this._projectId;\n        this._projectId = value;\n        this.setupProject();\n        this.requestUpdate('projectId', oldValue);\n    }\n    get brush() {\n        return this._brushName;\n    }\n    set brush(value) {\n        const oldValue = this._brushName;\n        this._brushName = value;\n        this._mapCanvas.setBrushFromName(this._brushName);\n        this.requestUpdate('brush', oldValue);\n    }\n    get arrangement() {\n        return this._arrangementName;\n    }\n    set arrangement(value) {\n        const oldValue = this._arrangementName;\n        this._arrangementName = value;\n        this._mapCanvas.setArrangementFromName(this._arrangementName);\n        this.requestUpdate('arrangement', oldValue);\n    }\n    get autoTileId() {\n        var _a;\n        return ((_a = this._mapCanvas.selectedAutoTile) === null || _a === void 0 ? void 0 : _a.id) || -1;\n    }\n    set autoTileId(value) {\n        var _a;\n        const oldValue = value;\n        const autoTile = (_a = this._project) === null || _a === void 0 ? void 0 : _a.tiledMap.autoTiles.fromId(value);\n        this._autoTileIdAttributeValue = value;\n        this.setActiveAutoTile(true);\n        this.requestUpdate('autoTileId', oldValue);\n    }\n    get mapChipFragmentProperties() {\n        var _a;\n        return ((_a = this._mapCanvas.selectedMapChipFragments) === null || _a === void 0 ? void 0 : _a.map(mapChipFragment => mapChipFragment.toObject())) || null;\n    }\n    set mapChipFragmentProperties(values) {\n        const oldValue = values;\n        this.requestUpdate('mapChipFragmentProperties', oldValue);\n        if (!values)\n            return;\n        const mapChipFragments = values.map(value => MapChipFragment.fromObject(value));\n        this._mapCanvas.setMapChipFragments(mapChipFragments);\n        this._selectedMapChipFragmentBoundarySize = this._mapCanvas.selectedMapChipFragmentBoundarySize;\n    }\n    get activeLayer() {\n        return this._mapCanvas.activeLayer;\n    }\n    set activeLayer(value) {\n        this._mapCanvas.setActiveLayer(value);\n        this.setInactiveCanvasStyle();\n    }\n    get pickFromActiveLayer() {\n        return this._mapCanvas.isPickFromActiveLayer;\n    }\n    set pickFromActiveLayer(value) {\n        this._mapCanvas.isPickFromActiveLayer = value;\n    }\n    get width() {\n        return this.xCount * this.gridWidth;\n    }\n    get height() {\n        return this.yCount * this.gridHeight;\n    }\n    get xCount() {\n        var _a;\n        return ((_a = this._project) === null || _a === void 0 ? void 0 : _a.tiledMap.chipCountX) || 0;\n    }\n    get yCount() {\n        var _a;\n        return ((_a = this._project) === null || _a === void 0 ? void 0 : _a.tiledMap.chipCountY) || 0;\n    }\n    get gridWidth() {\n        var _a;\n        return ((_a = this._project) === null || _a === void 0 ? void 0 : _a.tiledMap.chipWidth) || 0;\n    }\n    get gridHeight() {\n        var _a;\n        return ((_a = this._project) === null || _a === void 0 ? void 0 : _a.tiledMap.chipHeight) || 0;\n    }\n    get mapCanvas() {\n        return this._mapCanvas;\n    }\n    get isSubscribedProjectEvent() {\n        return !!this._beforeAddLayerCallbackItem && !!this._afterResizedMapCallbackItem;\n    }\n    set mapCanvas(value) {\n        this._mapCanvas = value;\n    }\n    setupProject() {\n        if (this._project && this._project.projectId === this._projectId)\n            return;\n        if (this._project) {\n            this._mapCanvas.unsubscribeProjectEvent();\n            this._unsubscribeProjectEvent();\n        }\n        this._project = Projects.fromProjectId(this._projectId);\n        if (!this._project)\n            return;\n        this._mapCanvas.setProject(this._project);\n        if (!this._mapCanvas.isSubscribedProjectEvent)\n            this._mapCanvas.subscribeProjectEvent();\n        if (!this.isSubscribedProjectEvent)\n            this._subscribeProjectEvent();\n        this._mapCanvas.firstRenderAll();\n        this.setupMapCanvas();\n        this.setActiveAutoTile();\n        this.requestUpdate();\n    }\n    _subscribeProjectEvent() {\n        if (!this._project || this.isSubscribedProjectEvent)\n            return;\n        this._beforeAddLayerCallbackItem = this._project.setCallback('beforeAddLayer', () => this._mapCanvas.addCanvas(this.addCanvasToDOMTree()));\n        this._afterResizedMapCallbackItem = this._project.setCallback('afterResizedMap', () => {\n            this.requestUpdate();\n            this._appendedLayerCanvases.forEach(canvas => {\n                canvas.width = this.width;\n                canvas.height = this.height;\n            });\n            this._mapCanvas.renderAll();\n        });\n    }\n    _unsubscribeProjectEvent() {\n        if (!this._project)\n            return;\n        if (this._beforeAddLayerCallbackItem)\n            this._project.removeCallback('beforeAddLayer', this._beforeAddLayerCallbackItem);\n        if (this._afterResizedMapCallbackItem)\n            this._project.removeCallback('afterResizedMap', this._afterResizedMapCallbackItem);\n        this._beforeAddLayerCallbackItem = null;\n        this._afterResizedMapCallbackItem = null;\n    }\n    createCanvas() {\n        const canvas = document.createElement('canvas');\n        this.setupCanvas(canvas);\n        canvas.width = this.width;\n        canvas.height = this.height;\n        return canvas;\n    }\n    setupCanvas(canvas) {\n        canvas.width = this.width;\n        canvas.height = this.height;\n        const ctx = canvas.getContext('2d');\n        ctx === null || ctx === void 0 ? void 0 : ctx.clearRect(0, 0, this.width, this.height);\n    }\n    addCanvasToDOMTree() {\n        if (!this._canvasesOuterElement)\n            throw new Error();\n        const canvas = this.createCanvas();\n        canvas.id = `layer_canvas_${this._canvasMaxIds++}`;\n        this._canvasesOuterElement.appendChild(canvas);\n        this._appendedLayerCanvases.push(canvas);\n        return canvas;\n    }\n    removeCanvasToDOMTree(index) {\n        if (!this._canvasesOuterElement)\n            throw new Error();\n        const canvas = this._appendedLayerCanvases[index];\n        this._canvasesOuterElement.removeChild(canvas);\n        this._appendedLayerCanvases.splice(index, 1);\n    }\n    setActiveAutoTile(forced = false) {\n        if (!this._project || this._autoTileIdAttributeValue < 0)\n            return;\n        if (!this._mapCanvas.hasActiveAutoTile() || forced) {\n            const autoTile = this._project.tiledMap.autoTiles.fromId(this._autoTileIdAttributeValue);\n            if (!autoTile)\n                throw new Error(`AutoTile (id: ${this._autoTileIdAttributeValue}) is not found.`);\n            this._mapCanvas.setAutoTile(autoTile);\n        }\n    }\n    setupMapCanvas() {\n        if (!this._project || !this._secondaryCanvasElement || !this._canvasesOuterElement)\n            return;\n        const diffCanvasCount = this._project.tiledMap.datas.length - this._appendedLayerCanvases.length;\n        this._appendedLayerCanvases.forEach(canvas => this.setupCanvas(canvas));\n        if (diffCanvasCount > 0) {\n            for (let i = 0; i < diffCanvasCount; i++) {\n                this.addCanvasToDOMTree();\n            }\n        }\n        else if (diffCanvasCount < 0) {\n            const layerCanvasesLength = this._appendedLayerCanvases.length;\n            for (let i = layerCanvasesLength - 1; i >= layerCanvasesLength + diffCanvasCount; i--) {\n                this.removeCanvasToDOMTree(i);\n            }\n        }\n        this._mapCanvas.setCanvases(this._appendedLayerCanvases, this._secondaryCanvasElement);\n    }\n    setInactiveCanvasStyle() {\n        if (!this._canvasesOuterElement)\n            return;\n        this._canvasesOuterElement.childNodes.forEach((node, index) => {\n            const element = node;\n            if (this.activeLayer === index) {\n                element.style.opacity = '1.0';\n            }\n            else {\n                element.style.opacity = this._inactiveLayerOpacity.toString();\n            }\n        });\n    }\n    firstUpdated() {\n        var _a, _b, _c;\n        const element = (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.getElementById('boundary');\n        if (element)\n            this.cursorPositionCalculator.setElement(element);\n        this._secondaryCanvasElement = (_b = this.shadowRoot) === null || _b === void 0 ? void 0 : _b.getElementById('secondary-canvas');\n        this._canvasesOuterElement = (_c = this.shadowRoot) === null || _c === void 0 ? void 0 : _c.getElementById('canvases');\n        this.setupMapCanvas();\n    }\n    mouseDown(e) {\n        const mouseCursorPosition = this.cursorPositionCalculator.getMouseCursorPosition(e.pageX, e.pageY);\n        this._mapCanvas.mouseDown(mouseCursorPosition.x, mouseCursorPosition.y, e.button === 2);\n        this._documentMouseMoveEventCallee = e => this.mouseMove(e);\n        this._documentMouseUpEventCallee = e => this.mouseUp(e);\n        document.addEventListener('mousemove', this._documentMouseMoveEventCallee);\n        document.addEventListener('mouseup', this._documentMouseUpEventCallee);\n    }\n    mouseMove(e) {\n        const mouseCursorPosition = this.cursorPositionCalculator.getMouseCursorPosition(e.pageX, e.pageY);\n        this._mapCanvas.mouseMove(mouseCursorPosition.x, mouseCursorPosition.y);\n    }\n    mouseUp(e) {\n        this._mapCanvas.mouseUp();\n        if (this._documentMouseMoveEventCallee)\n            document.removeEventListener('mousemove', this._documentMouseMoveEventCallee);\n        if (this._documentMouseUpEventCallee)\n            document.removeEventListener('mouseup', this._documentMouseUpEventCallee);\n        this._documentMouseMoveEventCallee = null;\n        this._documentMouseUpEventCallee = null;\n    }\n    touchStart(e) {\n        if (e.touches.length > 1) {\n            this._mapCanvas.reset();\n            this._touchReset();\n            return;\n        }\n        const mouseCursorPosition = this.cursorPositionCalculator.getMouseCursorPosition(e.touches[0].clientX, e.touches[0].clientY);\n        this._mapCanvas.mouseDown(mouseCursorPosition.x, mouseCursorPosition.y, false);\n        this._documentTouchMoveEventCallee = e => this.touchMove(e);\n        this._documentTouchEndEventCallee = e => this.touchEnd(e);\n        document.addEventListener('touchmove', this._documentTouchMoveEventCallee);\n        document.addEventListener('touchend', this._documentTouchEndEventCallee);\n    }\n    touchMove(e) {\n        const mouseCursorPosition = this.cursorPositionCalculator.getMouseCursorPosition(e.touches[0].clientX, e.touches[0].clientY);\n        this._mapCanvas.mouseMove(mouseCursorPosition.x, mouseCursorPosition.y);\n    }\n    touchEnd(e) {\n        this._mapCanvas.mouseUp();\n        this._touchReset();\n    }\n    _touchReset() {\n        if (this._documentTouchMoveEventCallee)\n            document.removeEventListener('touchmove', this._documentTouchMoveEventCallee);\n        if (this._documentTouchEndEventCallee)\n            document.removeEventListener('touchend', this._documentTouchEndEventCallee);\n        this._documentTouchMoveEventCallee = null;\n        this._documentTouchEndEventCallee = null;\n    }\n    render() {\n        return html `\n      <style>\n        #boundary {\n          width: ${this.width + 1}px;\n          height: ${this.height + 1}px;\n        }\n      </style>\n\n      <div id=\"boundary\"\n        @mousedown=\"${(e) => this.mouseDown(e)}\"\n        @touchstart=\"${(e) => this.touchStart(e)}\"\n        @contextmenu=\"${(e) => this.preventDefaultContextMenu && e.preventDefault()}\"\n      >\n        <div id=\"canvases\"></div>\n        <canvas\n          id=\"secondary-canvas\"\n          width=\"${this.width}\"\n          height=\"${this.height}\"\n        ></canvas>\n        ${this.gridCursorHidden ? null : html `\n          <map-grid-component\n            gridWidth=\"${this.gridWidth}\"\n            gridHeight=\"${this.gridHeight}\"\n            chipCountX=\"${this.xCount}\"\n            chipCountY=\"${this.yCount}\"\n            gridColor=\"${this.gridColor}\"\n            cursorWidth=\"${this._selectedMapChipFragmentBoundarySize.width}\"\n            cursorHeight=\"${this._selectedMapChipFragmentBoundarySize.height}\"\n          ></map-grid-component>`}\n      </div>\n    `;\n    }\n    static get styles() {\n        return css `\n      #canvases {\n        position: relative;\n      }\n\n      #canvases > canvas {\n        position: absolute;\n        top: 0;\n        left: 0;\n      }\n\n      #boundary {\n        position: relative;\n      }\n\n      #secondary-canvas {\n        pointer-events: none;\n        position: absolute;\n        top: 0;\n        left: 0;\n      }\n    `;\n    }\n    disconnectedCallback() {\n        super.disconnectedCallback();\n        this._mapCanvas.unsubscribeProjectEvent();\n        this._unsubscribeProjectEvent();\n    }\n    connectedCallback() {\n        super.connectedCallback();\n        if (this._mapCanvas.hasProject && !this._mapCanvas.isSubscribedProjectEvent)\n            this._mapCanvas.subscribeProjectEvent();\n        if (this._project && !this.isSubscribedProjectEvent)\n            this._subscribeProjectEvent();\n    }\n}\n__decorate([\n    property({ type: Boolean })\n], MapCanvasComponent.prototype, \"gridCursorHidden\", void 0);\n__decorate([\n    property({ type: Boolean })\n], MapCanvasComponent.prototype, \"preventDefaultContextMenu\", void 0);\n__decorate([\n    property({ type: String })\n], MapCanvasComponent.prototype, \"gridColor\", void 0);\n__decorate([\n    property({ type: Number })\n], MapCanvasComponent.prototype, \"inactiveLayerOpacity\", null);\n__decorate([\n    property({ type: Number })\n], MapCanvasComponent.prototype, \"projectId\", null);\n__decorate([\n    property({ type: String })\n], MapCanvasComponent.prototype, \"brush\", null);\n__decorate([\n    property({ type: String })\n], MapCanvasComponent.prototype, \"arrangement\", null);\n__decorate([\n    property({ type: Number })\n], MapCanvasComponent.prototype, \"autoTileId\", null);\n__decorate([\n    property({ type: Object })\n], MapCanvasComponent.prototype, \"mapChipFragmentProperties\", null);\n__decorate([\n    property({ type: Number })\n], MapCanvasComponent.prototype, \"activeLayer\", null);\n__decorate([\n    property({ type: Boolean })\n], MapCanvasComponent.prototype, \"pickFromActiveLayer\", null);\n","/**\n * @license\n * Copyright 2021 piyoppi\n * SPDX-License-Identifier: MIT\n */\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { LitElement, html, css } from 'lit';\nimport { property } from 'lit/decorators.js';\nimport { GridImageGenerator, MapChipSelector, Projects } from '@piyoppi/pico2map-editor';\nimport { CursorPositionCalculator } from './Helpers/CursorPositionCalculator';\nexport class MapChipSelectorComponent extends LitElement {\n    constructor() {\n        super(...arguments);\n        this._gridImageSrc = '';\n        this.gridImageGenerator = new GridImageGenerator();\n        this.cursorPositionCalculator = new CursorPositionCalculator();\n        this._project = null;\n        this._mapChipSelector = null;\n        this._imageSrc = '';\n        this._afterReplacedMapChipImageCallbackItem = null;\n        this._projectId = -1;\n        this._chipId = -1;\n        this.cursorChipX = 0;\n        this.cursorChipY = 0;\n        this.selectedX = 0;\n        this.selectedY = 0;\n        this.selectedWidth = 0;\n        this.selectedHeight = 0;\n    }\n    get gridColor() {\n        return this.gridImageGenerator.gridColor;\n    }\n    set gridColor(value) {\n        const oldValue = this.gridImageGenerator.gridColor;\n        this.gridImageGenerator.gridColor = value;\n        this.requestUpdate('gridColor', oldValue);\n    }\n    get projectId() {\n        return this._projectId;\n    }\n    set projectId(value) {\n        const oldValue = this._projectId;\n        this._projectId = value;\n        this._setupProject();\n        if (this._project) {\n            this.setupMapChipSelector();\n        }\n        else {\n            this.reset();\n        }\n        this.requestUpdate('projectId', oldValue);\n    }\n    get chipId() {\n        return this._chipId;\n    }\n    set chipId(value) {\n        const oldValue = this._chipId;\n        this._chipId = value;\n        this.setupMapChipSelector();\n        this.requestUpdate('chipId', oldValue);\n    }\n    get mapChipSelector() {\n        if (!this._mapChipSelector)\n            throw new Error('The project is not set');\n        return this._mapChipSelector;\n    }\n    get gridWidth() {\n        var _a;\n        return ((_a = this._project) === null || _a === void 0 ? void 0 : _a.tiledMap.chipWidth) || 0;\n    }\n    get gridHeight() {\n        var _a;\n        return ((_a = this._project) === null || _a === void 0 ? void 0 : _a.tiledMap.chipHeight) || 0;\n    }\n    get cursorPosition() {\n        return {\n            x: this.cursorChipX * this.gridWidth,\n            y: this.cursorChipY * this.gridHeight\n        };\n    }\n    get subscribedProjectEvent() {\n        return !!this._afterReplacedMapChipImageCallbackItem;\n    }\n    _setupProject() {\n        if (this._project) {\n            this._unsubscribeProjectEvent();\n        }\n        this._project = Projects.fromProjectId(this._projectId);\n        if (!this._project)\n            return;\n        this._subscribeProjectEvent();\n    }\n    _subscribeProjectEvent() {\n        if (!this._project || this._afterReplacedMapChipImageCallbackItem)\n            return;\n        this._afterReplacedMapChipImageCallbackItem = this._project.setCallback('afterReplacedMapChipImage', () => this.setupMapChipSelector());\n    }\n    _unsubscribeProjectEvent() {\n        if (!this._project)\n            return;\n        if (this._afterReplacedMapChipImageCallbackItem)\n            this._project.removeCallback('afterReplacedMapChipImage', this._afterReplacedMapChipImageCallbackItem);\n        this._afterReplacedMapChipImageCallbackItem = null;\n    }\n    setupMapChipSelector() {\n        if (!this._project)\n            return;\n        const chipImage = this._project.tiledMap.mapChipsCollection.findById(this._chipId);\n        if (!chipImage) {\n            this.reset();\n            return;\n        }\n        this._mapChipSelector = new MapChipSelector(this._project.tiledMap, chipImage);\n        this._imageSrc = this._mapChipSelector.chipImage.src;\n        this.requestUpdate();\n    }\n    reset() {\n        this._mapChipSelector = null;\n        this._imageSrc = '';\n    }\n    mouseUp(e) {\n        const mouseCursorPosition = this.cursorPositionCalculator.getMouseCursorPosition(e.pageX, e.pageY);\n        this.mapChipSelector.mouseUp(mouseCursorPosition.x, mouseCursorPosition.y);\n        const selectedChips = this.mapChipSelector.selectedChips;\n        this.dispatchEvent(new CustomEvent('mapchip-selected', {\n            detail: { selectedMapChipProperties: selectedChips.map(chip => chip.toObject()) },\n            bubbles: true,\n            composed: true\n        }));\n        this.syncSelectedCursor();\n    }\n    mouseMove(e) {\n        const mouseCursorPosition = this.cursorPositionCalculator.getMouseCursorPosition(e.pageX, e.pageY);\n        this.mapChipSelector.mouseMove(mouseCursorPosition.x, mouseCursorPosition.y);\n        this.syncSelectedCursor();\n        const chip = this.mapChipSelector.convertFromImagePositionToChipPosition(mouseCursorPosition.x, mouseCursorPosition.y);\n        this.cursorChipX = chip.x;\n        this.cursorChipY = chip.y;\n    }\n    mouseDown(e) {\n        const mouseCursorPosition = this.cursorPositionCalculator.getMouseCursorPosition(e.pageX, e.pageY);\n        this.mapChipSelector.mouseDown(mouseCursorPosition.x, mouseCursorPosition.y);\n        this.syncSelectedCursor();\n    }\n    syncSelectedCursor() {\n        if (!this.mapChipSelector.selecting)\n            return;\n        const startPosition = this.mapChipSelector.startPosition;\n        const selectedSize = this.mapChipSelector.selectedSize;\n        this.selectedX = startPosition.x;\n        this.selectedY = startPosition.y;\n        this.selectedWidth = selectedSize.width;\n        this.selectedHeight = selectedSize.height;\n    }\n    firstUpdated() {\n        var _a;\n        const element = (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.getElementById('boundary');\n        if (element)\n            this.cursorPositionCalculator.setElement(element);\n    }\n    render() {\n        var _a, _b;\n        this.gridImageGenerator.setGridSize(this.gridWidth, this.gridHeight);\n        if (this.gridImageGenerator.changed) {\n            this._gridImageSrc = this.gridImageGenerator.generateLinePart().toDataURL();\n        }\n        return html `\n      <style>\n        .grid {\n          background-image: url(\"${this._gridImageSrc}\");\n          width: ${((_a = this._mapChipSelector) === null || _a === void 0 ? void 0 : _a.chipImage.image.width) || 0}px;\n          height: ${((_b = this._mapChipSelector) === null || _b === void 0 ? void 0 : _b.chipImage.image.height) || 0}px;\n        }\n\n        .cursor {\n          width: ${this.gridWidth}px;\n          height: ${this.gridHeight}px;\n          left: ${this.cursorPosition.x}px;\n          top: ${this.cursorPosition.y}px;\n        }\n\n        .selected {\n          width: ${this.selectedWidth}px;\n          height: ${this.selectedHeight}px;\n          left: ${this.selectedX}px;\n          top: ${this.selectedY}px;\n        }\n      </style>\n\n      <div id=\"boundary\">\n        <img id=\"chip-image\" src=\"${this._imageSrc}\">\n        <div\n          class=\"grid-image grid\"\n          @mousemove=\"${(e) => this.mouseMove(e)}\"\n          @mousedown=\"${(e) => this.mouseDown(e)}\"\n          @mouseup=\"${(e) => this.mouseUp(e)}\"\n        ></div>\n        ${this._imageSrc ? html `<div class=\"cursor\"></div>` : null}\n        ${(this._imageSrc && this.selectedWidth > 0 && this.selectedHeight > 0) ? html `<div class=\"selected\"></div>` : null}\n      </div>\n    `;\n    }\n    static get styles() {\n        return css `\n      .grid-image {\n        position: absolute;\n        top: 0;\n        left: 0;\n        background-repeat: repeat;\n      }\n\n      .cursor, .selected {\n        position: absolute;\n        border-style: solid;\n        box-sizing: border-box;\n      }\n\n      .cursor {\n        border-color: red;\n        pointer-events: none;\n      }\n\n      .selected {\n        border-color: blue;\n        pointer-events: none;\n      }\n\n      #boundary {\n        position: relative;\n      }\n\n      #chip-image {\n        display: block;\n        user-select: none;\n      }\n    `;\n    }\n    disconnectedCallback() {\n        super.disconnectedCallback();\n        this._unsubscribeProjectEvent();\n    }\n    connectedCallback() {\n        super.connectedCallback();\n        this._subscribeProjectEvent();\n    }\n}\n__decorate([\n    property({ type: String })\n], MapChipSelectorComponent.prototype, \"gridColor\", null);\n__decorate([\n    property({ type: Number })\n], MapChipSelectorComponent.prototype, \"projectId\", null);\n__decorate([\n    property({ type: Number })\n], MapChipSelectorComponent.prototype, \"chipId\", null);\n__decorate([\n    property({ type: Number })\n], MapChipSelectorComponent.prototype, \"cursorChipX\", void 0);\n__decorate([\n    property({ type: Number })\n], MapChipSelectorComponent.prototype, \"cursorChipY\", void 0);\n__decorate([\n    property({ type: Number })\n], MapChipSelectorComponent.prototype, \"selectedX\", void 0);\n__decorate([\n    property({ type: Number })\n], MapChipSelectorComponent.prototype, \"selectedY\", void 0);\n__decorate([\n    property({ type: Number })\n], MapChipSelectorComponent.prototype, \"selectedWidth\", void 0);\n__decorate([\n    property({ type: Number })\n], MapChipSelectorComponent.prototype, \"selectedHeight\", void 0);\n","/**\n * @license\n * Copyright 2021 piyoppi\n * SPDX-License-Identifier: MIT\n */\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { LitElement, html, css } from 'lit';\nimport { property } from 'lit/decorators.js';\nimport { CursorPositionCalculator } from './Helpers/CursorPositionCalculator';\nimport { GridImageGenerator, convertFromCursorPositionToChipPosition, convertChipPositionDivisionByCursorSize } from '@piyoppi/pico2map-editor';\nexport class MapGridComponent extends LitElement {\n    constructor() {\n        super(...arguments);\n        this.gridImageSrc = '';\n        this.gridImageGenerator = new GridImageGenerator();\n        this.cursorPositionCalculator = new CursorPositionCalculator();\n        this.mapMouseDownPosition = { x: -1, y: -1 };\n        this.lastCursor = { x: -1, y: -1 };\n        this.isMouseDown = false;\n        this.mouseUpEventCallee = null;\n        this.gridWidth = 0;\n        this.gridHeight = 0;\n        this.chipCountX = 0;\n        this.chipCountY = 0;\n        this.cursorHidden = false;\n        this.cursorX = 0;\n        this.cursorY = 0;\n        this.cursorWidth = 1;\n        this.cursorHeight = 1;\n    }\n    get gridColor() {\n        return this.gridImageGenerator.gridColor;\n    }\n    set gridColor(value) {\n        const oldValue = this.gridImageGenerator.gridColor;\n        this.gridImageGenerator.gridColor = value;\n        this.requestUpdate('gridColor', oldValue);\n    }\n    get width() {\n        return this.chipCountX * this.gridWidth;\n    }\n    get height() {\n        return this.chipCountY * this.gridHeight;\n    }\n    get cursorPosition() {\n        return {\n            x: this.cursorX * this.gridWidth,\n            y: this.cursorY * this.gridHeight\n        };\n    }\n    firstUpdated() {\n        var _a;\n        const element = (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.getElementById('boundary');\n        if (element)\n            this.cursorPositionCalculator.setElement(element);\n    }\n    mouseDown(e) {\n        const mouseCursorPosition = this.cursorPositionCalculator.getMouseCursorPosition(e.pageX, e.pageY);\n        const cursor = this.convertFromCursorPositionToChipPosition(mouseCursorPosition.x, mouseCursorPosition.y);\n        this.mapMouseDownPosition = this.lastCursor = cursor;\n        this.isMouseDown = true;\n        this.mouseUpEventCallee = () => this.mouseUp();\n        document.addEventListener('mouseup', this.mouseUpEventCallee);\n    }\n    mouseMove(e) {\n        if (this.cursorHidden)\n            return;\n        const mouseCursorPosition = this.cursorPositionCalculator.getMouseCursorPosition(e.pageX, e.pageY);\n        let cursor = this.convertFromCursorPositionToChipPosition(mouseCursorPosition.x, mouseCursorPosition.y);\n        if (this.isMouseDown) {\n            cursor = convertChipPositionDivisionByCursorSize(cursor.x, cursor.y, this.mapMouseDownPosition.x, this.mapMouseDownPosition.y, this.cursorWidth, this.cursorHeight);\n        }\n        if (cursor.x === this.lastCursor.x && cursor.y === this.lastCursor.y)\n            return;\n        this.lastCursor = cursor;\n        this.cursorX = cursor.x;\n        this.cursorY = cursor.y;\n    }\n    mouseUp() {\n        this.isMouseDown = false;\n        if (this.mouseUpEventCallee)\n            document.removeEventListener('mouseup', this.mouseUpEventCallee);\n        this.mouseUpEventCallee = null;\n    }\n    convertFromCursorPositionToChipPosition(x, y) {\n        return convertFromCursorPositionToChipPosition(x, y, this.gridWidth, this.gridHeight, this.chipCountX, this.chipCountY, this.cursorWidth, this.cursorHeight);\n    }\n    render() {\n        this.gridImageGenerator.setGridSize(this.gridWidth, this.gridHeight);\n        if (this.gridImageGenerator.changed) {\n            this.gridImageSrc = this.gridImageGenerator.generateLinePart().toDataURL();\n        }\n        return html `\n      <style>\n        .grid {\n          background-image: url(\"${this.gridImageSrc}\");\n        }\n\n        #boundary {\n          width: ${this.width + 1}px;\n          height: ${this.height + 1}px;\n        }\n\n        .cursor {\n          width: ${this.gridWidth * this.cursorWidth}px;\n          height: ${this.gridHeight * this.cursorHeight}px;\n          left: ${this.cursorPosition.x}px;\n          top: ${this.cursorPosition.y}px;\n        }\n\n        .grid-image {\n          background-position: 1px 1px\n        }\n      </style>\n\n      <div id=\"boundary\">\n        <div\n          class=\"grid-image grid\"\n          @mousedown=\"${(e) => this.mouseDown(e)}\"\n          @mousemove=\"${(e) => this.mouseMove(e)}\"\n        ></div>\n        ${!this.cursorHidden ? html `<div class=\"cursor\"></div>` : null}\n      </div>\n    `;\n    }\n    static get styles() {\n        return css `\n      .grid-image {\n        position: absolute;\n        top: 0;\n        left: 0;\n        background-repeat: repeat;\n        width: 100%;\n        height: 100%;\n      }\n\n      #boundary {\n        position: relative;\n      }\n\n      .cursor {\n        position: absolute;\n        border-style: solid;\n        box-sizing: border-box;\n        border-color: red;\n        pointer-events: none;\n      }\n    `;\n    }\n}\n__decorate([\n    property({ type: Number })\n], MapGridComponent.prototype, \"gridWidth\", void 0);\n__decorate([\n    property({ type: Number })\n], MapGridComponent.prototype, \"gridHeight\", void 0);\n__decorate([\n    property({ type: Number })\n], MapGridComponent.prototype, \"chipCountX\", void 0);\n__decorate([\n    property({ type: Number })\n], MapGridComponent.prototype, \"chipCountY\", void 0);\n__decorate([\n    property({ type: Boolean })\n], MapGridComponent.prototype, \"cursorHidden\", void 0);\n__decorate([\n    property({ type: Number })\n], MapGridComponent.prototype, \"cursorX\", void 0);\n__decorate([\n    property({ type: Number })\n], MapGridComponent.prototype, \"cursorY\", void 0);\n__decorate([\n    property({ type: Number })\n], MapGridComponent.prototype, \"cursorWidth\", void 0);\n__decorate([\n    property({ type: Number })\n], MapGridComponent.prototype, \"cursorHeight\", void 0);\n__decorate([\n    property({ type: String })\n], MapGridComponent.prototype, \"gridColor\", null);\n","/**\n * @license\n * Copyright 2021 piyoppi\n * SPDX-License-Identifier: MIT\n */\nimport { isAutoTileMapChip } from '@piyoppi/pico2map-tiled';\nexport function PickedArrangementSelector(detail) {\n    if (isAutoTileMapChip(detail.picked)) {\n        return 'AutoTileArrangement';\n    }\n    else if (detail.picked) {\n        return 'DefaultArrangement';\n    }\n    else {\n        return 'DefaultEraseArrangement';\n    }\n}\n","/**\n * @license\n * Copyright 2021 piyoppi\n * SPDX-License-Identifier: MIT\n */\nimport { MapChipSelectorComponent } from './MapChipSelectorComponent';\nimport { MapCanvasComponent } from './MapCanvasComponent';\nimport { AutoTileSelectorComponent } from './AutoTileSelectorComponent';\nimport { ColiderMarkerComponent } from './ColisionMarkerComponent';\nimport { MapGridComponent } from './MapGridComponent';\nexport function defineComponent() {\n    customElements.define('map-canvas-component', MapCanvasComponent);\n    customElements.define('auto-tile-selector-component', AutoTileSelectorComponent);\n    customElements.define('map-chip-selector-component', MapChipSelectorComponent);\n    customElements.define('colider-marker-component', ColiderMarkerComponent);\n    customElements.define('map-grid-component', MapGridComponent);\n}\nexport { Projects } from '@piyoppi/pico2map-editor';\nexport { MapChipSelectedEvent, AutoTileSelectedEvent, PickedMapChipEvent } from './Events';\nexport { PickedArrangementSelector } from './PickedArrangementSelector';\n","/**\n * @license\n * Copyright 2021 piyoppi\n * SPDX-License-Identifier: MIT\n */\nexport class AutoTileSelector {\n    constructor(_canvasWidth, _chipWidth, _chipHeight, _autoTiles, _mapChipsCollection) {\n        this._canvasWidth = _canvasWidth;\n        this._chipWidth = _chipWidth;\n        this._chipHeight = _chipHeight;\n        this._autoTiles = _autoTiles;\n        this._mapChipsCollection = _mapChipsCollection;\n        this._indexImageWidth = 0;\n        this._indexImageHeight = 0;\n        this._autoTilesMap = new Map();\n    }\n    get canvasWidth() {\n        return this._canvasWidth;\n    }\n    set canvasWidth(value) {\n        this._canvasWidth = value;\n    }\n    getAutoTileFragmentFromIndexImagePosition(cursorX, cursorY) {\n        const x = Math.floor(cursorX / this._chipWidth);\n        const y = Math.floor(cursorY / this._chipHeight);\n        return this._autoTilesMap.get(`${x},${y}`) || null;\n    }\n    convertFromIndexImageToChipPosition(cursorX, cursorY) {\n        const chipCount = {\n            width: this._indexImageWidth / this._chipWidth,\n            height: this._indexImageHeight / this._chipHeight\n        };\n        return {\n            x: Math.max(0, Math.min(Math.floor(cursorX / this._chipWidth), chipCount.width - 1)),\n            y: Math.max(0, Math.min(Math.floor(cursorY / this._chipHeight), chipCount.height - 1))\n        };\n    }\n    getSizeOfIndexImage() {\n        return {\n            width: this._canvasWidth,\n            height: Math.ceil(this._autoTiles.length / Math.floor(this._canvasWidth / this._chipWidth)) * this._chipHeight\n        };\n    }\n    generateIndexImage(canvas) {\n        const indexImageContext = canvas.getContext('2d');\n        if (!indexImageContext)\n            return;\n        indexImageContext.clearRect(0, 0, canvas.width, canvas.height);\n        this._autoTilesMap.clear();\n        const xCount = Math.floor(this._canvasWidth / this._chipWidth);\n        const values = this._autoTiles.values();\n        let currentAutoTile = undefined;\n        let x = 0, y = 0;\n        while (currentAutoTile = values.next().value) {\n            const fragment = currentAutoTile.mapChipFragments[0];\n            const chipImage = this._mapChipsCollection.findById(fragment.chipId);\n            if (!chipImage)\n                continue;\n            indexImageContext.drawImage(chipImage.image, fragment.x * this._chipWidth, fragment.y * this._chipHeight, this._chipWidth, this._chipHeight, x * this._chipWidth, y * this._chipHeight, this._chipWidth, this._chipHeight);\n            this._autoTilesMap.set(`${x},${y}`, currentAutoTile);\n            x++;\n            if (x >= xCount) {\n                x = 0;\n                y++;\n            }\n        }\n        this._indexImageWidth = xCount * this._chipWidth;\n        this._indexImageHeight = (y + 1) * this._chipHeight;\n    }\n}\n","/**\n * @license\n * Copyright 2021 piyoppi\n * SPDX-License-Identifier: MIT\n */\nexport function isMapChipFragmentRequired(obj) {\n    return typeof obj.setMapChips === 'function';\n}\nexport function isTiledMapDataRequired(obj) {\n    return typeof obj.setTiledMapData === 'function';\n}\nexport function isAutoTileRequired(obj) {\n    return typeof obj.setAutoTile === 'function';\n}\nexport function isAutoTilesRequired(obj) {\n    return typeof obj.setAutoTiles === 'function';\n}\nexport function isColiderTypesRequired(obj) {\n    return typeof obj.setColiderTypes === 'function';\n}\n","/**\n * @license\n * Copyright 2021 piyoppi\n * SPDX-License-Identifier: MIT\n */\nimport { DefaultArrangementDescription } from './DefaultArrangement';\nimport { AutoTileArrangementDescription } from './AutoTileArrangement';\nimport { DefaultEraseArrangementDescription } from './DefaultEraseArrangement';\nconst registeredArrangementDescriptions = [\n    DefaultArrangementDescription,\n    AutoTileArrangementDescription,\n    DefaultEraseArrangementDescription\n];\nexport const Arrangements = registeredArrangementDescriptions.map(description => ({\n    name: description.name,\n    create: () => description.create()\n}));\n","/**\n * @license\n * Copyright 2021 piyoppi\n * SPDX-License-Identifier: MIT\n */\nimport { MapChipFragment, AutoTileMapChip, isAutoTileMapChip, TiledMapData } from '@piyoppi/pico2map-tiled';\nexport const AutoTileArrangementDescription = {\n    name: 'AutoTileArrangement',\n    create: () => new AutoTileArrangement()\n};\n/**\n * AutoTileArrangement\n *\n * Supported auto tile format is shown below.\n *\n * |<---------- 1chip ----------->|\n * ┏━┿┿┿┿┿┿┿┿┓---\n * ┠isolated                   ┠↑\n * ┣┿┿┿┿┿┿┿┿┿┫ |\n * ┠straight road (lengthwise) ┠ |\n * ┣┿┿┿┿┿┿┿┿┿┫ |\n * ┠straight road (sideways)   ┠5chips\n * ┣┿┿┿┿┿┿┿┿┿┫ |\n * ┠cross road                 ┠ |\n * ┣┿┿┿┿┿┿┿┿┿┫ |\n * ┠square                     ┠↓\n * ┗┷┿┿┿┿┿┿┿┿┛---\n */\nexport class AutoTileArrangement {\n    constructor() {\n        this._autoTile = null;\n        this._tiledMapData = null;\n        this.temporaryChip = new AutoTileMapChip(-1, [new MapChipFragment(-1, -1, -1)]);\n    }\n    get tiledMapData() {\n        return this._tiledMapData;\n    }\n    setMapChips(mapChips) {\n    }\n    setAutoTile(autoTile) {\n        if (autoTile.mapChipFragments.length !== 5)\n            throw new Error('Too few map chips. AutoTileArrangement requires 5 map chips.');\n        this._autoTile = autoTile;\n    }\n    setTiledMapData(tiledMapData) {\n        this._tiledMapData = tiledMapData;\n    }\n    apply(paints) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;\n        if (!this._tiledMapData)\n            throw new Error('MapData is not set.');\n        const result = [];\n        const x1 = paints.reduce((acc, val) => Math.min(acc, val.x), this._tiledMapData.width);\n        const y1 = paints.reduce((acc, val) => Math.min(acc, val.y), this._tiledMapData.height);\n        const x2 = paints.reduce((acc, val) => Math.max(acc, val.x), 0);\n        const y2 = paints.reduce((acc, val) => Math.max(acc, val.y), 0);\n        const size = {\n            width: x2 - x1 + 1,\n            height: y2 - y1 + 1\n        };\n        const sizeWithPatch = {\n            width: size.width + 2,\n            height: size.height + 2\n        };\n        const tiledBuffer = new TiledMapData(sizeWithPatch.width, sizeWithPatch.height);\n        const offsetX1 = 1;\n        const offsetY1 = 1;\n        const offsetX2 = 1;\n        const offsetY2 = 1;\n        tiledBuffer.transferFromTiledMapData(this._tiledMapData, x1 - offsetX1, y1 - offsetY1, sizeWithPatch.width + offsetX2, sizeWithPatch.height + offsetY2, 0, 0);\n        paints.forEach(paint => {\n            const x = paint.x - x1 + offsetX1;\n            const y = paint.y - y1 + offsetY1;\n            tiledBuffer.put(this.temporaryChip, x, y);\n        });\n        for (let y = offsetY1; y < size.height + offsetY2; y++) {\n            for (let x = offsetX1; x < size.width + offsetX2; x++) {\n                const cursor = tiledBuffer.getFromChipPosition(x, y);\n                const targetChip = tiledBuffer.getFromChipPosition(x, y);\n                const isTemporaryChip = targetChip ? this.temporaryChip.compare(targetChip) : false;\n                if (!cursor)\n                    continue;\n                if (!isTemporaryChip)\n                    continue;\n                /**\n                 * adjacent\n                 *\n                 *  x      : processing point\n                 *  others : patch number\n                 * *-----*-----*-----*\n                 * | 16  |  1  | 32  |\n                 * *-----*-----*-----*\n                 * |  2  |  x  |  4  |\n                 * *-----*-----*-----*\n                 * | 64  |  8  | 128 |\n                 * *-----*-----*-----*\n                 */\n                let adjacent = 0;\n                const aroundChips = [\n                    tiledBuffer.getFromChipPosition(x, y - 1),\n                    tiledBuffer.getFromChipPosition(x - 1, y),\n                    tiledBuffer.getFromChipPosition(x + 1, y),\n                    tiledBuffer.getFromChipPosition(x, y + 1),\n                    tiledBuffer.getFromChipPosition(x - 1, y - 1),\n                    tiledBuffer.getFromChipPosition(x + 1, y - 1),\n                    tiledBuffer.getFromChipPosition(x - 1, y + 1),\n                    tiledBuffer.getFromChipPosition(x + 1, y + 1)\n                ].map(mapChip => isAutoTileMapChip(mapChip) ? mapChip : null);\n                if (!((_a = aroundChips[0]) === null || _a === void 0 ? void 0 : _a.boundary.bottom))\n                    adjacent += this._isAdjacent(aroundChips[0]) ? 1 : 0;\n                if (!((_b = aroundChips[1]) === null || _b === void 0 ? void 0 : _b.boundary.right))\n                    adjacent += this._isAdjacent(aroundChips[1]) ? 2 : 0;\n                if (!((_c = aroundChips[2]) === null || _c === void 0 ? void 0 : _c.boundary.left))\n                    adjacent += this._isAdjacent(aroundChips[2]) ? 4 : 0;\n                if (!((_d = aroundChips[3]) === null || _d === void 0 ? void 0 : _d.boundary.top))\n                    adjacent += this._isAdjacent(aroundChips[3]) ? 8 : 0;\n                if (!((_e = aroundChips[4]) === null || _e === void 0 ? void 0 : _e.boundary.bottom) && !((_f = aroundChips[4]) === null || _f === void 0 ? void 0 : _f.boundary.right) && !((_g = aroundChips[4]) === null || _g === void 0 ? void 0 : _g.cross.bottomRight))\n                    adjacent += this._isAdjacent(aroundChips[4]) ? 16 : 0;\n                if (!((_h = aroundChips[5]) === null || _h === void 0 ? void 0 : _h.boundary.bottom) && !((_j = aroundChips[5]) === null || _j === void 0 ? void 0 : _j.boundary.left) && !((_k = aroundChips[5]) === null || _k === void 0 ? void 0 : _k.cross.bottomLeft))\n                    adjacent += this._isAdjacent(aroundChips[5]) ? 32 : 0;\n                if (!((_l = aroundChips[6]) === null || _l === void 0 ? void 0 : _l.boundary.top) && !((_m = aroundChips[6]) === null || _m === void 0 ? void 0 : _m.boundary.right) && !((_o = aroundChips[6]) === null || _o === void 0 ? void 0 : _o.cross.topRight))\n                    adjacent += this._isAdjacent(aroundChips[6]) ? 64 : 0;\n                if (!((_p = aroundChips[7]) === null || _p === void 0 ? void 0 : _p.boundary.top) && !((_q = aroundChips[7]) === null || _q === void 0 ? void 0 : _q.boundary.left) && !((_r = aroundChips[7]) === null || _r === void 0 ? void 0 : _r.cross.topLeft))\n                    adjacent += this._isAdjacent(aroundChips[7]) ? 128 : 0;\n                const item = this.getTiledPattern(adjacent, aroundChips);\n                if (item) {\n                    tiledBuffer.put(item, x, y);\n                    result.push({ x: x + x1 - offsetX1, y: y + y1 - offsetY1, item });\n                }\n            }\n        }\n        return result;\n    }\n    getTiledPattern(adjacent, aroundChips) {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        if (!this._autoTile)\n            return null;\n        const mapChip = new AutoTileMapChip(this._autoTile.id, [], 'AutoTileArrangement');\n        const mapChips = this._autoTile.mapChipFragments;\n        const boundary = {\n            top: false,\n            bottom: false,\n            left: false,\n            right: false\n        };\n        const cross = {\n            topLeft: false,\n            topRight: false,\n            bottomLeft: false,\n            bottomRight: false\n        };\n        if ((adjacent & 19) === 19 && !((_a = aroundChips[0]) === null || _a === void 0 ? void 0 : _a.cross.bottomLeft) && !((_b = aroundChips[1]) === null || _b === void 0 ? void 0 : _b.cross.topRight)) {\n            /* Square */\n            mapChip.push(mapChips[4].clone().withParameter({ renderingArea: 1 }));\n            boundary.top = false;\n            boundary.left = false;\n        }\n        else if ((adjacent & 3) === 2) {\n            /* Straight(sideways) */\n            mapChip.push(mapChips[2].clone().withParameter({ renderingArea: 1 }));\n            boundary.top = true;\n            boundary.left = false;\n        }\n        else if ((adjacent & 3) === 1) {\n            /* Straight(lengthwise) */\n            mapChip.push(mapChips[1].clone().withParameter({ renderingArea: 1 }));\n            boundary.top = false;\n            boundary.left = true;\n        }\n        else if ((adjacent & 3) === 0) {\n            /* Corner */\n            mapChip.push(mapChips[0].clone().withParameter({ renderingArea: 1 }));\n            boundary.top = true;\n            boundary.left = true;\n        }\n        else if ((adjacent & 19) === 3) {\n            /* Cross */\n            mapChip.push(mapChips[3].clone().withParameter({ renderingArea: 1 }));\n            boundary.top = false;\n            boundary.left = false;\n            cross.topLeft = true;\n        }\n        if ((adjacent & 37) === 37 && !((_c = aroundChips[0]) === null || _c === void 0 ? void 0 : _c.cross.bottomRight) && !((_d = aroundChips[2]) === null || _d === void 0 ? void 0 : _d.cross.topLeft)) {\n            mapChip.push(mapChips[4].clone().withParameter({ renderingArea: 2 }));\n        }\n        else if ((adjacent & 5) === 4) {\n            mapChip.push(mapChips[2].clone().withParameter({ renderingArea: 2 }));\n        }\n        else if ((adjacent & 5) === 1) {\n            mapChip.push(mapChips[1].clone().withParameter({ renderingArea: 2 }));\n        }\n        else if ((adjacent & 5) === 0) {\n            mapChip.push(mapChips[0].clone().withParameter({ renderingArea: 2 }));\n        }\n        else if ((adjacent & 37) === 5) {\n            mapChip.push(mapChips[3].clone().withParameter({ renderingArea: 2 }));\n            cross.topRight = true;\n        }\n        if ((adjacent & 74) === 74 && !((_e = aroundChips[1]) === null || _e === void 0 ? void 0 : _e.cross.bottomRight) && !((_f = aroundChips[3]) === null || _f === void 0 ? void 0 : _f.cross.topRight)) {\n            mapChip.push(mapChips[4].clone().withParameter({ renderingArea: 4 }));\n        }\n        else if ((adjacent & 10) === 2) {\n            mapChip.push(mapChips[2].clone().withParameter({ renderingArea: 4 }));\n        }\n        else if ((adjacent & 10) === 8) {\n            mapChip.push(mapChips[1].clone().withParameter({ renderingArea: 4 }));\n        }\n        else if ((adjacent & 10) === 0) {\n            mapChip.push(mapChips[0].clone().withParameter({ renderingArea: 4 }));\n        }\n        else if ((adjacent & 74) === 10) {\n            mapChip.push(mapChips[3].clone().withParameter({ renderingArea: 4 }));\n            cross.bottomLeft = true;\n        }\n        if ((adjacent & 140) === 140 && !((_g = aroundChips[2]) === null || _g === void 0 ? void 0 : _g.cross.bottomLeft) && !((_h = aroundChips[3]) === null || _h === void 0 ? void 0 : _h.cross.topRight)) {\n            mapChip.push(mapChips[4].clone().withParameter({ renderingArea: 8 }));\n            boundary.bottom = false;\n            boundary.right = false;\n        }\n        else if ((adjacent & 12) === 4) {\n            mapChip.push(mapChips[2].clone().withParameter({ renderingArea: 8 }));\n            boundary.bottom = true;\n            boundary.right = false;\n        }\n        else if ((adjacent & 12) === 8) {\n            mapChip.push(mapChips[1].clone().withParameter({ renderingArea: 8 }));\n            boundary.bottom = false;\n            boundary.right = true;\n        }\n        else if ((adjacent & 12) === 0) {\n            mapChip.push(mapChips[0].clone().withParameter({ renderingArea: 8 }));\n            boundary.bottom = true;\n            boundary.right = true;\n        }\n        else if ((adjacent & 140) === 12) {\n            mapChip.push(mapChips[3].clone().withParameter({ renderingArea: 8 }));\n            boundary.bottom = false;\n            boundary.right = false;\n            cross.bottomRight = true;\n        }\n        if (mapChip.length !== 4)\n            return null;\n        mapChip.setBoundary(boundary);\n        mapChip.setCross(cross);\n        return mapChip;\n    }\n    _isAdjacent(chip) {\n        if (chip === null)\n            return false;\n        const isTemporaryChip = this.temporaryChip.compare(chip);\n        const isAutoTileChip = this._isAutoTileChip(chip);\n        return isAutoTileChip || isTemporaryChip;\n    }\n    _isAutoTileChip(chip) {\n        if (!this._autoTile)\n            return false;\n        if (!chip)\n            return false;\n        return this._autoTile.id === chip.autoTileId;\n    }\n}\n","/**\n * @license\n * Copyright 2021 piyoppi\n * SPDX-License-Identifier: MIT\n */\nimport { AutoTileArrangement } from './AutoTileArrangement';\nimport { TiledMapData, isAutoTileMapChip } from '@piyoppi/pico2map-tiled';\nexport const AutoTileEraseArrangementDescription = {\n    name: 'AutoTileEraseArrangement',\n    create: () => new AutoTileEraseArrangement()\n};\nexport class AutoTileEraseArrangement {\n    constructor() {\n        this._autoTileArrangement = new AutoTileArrangement();\n        this._tiledMapData = null;\n        this._autoTiles = null;\n    }\n    setTiledMapData(tiledMapData) {\n        this._tiledMapData = tiledMapData;\n    }\n    setAutoTiles(autoTiles) {\n        this._autoTiles = autoTiles;\n    }\n    apply(paints) {\n        if (paints.length === 0)\n            return [];\n        return this.erase(paints);\n    }\n    erase(paints) {\n        if (!this._tiledMapData)\n            throw new Error('MapData is not set.');\n        if (!this._autoTiles)\n            throw new Error('AutoTiles is not set');\n        const resultPaints = [];\n        const paintX1 = paints.reduce((acc, val) => Math.min(acc, val.x), this._tiledMapData.width);\n        const paintY1 = paints.reduce((acc, val) => Math.min(acc, val.y), this._tiledMapData.height);\n        const paintX2 = paints.reduce((acc, val) => Math.max(acc, val.x), 0);\n        const paintY2 = paints.reduce((acc, val) => Math.max(acc, val.y), 0);\n        const x1 = Math.max(paintX1 - 1, 0);\n        const y1 = Math.max(paintY1 - 1, 0);\n        const x2 = Math.min(paintX2 + 1, this._tiledMapData.width);\n        const y2 = Math.min(paintY2 + 1, this._tiledMapData.height);\n        const bufferWidth = x2 - x1 + 1;\n        const bufferHeight = y2 - y1 + 1;\n        const tiledBuffer = new TiledMapData(bufferWidth + 2, bufferHeight + 2);\n        const bufferOffsetX = x1 - 1;\n        const bufferOffsetY = y1 - 1;\n        tiledBuffer.transferFromTiledMapData(this._tiledMapData, bufferOffsetX, bufferOffsetY, tiledBuffer.width, tiledBuffer.height, 0, 0);\n        paints.forEach(paint => {\n            var _a;\n            const paintPositionAtBuffer = { x: paint.x - bufferOffsetX, y: paint.y - bufferOffsetY };\n            tiledBuffer.put(null, paintPositionAtBuffer.x, paintPositionAtBuffer.y);\n            resultPaints.push({ x: paint.x, y: paint.y, item: null });\n            this._autoTileArrangement.setTiledMapData(tiledBuffer);\n            for (let y = paintPositionAtBuffer.y - 1; y <= paintPositionAtBuffer.y + 1; y++) {\n                for (let x = paintPositionAtBuffer.x - 1; x <= paintPositionAtBuffer.x + 1; x++) {\n                    if (x === paintPositionAtBuffer.x && y === paintPositionAtBuffer.y)\n                        continue;\n                    const item = tiledBuffer.getFromChipPosition(x, y);\n                    if (item && isAutoTileMapChip(item)) {\n                        const autoTile = (_a = this._autoTiles) === null || _a === void 0 ? void 0 : _a.fromId(item.autoTileId);\n                        if (!autoTile)\n                            continue;\n                        this._autoTileArrangement.setAutoTile(autoTile);\n                        const appliedPaints = this._autoTileArrangement.apply([{ x, y }]);\n                        if (appliedPaints.length === 0)\n                            continue;\n                        resultPaints.push({ x: appliedPaints[0].x + bufferOffsetX, y: appliedPaints[0].y + bufferOffsetY, item: appliedPaints[0].item });\n                    }\n                }\n            }\n        });\n        return resultPaints;\n    }\n}\n","/**\n * @license\n * Copyright 2021 piyoppi\n * SPDX-License-Identifier: MIT\n */\nexport const ColiderArrangementDescription = {\n    name: 'ColiderArrangement',\n    create: () => new ColiderArrangement()\n};\nexport class ColiderArrangement {\n    constructor() {\n        this._coliderType = 0;\n    }\n    setColiderTypes(coliderType) {\n        this._coliderType = coliderType;\n    }\n    apply(paints) {\n        return paints.map(paint => ({ ...paint, item: this._coliderType }));\n    }\n}\n","/**\n * @license\n * Copyright 2021 piyoppi\n * SPDX-License-Identifier: MIT\n */\nimport { MapChip } from '@piyoppi/pico2map-tiled';\nexport const DefaultArrangementDescription = {\n    name: 'DefaultArrangement',\n    create: () => new DefaultArrangement()\n};\nexport class DefaultArrangement {\n    constructor() {\n        this._mapChips = [];\n    }\n    setMapChips(mapChips) {\n        if (mapChips.length < 1)\n            throw new Error('Invalid count of map chips. DefaultArrangement requires a map chip.');\n        this._mapChips = mapChips;\n    }\n    apply(paints) {\n        if (this._mapChips.length < 1)\n            throw new Error('Invalid count of map chips. DefaultArrangement requires a map chip.');\n        const basePosition = { x: this._mapChips[0].x, y: this._mapChips[0].y };\n        return paints.map(paint => {\n            return this._mapChips.map(mapChip => ({\n                x: paint.x + mapChip.x - basePosition.x,\n                y: paint.y + mapChip.y - basePosition.y,\n                item: new MapChip([mapChip])\n            }));\n        }).flat(1);\n    }\n}\n","/**\n * @license\n * Copyright 2021 piyoppi\n * SPDX-License-Identifier: MIT\n */\nimport { EraseArrangement } from './EraseArrangement';\nimport { AutoTileEraseArrangement } from './AutoTileEraseArrangement';\nexport const DefaultEraseArrangementDescription = {\n    name: 'DefaultEraseArrangement',\n    create: () => new DefaultEraseArrangement()\n};\nexport class DefaultEraseArrangement {\n    constructor() {\n        this.defaultEraser = new EraseArrangement();\n        this.autoTileEraser = new AutoTileEraseArrangement();\n        this._tiledMapData = null;\n    }\n    setTiledMapData(tiledMapData) {\n        this._tiledMapData = tiledMapData;\n        this.autoTileEraser.setTiledMapData(tiledMapData);\n    }\n    setAutoTiles(autoTiles) {\n        this.autoTileEraser.setAutoTiles(autoTiles);\n    }\n    apply(paints) {\n        const autoTilePaints = [];\n        const otherPaints = [];\n        paints.forEach(paint => {\n            if (!this._tiledMapData)\n                throw new Error('MapData is not set.');\n            const chip = this._tiledMapData.getFromChipPosition(paint.x, paint.y);\n            if ((chip === null || chip === void 0 ? void 0 : chip.arrangementName) === 'AutoTileArrangement') {\n                autoTilePaints.push(paint);\n            }\n            else {\n                otherPaints.push(paint);\n            }\n        });\n        return [...this.autoTileEraser.apply(autoTilePaints), ...this.defaultEraser.apply(otherPaints)];\n    }\n}\n","/**\n * @license\n * Copyright 2021 piyoppi\n * SPDX-License-Identifier: MIT\n */\nexport const EraseArrangementDescription = {\n    name: 'EraseArrangement',\n    create: () => new EraseArrangement()\n};\nexport class EraseArrangement {\n    apply(paints) {\n        return paints.map(paint => ({ ...paint, item: null }));\n    }\n}\n","/**\n * @license\n * Copyright 2021 piyoppi\n * SPDX-License-Identifier: MIT\n */\nimport { PenDescription } from './Pen';\nimport { RectangleBrushDescription } from './RectangleBrush';\nconst registeredBrushDescriptions = [\n    PenDescription,\n    RectangleBrushDescription\n];\nexport const Brushes = registeredBrushDescriptions.map(description => ({\n    name: description.name,\n    create: () => description.create()\n}));\n","/**\n * @license\n * Copyright 2021 piyoppi\n * SPDX-License-Identifier: MIT\n */\nexport const PenDescription = {\n    name: 'Pen',\n    create: () => new Pen()\n};\nexport class Pen {\n    constructor() {\n        this._isMouseDown = false;\n        this.painting = [];\n        this._beforeCursorPosition = { x: -1, y: -1 };\n        this._arrangement = null;\n    }\n    setArrangement(arrangement) {\n        this._arrangement = arrangement;\n    }\n    mouseDown(chipX, chipY) {\n        this._isMouseDown = true;\n        this.painting = [];\n    }\n    mouseMove(chipX, chipY) {\n        if (!this._arrangement)\n            throw new Error('Arrangement is not set.');\n        if (!this._isMouseDown)\n            return [];\n        const paint = {\n            x: chipX,\n            y: chipY,\n            item: null\n        };\n        if (paint.x !== this._beforeCursorPosition.x || paint.y !== this._beforeCursorPosition.y) {\n            this.painting.push(paint);\n            this._beforeCursorPosition = paint;\n        }\n        return this._arrangement.apply(this.painting);\n    }\n    mouseUp(chipX, chipY) {\n        if (!this._arrangement)\n            throw new Error('Arrangement is not set.');\n        this._isMouseDown = false;\n        return this._arrangement.apply(this.painting);\n    }\n    cleanUp() {\n        this.painting.length = 0;\n        this._beforeCursorPosition = { x: -1, y: -1 };\n    }\n}\n","/**\n * @license\n * Copyright 2021 piyoppi\n * SPDX-License-Identifier: MIT\n */\nexport const RectangleBrushDescription = {\n    name: 'RectangleBrush',\n    create: () => new RectangleBrush()\n};\nexport class RectangleBrush {\n    constructor() {\n        this._isMouseDown = false;\n        this._startPosition = { x: 0, y: 0 };\n        this._arrangement = null;\n    }\n    setArrangement(arrangement) {\n        this._arrangement = arrangement;\n    }\n    mouseDown(chipX, chipY) {\n        this._isMouseDown = true;\n        this._startPosition = { x: chipX, y: chipY };\n    }\n    mouseMove(chipX, chipY) {\n        if (!this._isMouseDown)\n            return [];\n        return this._build(chipX, chipY);\n    }\n    mouseUp(chipX, chipY) {\n        this._isMouseDown = false;\n        return this._build(chipX, chipY);\n    }\n    _build(chipX, chipY) {\n        if (!this._arrangement)\n            throw new Error('Arrangement is not set.');\n        const paints = [];\n        const startX = Math.min(this._startPosition.x, chipX);\n        const startY = Math.min(this._startPosition.y, chipY);\n        const endX = Math.max(this._startPosition.x, chipX);\n        const endY = Math.max(this._startPosition.y, chipY);\n        for (let x = startX; x <= endX; x++) {\n            for (let y = startY; y <= endY; y++) {\n                paints.push({ x, y });\n            }\n        }\n        return this._arrangement.apply(paints);\n    }\n    cleanUp() {\n    }\n}\n","/**\n * @license\n * Copyright 2021 piyoppi\n * SPDX-License-Identifier: MIT\n */\nimport { CallbackItem } from './CallbackItem';\nexport class CallbackCaller {\n    constructor() {\n        this._items = [];\n        this._maxId = 1;\n    }\n    get length() {\n        return this._items.length;\n    }\n    get items() {\n        return this._items;\n    }\n    has(callbackItem) {\n        return !!this._items.find(item => item === callbackItem);\n    }\n    add(proc) {\n        const callbackItem = new CallbackItem(proc, this._maxId++);\n        this._items.push(callbackItem);\n        return callbackItem;\n    }\n    call() {\n        this._items.forEach(item => item.call());\n    }\n    remove(removedCallbackItem) {\n        const index = this._items.findIndex(item => item === removedCallbackItem);\n        if (index < 0)\n            throw Error('CallbackCaller is not found');\n        this._items.splice(index, 1);\n    }\n}\n","/**\n * @license\n * Copyright 2021 piyoppi\n * SPDX-License-Identifier: MIT\n */\nimport { CallbackCaller } from './CallbackCaller';\nexport class CallbackCallers {\n    constructor() {\n        this._callers = new Map();\n    }\n    getCallbackCaller(key) {\n        return this._callers.get(key);\n    }\n    has(key, callbackItem) {\n        var _a;\n        return !!((_a = this._callers.get(key)) === null || _a === void 0 ? void 0 : _a.has(callbackItem));\n    }\n    add(key, callback) {\n        let caller = this._callers.get(key);\n        if (!caller) {\n            caller = new CallbackCaller();\n            this._callers.set(key, caller);\n        }\n        return caller.add(callback);\n    }\n    call(key) {\n        var _a;\n        (_a = this._callers.get(key)) === null || _a === void 0 ? void 0 : _a.call();\n    }\n    remove(key, callbackItem) {\n        var _a;\n        (_a = this._callers.get(key)) === null || _a === void 0 ? void 0 : _a.remove(callbackItem);\n    }\n}\n","/**\n * @license\n * Copyright 2021 piyoppi\n * SPDX-License-Identifier: MIT\n */\nexport class CallbackItem {\n    constructor(_proc, _id = -1) {\n        this._proc = _proc;\n        this._id = _id;\n        this._caller = null;\n    }\n    get id() {\n        return this._id;\n    }\n    call() {\n        if (!this._proc)\n            new Error('Callback function is not set');\n        this._proc.call(this._caller);\n    }\n}\n","/**\n * @license\n * Copyright 2021 piyoppi\n * SPDX-License-Identifier: MIT\n */\nimport { ColiderRenderer } from './ColiderRenderer';\nimport { Pen } from './Brushes/Pen';\nimport { Brushes } from './Brushes/Brushes';\nimport { isColiderTypesRequired } from './Brushes/Arrangements/Arrangement';\nimport { ColiderArrangement } from './Brushes/Arrangements/ColiderArrangement';\nexport class ColiderCanvas {\n    constructor() {\n        this._coliderCtx = null;\n        this._secondaryCanvasCtx = null;\n        this._secondaryCanvas = null;\n        this._project = null;\n        this._coliderRenderer = null;\n        this._arrangement = new ColiderArrangement();\n        this._isMouseDown = false;\n        this._lastMapChipPosition = { x: -1, y: -1 };\n        this._selectedColiderType = 0;\n        this._selectedSubColiderType = 0;\n        this._renderAllCallbackItem = null;\n        this._brush = new Pen();\n        this._setupBrush();\n    }\n    get selectedColiderType() {\n        return this._selectedColiderType;\n    }\n    get selectedSubColiderType() {\n        return this._selectedSubColiderType;\n    }\n    get project() {\n        if (!this._project)\n            throw new Error('The project is not set');\n        return this._project;\n    }\n    get hasProject() {\n        return !!this._project;\n    }\n    get coliderCtx() {\n        if (!this._coliderCtx)\n            throw new Error('A canvas is not set');\n        return this._coliderCtx;\n    }\n    get secondaryCanvasCtx() {\n        if (!this._secondaryCanvasCtx)\n            throw new Error('A canvas is not set');\n        return this._secondaryCanvasCtx;\n    }\n    get coliderRenderer() {\n        if (!this._coliderRenderer)\n            throw new Error('The project is not set');\n        return this._coliderRenderer;\n    }\n    get secondaryCanvas() {\n        if (!this._secondaryCanvas)\n            throw new Error('A canvas is not set');\n        return this._secondaryCanvas;\n    }\n    get isMouseDown() {\n        return this._isMouseDown;\n    }\n    get renderable() {\n        return !!this._coliderCtx && !!this._coliderRenderer;\n    }\n    get isSubscribedProjectEvent() {\n        return !!this._renderAllCallbackItem;\n    }\n    setProject(project) {\n        if (this.isSubscribedProjectEvent)\n            throw new Error('This colider-canvas is subscribed to the project event. You need to unsubscribe.');\n        this._project = project;\n        this._coliderRenderer = new ColiderRenderer(this._project.tiledMap);\n        if (this.renderable && this._coliderCtx) {\n            this.coliderRenderer.renderAll(this._coliderCtx);\n        }\n    }\n    subscribeProjectEvent() {\n        if (this._renderAllCallbackItem)\n            throw new Error('Project Event is already subscribed');\n        if (!this._project)\n            throw new Error('Project is not set');\n        this._renderAllCallbackItem = this._project.setCallback('renderAll', () => {\n            if (!this.renderable || !this._coliderCtx)\n                return;\n            this.coliderRenderer.renderAll(this._coliderCtx);\n        });\n    }\n    unsubscribeProjectEvent() {\n        if (this._project && this._renderAllCallbackItem)\n            this._project.removeCallback('renderAll', this._renderAllCallbackItem);\n        this._renderAllCallbackItem = null;\n    }\n    setCanvas(canvas, secondaryCanvas) {\n        this._coliderCtx = canvas.getContext('2d');\n        this._secondaryCanvasCtx = secondaryCanvas.getContext('2d');\n        this._secondaryCanvas = secondaryCanvas;\n        if (this.renderable) {\n            this.coliderRenderer.renderAll(this._coliderCtx);\n        }\n    }\n    setBrush(brush) {\n        this._brush = brush;\n        this._setupBrush();\n    }\n    setArrangement(value) {\n        this._arrangement = value;\n    }\n    setBrushFromName(brushName) {\n        const registeredBrush = Brushes.find(registeredBrush => registeredBrush.name === brushName);\n        if (!registeredBrush) {\n            this.setBrush(new Pen());\n        }\n        else {\n            this.setBrush(registeredBrush.create());\n        }\n    }\n    setColiderType(value) {\n        this._selectedColiderType = value;\n    }\n    setSubColiderType(value) {\n        this._selectedSubColiderType = value;\n    }\n    _setupBrush(isSubButton = false) {\n        this._brush.setArrangement(this._arrangement);\n        if (isColiderTypesRequired(this._arrangement)) {\n            this._arrangement.setColiderTypes(isSubButton ? this._selectedSubColiderType : this._selectedColiderType);\n        }\n    }\n    mouseDown(x, y, isSubButton = false) {\n        this._isMouseDown = true;\n        this._setupBrush(isSubButton);\n        const chipPosition = this.convertFromCursorPositionToChipPosition(x, y);\n        this._brush.mouseDown(chipPosition.x, chipPosition.y);\n        this._paint(chipPosition);\n        this._lastMapChipPosition = chipPosition;\n    }\n    mouseMove(x, y) {\n        const chipPosition = this.convertFromCursorPositionToChipPosition(x, y);\n        if (!this._isMouseDown)\n            return chipPosition;\n        if (chipPosition.x === this._lastMapChipPosition.x && chipPosition.y === this._lastMapChipPosition.y)\n            return chipPosition;\n        this._paint(chipPosition);\n        this._lastMapChipPosition = chipPosition;\n        return chipPosition;\n    }\n    mouseUp() {\n        this._brush.mouseUp(this._lastMapChipPosition.x, this._lastMapChipPosition.y).forEach(paint => {\n            const chip = paint.item;\n            this.putChip(chip, paint.x, paint.y);\n        });\n        this.reset();\n    }\n    reset() {\n        if (!this._isMouseDown)\n            return;\n        this._isMouseDown = false;\n        this.clearSecondaryCanvas();\n        this._brush.cleanUp();\n        this._lastMapChipPosition = { x: -1, y: -1 };\n    }\n    _paint(chipPosition) {\n        this.clearSecondaryCanvas();\n        this._brush.mouseMove(chipPosition.x, chipPosition.y).forEach(paint => {\n            const chip = paint.item;\n            this.coliderRenderer.putOrClearChipToCanvas(this.secondaryCanvasCtx, chip, paint.x, paint.y, true);\n        });\n    }\n    putChip(coliderType, chipX, chipY) {\n        this.project.tiledMap.coliders.put(coliderType, chipX, chipY);\n        this.coliderRenderer.putOrClearChipToCanvas(this.coliderCtx, coliderType, chipX, chipY);\n    }\n    clearSecondaryCanvas() {\n        this.secondaryCanvasCtx.clearRect(0, 0, this.secondaryCanvas.width, this.secondaryCanvas.height);\n    }\n    convertFromCursorPositionToChipPosition(x, y) {\n        return {\n            x: Math.max(0, Math.min(Math.floor(x / this.project.tiledMap.chipWidth), this.project.tiledMap.chipCountX - 1)),\n            y: Math.max(0, Math.min(Math.floor(y / this.project.tiledMap.chipHeight), this.project.tiledMap.chipCountY - 1))\n        };\n    }\n}\n","/**\n * @license\n * Copyright 2021 piyoppi\n * SPDX-License-Identifier: MIT\n */\nexport class ColiderRenderer {\n    constructor(_tiledMap) {\n        this._tiledMap = _tiledMap;\n        this._backgroundRgba = { r: 255, g: 255, b: 255, a: 1.0 };\n    }\n    renderAll(ctx) {\n        this._tiledMap.coliders.items.forEach((value, index) => {\n            const position = this._tiledMap.convertMapNumberToPosition(index);\n            this.putOrClearChipToCanvas(ctx, value, position.x, position.y);\n        });\n    }\n    putOrClearChipToCanvas(ctx, coliderType, chipX, chipY, isTemporaryRendering = false) {\n        if (coliderType === 1) {\n            this._putToCanvas(ctx, chipX, chipY);\n        }\n        else {\n            this._clearChipToCanvas(ctx, chipX, chipY, isTemporaryRendering);\n        }\n    }\n    _clearChipToCanvas(ctx, chipX, chipY, isTemporaryRendering) {\n        const position = this._tiledMap.convertChipPositionToPixel(chipX, chipY);\n        ctx.clearRect(position.x, position.y, this._tiledMap.chipWidth, this._tiledMap.chipHeight);\n        if (isTemporaryRendering) {\n            ctx.fillStyle = `rgba(${this._backgroundRgba.r},${this._backgroundRgba.g},${this._backgroundRgba.b},${this._backgroundRgba.a})`;\n            ctx.fillRect(position.x, position.y, this._tiledMap.chipWidth, this._tiledMap.chipHeight);\n        }\n    }\n    _putToCanvas(ctx, chipX, chipY) {\n        const position = this._tiledMap.convertChipPositionToPixel(chipX, chipY);\n        ctx.clearRect(position.x, position.y, this._tiledMap.chipWidth, this._tiledMap.chipHeight);\n        ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';\n        ctx.fillRect(position.x, position.y, this._tiledMap.chipWidth, this._tiledMap.chipHeight);\n    }\n}\n","/**\n * @license\n * Copyright 2021 piyoppi\n * SPDX-License-Identifier: MIT\n */\nexport function convertFromCursorPositionToChipPosition(x, y, chipWidth, chipHeight, chipCountX, chipCountY, cursorWidth = 1, cursorHeight = 1) {\n    const offsetX = (Math.floor(cursorWidth / 2) * chipWidth) / 2;\n    const offsetY = (Math.floor(cursorHeight / 2) * chipHeight) / 2;\n    return {\n        x: Math.max(0, Math.min(Math.floor((x - offsetX) / chipWidth), chipCountX - cursorWidth)),\n        y: Math.max(0, Math.min(Math.floor((y - offsetY) / chipHeight), chipCountY - cursorHeight))\n    };\n}\nexport function convertChipPositionDivisionByCursorSize(x, y, baseX, baseY, cursorWidth, cursorHeight) {\n    return {\n        x: Math.floor((x - baseX) / cursorWidth) * cursorWidth + baseX,\n        y: Math.floor((y - baseY) / cursorHeight) * cursorHeight + baseY,\n    };\n}\n","/**\n * @license\n * Copyright 2021 piyoppi\n * SPDX-License-Identifier: MIT\n */\nexport class GridImageGenerator {\n    constructor() {\n        this._width = 0;\n        this._height = 0;\n        this._changed = false;\n        this._color = '#000000';\n    }\n    get changed() {\n        return this._changed;\n    }\n    get gridColor() {\n        return this._color;\n    }\n    get width() {\n        return this._width;\n    }\n    get height() {\n        return this._height;\n    }\n    set gridColor(color) {\n        this._changed = this._color !== color;\n        this._color = color;\n    }\n    setGridSize(width, height) {\n        this._changed = (this._width !== width) || (this._height !== height);\n        this._width = width;\n        this._height = height;\n    }\n    generateDottedPart() {\n        const { canvas, context } = this.createCanvas();\n        context.fillRect(this._width - 1, this._height - 1, 1, 1);\n        return canvas;\n    }\n    generateLinePart() {\n        const { canvas, context } = this.createCanvas();\n        context.fillRect(0, this._height - 1, this._width, 1);\n        context.fillRect(this._width - 1, 0, 1, this._height);\n        return canvas;\n    }\n    createCanvas() {\n        const canvas = document.createElement('canvas');\n        const context = canvas.getContext('2d');\n        if (!context) {\n            throw new Error();\n        }\n        canvas.width = this._width;\n        canvas.height = this._height;\n        context.fillStyle = this._color;\n        return {\n            canvas,\n            context\n        };\n    }\n}\n","/**\n * @license\n * Copyright 2021 piyoppi\n * SPDX-License-Identifier: MIT\n */\nexport class Injector {\n    inject(calledObject, method, before, after) {\n        const original = calledObject[method.name];\n        calledObject[method.name] = (...args) => {\n            if (before)\n                before();\n            const result = original.apply(calledObject, args);\n            if (after)\n                after();\n            return result;\n        };\n    }\n}\n","/**\n * @license\n * Copyright 2021 piyoppi\n * SPDX-License-Identifier: MIT\n */\nimport { MapRenderer, isAutoTileMapChip } from '@piyoppi/pico2map-tiled';\nimport { Pen } from './Brushes/Pen';\nimport { Brushes } from './Brushes/Brushes';\nimport { Arrangements } from './Brushes/Arrangements/Arrangements';\nimport { isMapChipFragmentRequired, isTiledMapDataRequired, isAutoTileRequired, isAutoTilesRequired } from './Brushes/Arrangements/Arrangement';\nimport { DefaultArrangement } from './Brushes/Arrangements/DefaultArrangement';\nimport { MapChipPicker } from './MapChipPicker';\nimport { convertFromCursorPositionToChipPosition, convertChipPositionDivisionByCursorSize } from './CursorPositionConverter';\nexport class MapCanvas {\n    constructor() {\n        this._secondaryCanvasCtx = null;\n        this._isMouseDown = false;\n        this._brush = new Pen();\n        this._arrangement = new DefaultArrangement();\n        this._lastMapChipPosition = { x: -1, y: -1 };\n        this._mapMouseDownPosition = { x: -1, y: -1 };\n        this._canvasContexts = [];\n        this.secondaryCanvas = null;\n        this._project = null;\n        this._renderer = null;\n        this._selectedAutoTile = null;\n        this._selectedMapChipFragments = [];\n        this._selectedMapChipFragmentBoundarySize = { width: 0, height: 0 };\n        this._activeLayerIndex = 0;\n        this._mapChipPickerEnabled = true;\n        this._mapChipPicker = null;\n        this._isPickFromActiveLayer = false;\n        this._pickedCallback = null;\n        this._renderAllCallbackItem = null;\n    }\n    get selectedAutoTile() {\n        return this._selectedAutoTile;\n    }\n    get selectedMapChipFragments() {\n        return this._selectedMapChipFragments;\n    }\n    get project() {\n        if (!this._project)\n            throw new Error('Project is not set');\n        return this._project;\n    }\n    get hasProject() {\n        return !!this._project;\n    }\n    get renderer() {\n        if (!this._renderer)\n            throw new Error('Renderer is not set');\n        return this._renderer;\n    }\n    get activeLayer() {\n        return this._activeLayerIndex;\n    }\n    get isMouseDown() {\n        return this._isMouseDown;\n    }\n    get renderable() {\n        return this._canvasContexts.length > 0 && !!this._renderer;\n    }\n    get mapChipPickerEnabled() {\n        return this._mapChipPickerEnabled;\n    }\n    get isPickFromActiveLayer() {\n        return this._isPickFromActiveLayer;\n    }\n    get selectedMapChipFragmentBoundarySize() {\n        return this._selectedMapChipFragmentBoundarySize;\n    }\n    set isPickFromActiveLayer(value) {\n        this._isPickFromActiveLayer = value;\n    }\n    get isSubscribedProjectEvent() {\n        return !!this._renderAllCallbackItem;\n    }\n    hasActiveAutoTile() {\n        return !!this._selectedAutoTile;\n    }\n    setProject(project) {\n        if (this._project === project)\n            throw new Error('This project has already been set.');\n        if (this.isSubscribedProjectEvent)\n            throw new Error('This map-canvas is subscribed to the project event. You need to unsubscribe.');\n        this._project = project;\n        this._renderer = new MapRenderer(this._project.tiledMap);\n        this._mapChipPicker = new MapChipPicker(this._project.tiledMap);\n        this._setupBrush();\n    }\n    subscribeProjectEvent() {\n        if (this._renderAllCallbackItem)\n            throw new Error('Project Event is already subscribed');\n        if (!this._project)\n            throw new Error('Project is not set');\n        this._renderAllCallbackItem = this._project.setCallback('renderAll', () => this.renderAll());\n    }\n    unsubscribeProjectEvent() {\n        if (this._project && this._renderAllCallbackItem)\n            this._project.removeCallback('renderAll', this._renderAllCallbackItem);\n        this._renderAllCallbackItem = null;\n    }\n    async firstRenderAll() {\n        if (!this._project)\n            return;\n        await this._project.tiledMap.mapChipsCollection.waitWhileLoading();\n        if (this.renderable) {\n            this.renderAll();\n        }\n    }\n    renderAll() {\n        if (!this.renderable)\n            return;\n        const renderer = this.renderer;\n        this._canvasContexts.forEach((ctx, index) => (this.project.tiledMap.datas.length > index) && renderer.renderLayer(index, ctx));\n    }\n    setCanvases(canvases, secondaryCanvas) {\n        this._canvasContexts = canvases.map(canvas => canvas.getContext('2d'));\n        this.secondaryCanvas = secondaryCanvas;\n        this._secondaryCanvasCtx = this.secondaryCanvas.getContext('2d');\n        if (this.renderable) {\n            this.renderAll();\n        }\n    }\n    addCanvas(canvas) {\n        this._canvasContexts.push(canvas.getContext('2d'));\n    }\n    setAutoTile(value) {\n        this._selectedAutoTile = value;\n        this._selectedMapChipFragmentBoundarySize = { width: 1, height: 1 };\n    }\n    setMapChipFragments(value) {\n        this._selectedMapChipFragments = value;\n        const boundary = value\n            .reduce((acc, val) => ({ x1: Math.min(acc.x1, val.x), y1: Math.min(acc.y1, val.y), x2: Math.max(acc.x2, val.x), y2: Math.max(acc.y2, val.y) }), { x1: value[0].x, y1: value[0].y, x2: value[0].x, y2: value[0].y });\n        this._selectedMapChipFragmentBoundarySize = { width: boundary.x2 - boundary.x1 + 1, height: boundary.y2 - boundary.y1 + 1 };\n    }\n    setPickedCallback(callbackFn) {\n        this._pickedCallback = callbackFn;\n    }\n    setBrushFromName(brushName) {\n        const registeredBrush = Brushes.find(registeredBrush => registeredBrush.name === brushName);\n        if (!registeredBrush) {\n            this.setBrush(new Pen());\n        }\n        else {\n            this.setBrush(registeredBrush.create());\n        }\n    }\n    setArrangementFromName(arrangementName) {\n        const registeredArrangement = Arrangements.find(registered => registered.name === arrangementName);\n        if (!registeredArrangement) {\n            this.setArrangement(new DefaultArrangement());\n        }\n        else {\n            this.setArrangement(registeredArrangement.create());\n        }\n    }\n    setActiveLayer(index) {\n        if (!this._project)\n            return;\n        if (index < 0 || index >= this._project.tiledMap.datas.length) {\n            throw new Error('The layer index is out of range.');\n        }\n        this._activeLayerIndex = index;\n        this._setupBrush();\n    }\n    setMapChipPickerEnabled(value) {\n        this._mapChipPickerEnabled = value;\n    }\n    _setupBrush() {\n        if (!this._project || !this._arrangement)\n            return;\n        this._brush.setArrangement(this._arrangement);\n        if (isTiledMapDataRequired(this._arrangement)) {\n            this._arrangement.setTiledMapData(this._project.tiledMap.datas[this._activeLayerIndex]);\n        }\n    }\n    setArrangement(arrangement) {\n        this._arrangement = arrangement;\n        this._setupBrush();\n    }\n    setBrush(brush) {\n        this._brush = brush;\n        this._setupBrush();\n    }\n    mouseDown(x, y, isSubButton = false) {\n        const chipPosition = this.convertFromCursorPositionToChipPosition(x, y);\n        if (isSubButton && this._mapChipPickerEnabled) {\n            this.pick(chipPosition.x, chipPosition.y);\n            return;\n        }\n        if (isMapChipFragmentRequired(this._arrangement) && !isAutoTileRequired(this._arrangement) && this._selectedMapChipFragments.length < 1)\n            return;\n        if (isAutoTileRequired(this._arrangement) && !this.selectedAutoTile)\n            return;\n        this._isMouseDown = true;\n        if (isMapChipFragmentRequired(this._arrangement)) {\n            this._arrangement.setMapChips(this._selectedMapChipFragments);\n        }\n        if (isAutoTileRequired(this._arrangement) && this._selectedAutoTile) {\n            this._arrangement.setAutoTile(this._selectedAutoTile);\n        }\n        if (isAutoTilesRequired(this._arrangement)) {\n            this._arrangement.setAutoTiles(this.project.tiledMap.autoTiles);\n        }\n        this._brush.mouseDown(chipPosition.x, chipPosition.y);\n        this._mapMouseDownPosition = this._lastMapChipPosition = chipPosition;\n        this._paint(chipPosition);\n    }\n    mouseMove(x, y) {\n        const cursorPosition = this.convertFromCursorPositionToChipPosition(x, y);\n        const chipPosition = convertChipPositionDivisionByCursorSize(cursorPosition.x, cursorPosition.y, this._mapMouseDownPosition.x, this._mapMouseDownPosition.y, this._selectedMapChipFragmentBoundarySize.width, this._selectedMapChipFragmentBoundarySize.height);\n        if (!this._isMouseDown)\n            return chipPosition;\n        if (chipPosition.x === this._lastMapChipPosition.x && chipPosition.y === this._lastMapChipPosition.y)\n            return chipPosition;\n        this._paint(chipPosition);\n        this._lastMapChipPosition = chipPosition;\n        return chipPosition;\n    }\n    mouseUp() {\n        if (!this._isMouseDown)\n            return;\n        const chipPosition = this._lastMapChipPosition;\n        this._brush.mouseUp(chipPosition.x, chipPosition.y).forEach(paint => {\n            const chip = paint.item;\n            this.putChip(chip, paint.x, paint.y);\n        });\n        this.reset();\n    }\n    reset() {\n        if (!this._isMouseDown)\n            return;\n        this._isMouseDown = false;\n        this.clearSecondaryCanvas();\n        this._brush.cleanUp();\n        this._mapMouseDownPosition = this._lastMapChipPosition = { x: -1, y: -1 };\n    }\n    putChip(mapChip, chipX, chipY) {\n        this.project.tiledMap.put(mapChip, chipX, chipY, this._activeLayerIndex);\n        this.renderer.putOrClearChipToCanvas(this._canvasContexts[this._activeLayerIndex], mapChip, chipX, chipY);\n    }\n    _paint(chipPosition) {\n        this.clearSecondaryCanvas();\n        this._brush.mouseMove(chipPosition.x, chipPosition.y).forEach(paint => {\n            if (!this._secondaryCanvasCtx)\n                return;\n            const chip = paint.item;\n            this.renderer.putOrClearChipToCanvas(this._secondaryCanvasCtx, chip, paint.x, paint.y, true);\n        });\n    }\n    clearSecondaryCanvas() {\n        if (!this.secondaryCanvas || !this._secondaryCanvasCtx)\n            return;\n        this._secondaryCanvasCtx.clearRect(0, 0, this.secondaryCanvas.width, this.secondaryCanvas.height);\n    }\n    convertFromCursorPositionToChipPosition(x, y) {\n        return convertFromCursorPositionToChipPosition(x, y, this.project.tiledMap.chipWidth, this.project.tiledMap.chipHeight, this.project.tiledMap.chipCountX, this.project.tiledMap.chipCountY, this._selectedMapChipFragmentBoundarySize.width, this._selectedMapChipFragmentBoundarySize.height);\n    }\n    pick(x, y) {\n        var _a, _b;\n        if (!this._mapChipPicker)\n            return;\n        const picked = this._isPickFromActiveLayer ? (_a = this._mapChipPicker) === null || _a === void 0 ? void 0 : _a.pick(x, y, this._activeLayerIndex) : (_b = this._mapChipPicker) === null || _b === void 0 ? void 0 : _b.pick(x, y);\n        if (isAutoTileMapChip(picked)) {\n            const autoTile = this.project.tiledMap.autoTiles.fromId(picked.autoTileId);\n            if (autoTile)\n                this.setAutoTile(autoTile);\n        }\n        else if (picked) {\n            this.setMapChipFragments(picked.items);\n        }\n        if (this._pickedCallback)\n            this._pickedCallback(picked);\n    }\n}\n","/**\n * @license\n * Copyright 2021 piyoppi\n * SPDX-License-Identifier: MIT\n */\nexport class MapChipPicker {\n    constructor(_tiledMap) {\n        this._tiledMap = _tiledMap;\n    }\n    pick(x, y, layerIndex) {\n        if (layerIndex !== undefined) {\n            return this._tiledMap.datas[layerIndex].getFromChipPosition(x, y);\n        }\n        return this._tiledMap.datas.reduce((acc, data) => {\n            const chip = data.getFromChipPosition(x, y);\n            if (chip)\n                return chip;\n            return acc;\n        }, null);\n    }\n}\n","/**\n * @license\n * Copyright 2021 piyoppi\n * SPDX-License-Identifier: MIT\n */\nimport { MapChipFragment } from '@piyoppi/pico2map-tiled';\nexport class MapChipSelector {\n    constructor(_tiledMap, _chipImage) {\n        this._tiledMap = _tiledMap;\n        this._chipImage = _chipImage;\n        this._selectedChips = [];\n        this._selecting = false;\n        this._startChipPosition = { x: -1, y: -1 };\n        this._endChipPosition = { x: -1, y: -1 };\n    }\n    get chipImage() {\n        return this._chipImage;\n    }\n    get selectedChips() {\n        return this._selectedChips;\n    }\n    get selecting() {\n        return this._selecting;\n    }\n    get startChipPosition() {\n        return {\n            x: Math.min(this._startChipPosition.x, this._endChipPosition.x),\n            y: Math.min(this._startChipPosition.y, this._endChipPosition.y)\n        };\n    }\n    get startPosition() {\n        const startChipPosition = this.startChipPosition;\n        return {\n            x: startChipPosition.x * this._tiledMap.chipWidth,\n            y: startChipPosition.y * this._tiledMap.chipHeight\n        };\n    }\n    get selectedChipSize() {\n        return {\n            width: (Math.abs(this._endChipPosition.x - this._startChipPosition.x) + 1),\n            height: (Math.abs(this._endChipPosition.y - this._startChipPosition.y) + 1)\n        };\n    }\n    get selectedSize() {\n        const selectedChipSize = this.selectedChipSize;\n        return {\n            width: selectedChipSize.width * this._tiledMap.chipWidth,\n            height: selectedChipSize.height * this._tiledMap.chipHeight\n        };\n    }\n    clear() {\n        this._selectedChips.length = 0;\n    }\n    _selectAtMouseCursor() {\n        this.clear();\n        const chipPosition = {\n            x: Math.min(this._startChipPosition.x, this._endChipPosition.x),\n            y: Math.min(this._startChipPosition.y, this._endChipPosition.y)\n        };\n        const maximumChipCount = this._chipImage.getChipCount(this._tiledMap.chipWidth, this._tiledMap.chipHeight);\n        const { width, height } = this.selectedChipSize;\n        if (chipPosition.x + width > maximumChipCount.width) {\n            chipPosition.x = maximumChipCount.width - width;\n        }\n        if (chipPosition.y + height > maximumChipCount.height) {\n            chipPosition.y = maximumChipCount.height - height;\n        }\n        if (chipPosition.x < 0 || chipPosition.y < 0) {\n            throw new Error('MapChipImage is not enough size.');\n        }\n        for (let x = 0; x < width; x++) {\n            for (let y = 0; y < height; y++) {\n                this._selectedChips.push(new MapChipFragment(chipPosition.x + x, chipPosition.y + y, this._chipImage.id));\n            }\n        }\n    }\n    mouseDown(x, y) {\n        const chipPosition = this.convertFromImagePositionToChipPosition(x, y);\n        this._startChipPosition = { ...chipPosition };\n        this._endChipPosition = { ...chipPosition };\n        this._selecting = true;\n    }\n    mouseMove(x, y) {\n        if (!this._selecting)\n            return;\n        const chipPosition = this.convertFromImagePositionToChipPosition(x, y);\n        this._endChipPosition = { ...chipPosition };\n    }\n    mouseUp(x, y) {\n        if (!this._selecting)\n            return;\n        const chipPosition = this.convertFromImagePositionToChipPosition(x, y);\n        this._endChipPosition = { ...chipPosition };\n        this._selectAtMouseCursor();\n        this._selecting = false;\n    }\n    convertFromImagePositionToChipPosition(x, y) {\n        const chipCount = this._chipImage.getChipCount(this._tiledMap.chipWidth, this._tiledMap.chipHeight);\n        return {\n            x: Math.max(0, Math.min(Math.floor(x / this._tiledMap.chipWidth), chipCount.width - 1)),\n            y: Math.max(0, Math.min(Math.floor(y / this._tiledMap.chipHeight), chipCount.height - 1))\n        };\n    }\n}\n","/**\n * @license\n * Copyright 2021 piyoppi\n * SPDX-License-Identifier: MIT\n */\nimport { CallbackCallers } from './CallbackCallers';\nimport { Injector } from './Injector';\nexport class Project {\n    constructor(_tiledMap, _projectId) {\n        this._tiledMap = _tiledMap;\n        this._projectId = _projectId;\n        this._callbacks = new CallbackCallers();\n        const injector = new Injector();\n        injector.inject(_tiledMap, _tiledMap.addLayer, () => this._beforeAddLayerHandler(), null);\n        injector.inject(_tiledMap, _tiledMap.resize, null, () => this._afterResizedMapHandler());\n        injector.inject(_tiledMap.autoTiles, _tiledMap.autoTiles.push, null, () => this._afterAddAutoTileHandler());\n        injector.inject(_tiledMap.autoTiles, _tiledMap.autoTiles.remove, null, () => this._afterRemoveAutoTileHandler());\n        injector.inject(_tiledMap.mapChipsCollection, _tiledMap.mapChipsCollection.replace, null, () => this._afterReplacedMapChipImageHandler());\n    }\n    get callbacks() {\n        return this._callbacks;\n    }\n    get projectId() {\n        return this._projectId;\n    }\n    get tiledMap() {\n        return this._tiledMap;\n    }\n    requestRenderAll() {\n        this._callbacks.call('renderAll');\n    }\n    setCallback(key, callback) {\n        return this._callbacks.add(key, callback);\n    }\n    removeCallback(key, callbackItem) {\n        this._callbacks.remove(key, callbackItem);\n    }\n    _beforeAddLayerHandler() {\n        this._callbacks.call('beforeAddLayer');\n    }\n    _afterAddAutoTileHandler() {\n        this._callbacks.call('afterAddAutoTile');\n    }\n    _afterRemoveAutoTileHandler() {\n        this._callbacks.call('afterRemoveAutoTile');\n    }\n    _afterReplacedMapChipImageHandler() {\n        this._callbacks.call('afterReplacedMapChipImage');\n    }\n    _afterResizedMapHandler() {\n        this._callbacks.call('afterResizedMap');\n    }\n}\nexport class Projects {\n    static setProjectAddCallbackFunction(fn) {\n        this._projectAddCallbackFunctions.push(fn);\n    }\n    static get items() {\n        return Projects._items;\n    }\n    static add(tiledMap, projectId = -1) {\n        const id = projectId > 0 ? projectId : Projects.createId();\n        const project = new Project(tiledMap, id);\n        Projects._items.push(project);\n        this._projectAddCallbackFunctions.forEach(fn => fn());\n        return project;\n    }\n    static clear() {\n        this._items.length = 0;\n    }\n    static fromProjectId(projectId) {\n        return this._items.find(item => item.projectId === projectId) || null;\n    }\n    static createId() {\n        return ++Projects._idCounter;\n    }\n}\nProjects._idCounter = 0;\nProjects._items = [];\nProjects._projectAddCallbackFunctions = [];\n","/**\n * @license\n * Copyright 2021 piyoppi\n * SPDX-License-Identifier: MIT\n */\nexport { GridImageGenerator } from './GridImageGenerator';\nexport { CallbackItem } from './CallbackItem';\nexport { MapCanvas } from './MapCanvas';\nexport { Projects, Project } from './Projects';\nexport { ColiderCanvas } from './ColiderCanvas';\nexport { AutoTileSelector } from './AutoTileSelector';\nexport { MapChipSelector } from './MapChipSelector';\nexport { convertFromCursorPositionToChipPosition, convertChipPositionDivisionByCursorSize } from './CursorPositionConverter';\n","/**\n * @license\n * Copyright 2021 piyoppi\n * SPDX-License-Identifier: MIT\n */\nimport { MapChipFragment } from './../MapChip';\nexport class AutoTile {\n    constructor(_mapChipFragments, _id) {\n        this._mapChipFragments = _mapChipFragments;\n        this._id = _id;\n    }\n    get id() {\n        return this._id;\n    }\n    get mapChipFragments() {\n        return this._mapChipFragments;\n    }\n    getMapChipImageIds() {\n        const chipIds = new Set();\n        this._mapChipFragments.forEach(fragment => chipIds.add(fragment.chipId));\n        return Array.from(chipIds.values());\n    }\n    toObject() {\n        return {\n            id: this._id,\n            mapChipFragments: this._mapChipFragments.map(fragment => fragment.toObject())\n        };\n    }\n    static fromObject(val) {\n        return new AutoTile(val.mapChipFragments.map(fragment => MapChipFragment.fromObject(fragment)), val.id);\n    }\n}\n//# sourceMappingURL=AutoTile.js.map","/**\n * @license\n * Copyright 2021 piyoppi\n * SPDX-License-Identifier: MIT\n */\nimport { AutoTile } from './AutoTile';\nexport class AutoTiles {\n    constructor() {\n        this._autoTiles = new Map();\n        this._maxId = 0;\n    }\n    get length() {\n        return this._autoTiles.size;\n    }\n    push(item) {\n        this._autoTiles.set(item.id, item);\n        this._maxId = Math.max(this._maxId, item.id);\n    }\n    remove(item) {\n        this._autoTiles.delete(item.id);\n    }\n    findByImage(image) {\n        const valuesItr = this._autoTiles.values();\n        return Array.from(valuesItr).filter(autoTile => autoTile.mapChipFragments.some(fragment => fragment.chipId === image.id));\n    }\n    fromId(id) {\n        return this._autoTiles.get(id) || null;\n    }\n    values() {\n        return this._autoTiles.values();\n    }\n    import(strategy) {\n        const mapChipFragmentGroups = strategy.getMapChipFragments();\n        return mapChipFragmentGroups.map(group => {\n            const autoTile = new AutoTile(group, ++this._maxId);\n            this.push(autoTile);\n            return autoTile;\n        });\n    }\n    toObject() {\n        const objectedAutoTiles = [];\n        const valuesItr = this._autoTiles.values();\n        for (const val of valuesItr) {\n            objectedAutoTiles.push(val.toObject());\n        }\n        return {\n            autoTiles: objectedAutoTiles\n        };\n    }\n    fromObject(val) {\n        this._autoTiles.clear();\n        val.autoTiles.forEach(objectedAutoTile => {\n            const autoTile = AutoTile.fromObject(objectedAutoTile);\n            this.push(autoTile);\n            this._maxId = Math.max(this._maxId, autoTile.id);\n        });\n    }\n}\n//# sourceMappingURL=AutoTiles.js.map","/**\n * @license\n * Copyright 2021 piyoppi\n * SPDX-License-Identifier: MIT\n */\nimport { MapChipFragment } from './../MapChip';\nexport class DefaultAutoTileImportStrategy {\n    constructor(_mapChipImage, _chipWidth, _chipHeight) {\n        this._mapChipImage = _mapChipImage;\n        this._chipWidth = _chipWidth;\n        this._chipHeight = _chipHeight;\n    }\n    getMapChipFragments() {\n        const heightChipCountPerUnit = 5;\n        const countX = Math.floor(this._mapChipImage.image.width / this._chipWidth);\n        const countY = Math.floor(Math.floor(this._mapChipImage.image.height / this._chipHeight) / heightChipCountPerUnit);\n        const mapChipFragmentGroups = [];\n        for (let cy = 0; cy < countY; cy++) {\n            const y = cy * heightChipCountPerUnit;\n            for (let x = 0; x < countX; x++) {\n                const mapChipFragments = [];\n                mapChipFragments.push(new MapChipFragment(x, y, this._mapChipImage.id));\n                mapChipFragments.push(new MapChipFragment(x, y + 1, this._mapChipImage.id));\n                mapChipFragments.push(new MapChipFragment(x, y + 2, this._mapChipImage.id));\n                mapChipFragments.push(new MapChipFragment(x, y + 3, this._mapChipImage.id));\n                mapChipFragments.push(new MapChipFragment(x, y + 4, this._mapChipImage.id));\n                mapChipFragmentGroups.push(mapChipFragments);\n            }\n        }\n        return mapChipFragmentGroups;\n    }\n}\n//# sourceMappingURL=DefaultAutoTileImportStrategy.js.map","/**\n * @license\n * Copyright 2021 piyoppi\n * SPDX-License-Identifier: MIT\n */\nexport class MapChipFragment {\n    constructor(_x, _y, _chipId, \n    /**\n     *  _renderingArea indicates the area where this map-chip is to be drawn.\n     *  It is represented by a OR of the following area-numbers.\n     *\n     * |<- 1chip ->|\n     * *-----*-----* ---\n     * |  1  |  2  |  ↑\n     * *-----*-----* 1chip\n     * |  4  |  8  |  ↓\n     * *-----*-----* ---\n     */\n    _renderingArea = 15) {\n        this._x = _x;\n        this._y = _y;\n        this._chipId = _chipId;\n        this._renderingArea = _renderingArea;\n        this._identifyKey = '';\n        this._identifyKey = `${_x},${_y},${_chipId}`;\n    }\n    get x() {\n        return this._x;\n    }\n    get y() {\n        return this._y;\n    }\n    get chipId() {\n        return this._chipId;\n    }\n    get identifyKey() {\n        return this._identifyKey;\n    }\n    get renderingArea() {\n        return this._renderingArea;\n    }\n    withParameter(parameters) {\n        if (parameters.x)\n            this._x = parameters.x;\n        if (parameters.y)\n            this._y = parameters.y;\n        if (parameters.renderingArea)\n            this._renderingArea = parameters.renderingArea;\n        return this;\n    }\n    clone() {\n        return new MapChipFragment(this._x, this._y, this._chipId);\n    }\n    compare(others) {\n        return this.identifyKey === others.identifyKey;\n    }\n    toObject() {\n        return {\n            x: this._x,\n            y: this._y,\n            chipId: this._chipId,\n            renderingArea: this._renderingArea\n        };\n    }\n    static fromObject(val) {\n        return new MapChipFragment(val.x, val.y, val.chipId, val.renderingArea);\n    }\n}\nexport class MapChip {\n    constructor(_items = [], _arrangementName = '') {\n        this._items = _items;\n        this._arrangementName = _arrangementName;\n        this._identifyKey = '';\n        this._buildIdentifyKey();\n    }\n    get items() {\n        return this._items;\n    }\n    get identifyKey() {\n        return this._identifyKey;\n    }\n    get length() {\n        return this._items.length;\n    }\n    get arrangementName() {\n        return this._arrangementName;\n    }\n    _buildIdentifyKey() {\n        this._identifyKey = this._items.map(item => item.identifyKey).join('|');\n    }\n    setArrangementName(name) {\n        this._arrangementName = name;\n    }\n    push(mapChip) {\n        this._items.push(mapChip);\n        this._buildIdentifyKey();\n    }\n    clear() {\n        this._items.length = 0;\n        this._buildIdentifyKey();\n    }\n    clone() {\n        const cloned = new MapChip();\n        cloned._items = this._items.map(mapChip => mapChip.clone());\n        return cloned;\n    }\n    compare(others) {\n        return this.identifyKey === others.identifyKey;\n    }\n    toObject() {\n        return {\n            items: this._items.map(item => item.toObject()),\n            arrangementName: this._arrangementName\n        };\n    }\n    static fromObject(val) {\n        return new MapChip(val.items.map(item => MapChipFragment.fromObject(item)), val.arrangementName);\n    }\n}\nexport function isAutoTileMapChipProperties(obj) {\n    return obj &&\n        typeof obj.autoTileId === 'number' &&\n        obj.boundary !== undefined &&\n        obj.cross !== undefined;\n}\nexport class AutoTileMapChip extends MapChip {\n    constructor(_autoTileId, items = [], _arrangementName = '', _boundary = {\n        top: false,\n        bottom: false,\n        left: false,\n        right: false\n    }, _cross = {\n        topLeft: false,\n        topRight: false,\n        bottomLeft: false,\n        bottomRight: false\n    }) {\n        super(items, _arrangementName);\n        this._autoTileId = _autoTileId;\n        this._boundary = _boundary;\n        this._cross = _cross;\n    }\n    get boundary() {\n        return this._boundary;\n    }\n    get cross() {\n        return this._cross;\n    }\n    get autoTileId() {\n        return this._autoTileId;\n    }\n    setBoundary(boundary) {\n        this._boundary = boundary;\n    }\n    setCross(cross) {\n        this._cross = cross;\n    }\n    toObject() {\n        return {\n            ...super.toObject(),\n            boundary: this._boundary,\n            cross: this._cross,\n            autoTileId: this._autoTileId\n        };\n    }\n    static fromObject(val) {\n        return new AutoTileMapChip(val.autoTileId, val.items.map(item => MapChipFragment.fromObject(item)), val.arrangementName, val.boundary, val.cross);\n    }\n}\nexport function isAutoTileMapChip(obj) {\n    return obj &&\n        typeof obj.boundary === 'object' &&\n        typeof obj.cross === 'object';\n}\n//# sourceMappingURL=MapChip.js.map","/**\n * @license\n * Copyright 2021 piyoppi\n * SPDX-License-Identifier: MIT\n */\nexport class MapChipImage {\n    constructor(_src, _id) {\n        this._src = _src;\n        this._id = _id;\n        this._image = new Image();\n        this._hasImage = false;\n        this._hasError = false;\n        this.loadImage();\n    }\n    get id() {\n        return this._id;\n    }\n    get src() {\n        return this._src;\n    }\n    get hasImage() {\n        return this._hasImage;\n    }\n    get hasError() {\n        return this._hasError;\n    }\n    get image() {\n        return this._image;\n    }\n    getChipCount(chipWidth, chipHeight) {\n        if (!this._hasImage)\n            throw new Error('Image loading is not complete.');\n        return {\n            width: Math.floor(this._image.width / chipWidth),\n            height: Math.floor(this._image.height / chipHeight)\n        };\n    }\n    _loadImageHandler() {\n        this._hasImage = true;\n    }\n    _errorImaegHandler() {\n        this._hasError = true;\n    }\n    loadImage() {\n        this._hasImage = false;\n        this._hasError = false;\n        this._image.onload = () => this._loadImageHandler();\n        this._image.onerror = () => this._errorImaegHandler();\n        this._image.src = this._src;\n    }\n    waitWhileLoading() {\n        const loadingPromise = new Promise((resolve, reject) => {\n            this._image.onload = () => {\n                this._loadImageHandler();\n                resolve();\n            };\n            this._image.onerror = () => {\n                this._errorImaegHandler();\n                reject(new Error('Failed to load the image.'));\n            };\n        });\n        if (this._hasImage)\n            return Promise.resolve();\n        if (this._hasError)\n            return Promise.reject(new Error('Failed to load the image.'));\n        return loadingPromise;\n    }\n    toObject() {\n        return {\n            id: this._id,\n            src: this._src\n        };\n    }\n    static fromObject(val) {\n        return new MapChipImage(val.src, val.id);\n    }\n}\n//# sourceMappingURL=MapChipImage.js.map","/**\n * @license\n * Copyright 2021 piyoppi\n * SPDX-License-Identifier: MIT\n */\nimport { MapChipImage } from './MapChipImage';\nexport class MapChipsCollection {\n    constructor() {\n        this._items = new Map();\n    }\n    push(item) {\n        this._items.set(item.id, item);\n    }\n    remove(item) {\n        this._items.delete(item.id);\n    }\n    replace(replacement) {\n        const target = this.findById(replacement.id);\n        if (!target)\n            throw new Error('Target MapChipImage cannot be found.');\n        this.remove(target);\n        this.push(replacement);\n    }\n    findById(chipId) {\n        return this._items.get(chipId) || null;\n    }\n    getItems() {\n        return Array.from(this._items.values());\n    }\n    async waitWhileLoading() {\n        await Promise.all(Array.from(this._items.values()).map(item => item.waitWhileLoading()));\n    }\n    toObject() {\n        const objectedMapChipImage = [];\n        const valuesItr = this._items.values();\n        for (const val of valuesItr) {\n            objectedMapChipImage.push(val.toObject());\n        }\n        return {\n            items: objectedMapChipImage\n        };\n    }\n    fromObject(val) {\n        this._items.clear();\n        val.items.forEach(objectedVal => {\n            this.push(MapChipImage.fromObject(objectedVal));\n        });\n    }\n}\n//# sourceMappingURL=MapChipsCollection.js.map","/**\n * @license\n * Copyright 2021 piyoppi\n * SPDX-License-Identifier: MIT\n */\nimport { MapMatrix } from './MapMatrix';\nexport class ColiderMap extends MapMatrix {\n    toObject() {\n        return {\n            chipCountX: this._chipCountX,\n            chipCountY: this._chipCountY,\n            coliders: this._items\n        };\n    }\n    static fromObject(val) {\n        return new ColiderMap(val.chipCountX, val.chipCountY, val.coliders);\n    }\n    allocate() {\n        super.allocate(0);\n    }\n}\n//# sourceMappingURL=ColiderMap.js.map","/**\n * @license\n * Copyright 2021 piyoppi\n * SPDX-License-Identifier: MIT\n */\nimport { transferEach } from './TransferEach';\nexport class MapMatrix {\n    constructor(_chipCountX, _chipCountY, items = []) {\n        this._chipCountX = _chipCountX;\n        this._chipCountY = _chipCountY;\n        this._items = [];\n        if (items.length > 0 && this.size !== items.length) {\n            throw new Error();\n        }\n        if (items.length === 0) {\n            this.allocate();\n        }\n        else {\n            this._items = items;\n        }\n    }\n    get size() {\n        return this._chipCountX * this._chipCountY;\n    }\n    get width() {\n        return this._chipCountX;\n    }\n    get height() {\n        return this._chipCountY;\n    }\n    get items() {\n        return this._items;\n    }\n    set(items) {\n        if (items.length !== this._items.length)\n            throw new Error();\n        this._items = items;\n    }\n    transferFromTiledMapData(src, srcX, srcY, width, height, destX, destY) {\n        transferEach(srcX, srcY, width, height, destX, destY, src.width, src.height, this.width, this.height, (pickupX, pickupY, putX, putY) => {\n            const item = src.getFromChipPosition(pickupX, pickupY);\n            this.put(item, putX, putY);\n        });\n    }\n    resize(chipCountX, chipCountY, emptyValue) {\n        const src = this.clone();\n        this._chipCountX = chipCountX;\n        this._chipCountY = chipCountY;\n        this.allocate(emptyValue);\n        this.transferFromTiledMapData(src, 0, 0, src.width, src.height, 0, 0);\n    }\n    getFromChipPosition(x, y) {\n        if (this.isOutOfRange(x, y))\n            throw new Error('The position is out of range.');\n        const mapNumber = this.convertPositionToMapNumber(x, y);\n        return this._items[mapNumber];\n    }\n    put(item, x, y) {\n        const mapNumber = this.convertPositionToMapNumber(x, y);\n        this._items[mapNumber] = item;\n    }\n    clone() {\n        return new MapMatrix(this._chipCountX, this._chipCountY, this._items);\n    }\n    convertPositionToMapNumber(x, y) {\n        return y * this._chipCountX + x;\n    }\n    isOutOfRange(x, y) {\n        return (x < 0) || (y < 0) || (x >= this._chipCountX) || (y >= this._chipCountY);\n    }\n    allocate(defaultValue = null) {\n        this._items = new Array(this._chipCountY * this._chipCountX).fill(defaultValue);\n    }\n}\n//# sourceMappingURL=MapMatrix.js.map","/**\n * @license\n * Copyright 2021 piyoppi\n * SPDX-License-Identifier: MIT\n */\nimport { transferEach } from './TransferEach';\nimport { MapMatrix } from './MapMatrix';\nexport class MapPaletteMatrix {\n    constructor(chipCountX, chipCountY, items = []) {\n        this._paletteIndexes = new Map();\n        this._values = new MapMatrix(0, 0, []);\n        this._palette = [];\n        this._values = new MapMatrix(chipCountX, chipCountY, new Array(chipCountY * chipCountX).fill(-1));\n        if (items.length > 0) {\n            this.set(items);\n        }\n    }\n    get size() {\n        return this._values.size;\n    }\n    get width() {\n        return this._values.width;\n    }\n    get height() {\n        return this._values.height;\n    }\n    get items() {\n        return this._values.items.map(value => value >= 0 ? this._palette[value] : null);\n    }\n    get palette() {\n        return this._palette;\n    }\n    get values() {\n        return this._values;\n    }\n    set(items) {\n        if (items.length !== this._values.items.length)\n            throw new Error();\n        this._values.set(items.map(value => this._getOrGeneratePaletteIndex(value)));\n    }\n    setValuePalette(values, palette) {\n        if (values.length !== this._values.items.length)\n            throw new Error();\n        this._values.set([...values]);\n        this._palette = [...palette];\n        this._paletteIndexes.clear();\n        for (const [index, paletteItem] of this._palette.entries()) {\n            if (!paletteItem)\n                continue;\n            if (this._paletteIndexes.has(paletteItem.identifyKey)) {\n                this.rebuild();\n                break;\n            }\n            this._paletteIndexes.set(paletteItem.identifyKey, index);\n        }\n    }\n    transferFromTiledMapData(src, srcX, srcY, width, height, destX, destY) {\n        transferEach(srcX, srcY, width, height, destX, destY, src.width, src.height, this.width, this.height, (pickupX, pickupY, putX, putY) => {\n            const item = src.getFromChipPosition(pickupX, pickupY);\n            this._values.put(this._getOrGeneratePaletteIndex(item), putX, putY);\n        });\n    }\n    resize(chipCountX, chipCountY, emptyValue) {\n        this._values.resize(chipCountX, chipCountY, this._getOrGeneratePaletteIndex(emptyValue));\n    }\n    getFromChipPosition(x, y) {\n        const paletteIndex = this._values.getFromChipPosition(x, y);\n        return paletteIndex >= 0 ? this._palette[paletteIndex] : null;\n    }\n    put(item, x, y) {\n        this._values.put(this._getOrGeneratePaletteIndex(item), x, y);\n    }\n    clone() {\n        const cloned = new MapPaletteMatrix(this.width, this.height);\n        cloned.setValuePalette(this._values.items, this._palette);\n        return cloned;\n    }\n    rebuild() {\n        const items = this.items;\n        this._palette = [];\n        this._paletteIndexes.clear();\n        this.set(items);\n    }\n    remove(target) {\n        if (!target)\n            return false;\n        const removePaletteId = this.palette.findIndex(item => (item === null || item === void 0 ? void 0 : item.identifyKey) === target.identifyKey);\n        if (removePaletteId < 0)\n            return false;\n        this.palette.splice(removePaletteId, 1);\n        this.values.items.forEach((paletteIndex, valueIndex) => {\n            if (paletteIndex === removePaletteId)\n                this.values.items[valueIndex] = -1;\n            if (paletteIndex > removePaletteId)\n                this.values.items[valueIndex] = this.values.items[valueIndex] - 1;\n        });\n        for (const [k, v] of this._paletteIndexes.entries()) {\n            if (v > removePaletteId)\n                this._paletteIndexes.set(k, v - 1);\n        }\n        this._paletteIndexes.delete(target.identifyKey);\n        return true;\n    }\n    getPaletteIndex(value) {\n        if (value === null)\n            return -1;\n        return this._paletteIndexes.get(value.identifyKey);\n    }\n    _getOrGeneratePaletteIndex(value) {\n        if (value === null)\n            return -1;\n        const index = this.getPaletteIndex(value);\n        if (index !== undefined)\n            return index;\n        this._palette.push(value);\n        const addedIndex = this._palette.length - 1;\n        this._paletteIndexes.set(value.identifyKey, addedIndex);\n        return addedIndex;\n    }\n}\n//# sourceMappingURL=MapPaletteMatrix.js.map","/**\n * @license\n * Copyright 2021 piyoppi\n * SPDX-License-Identifier: MIT\n */\nimport { MapChip, isAutoTileMapChipProperties, AutoTileMapChip } from './../MapChip';\nimport { MapPaletteMatrix } from './MapPaletteMatrix';\nexport class TiledMapData extends MapPaletteMatrix {\n    filter(needles) {\n        const filtered = this.items.map(chip => needles.some(needle => !!chip && needle.compare(chip)) ? chip : null);\n        return new TiledMapData(this.width, this.height, filtered);\n    }\n    findByImage(image) {\n        const registeredChips = new Set();\n        return this.items.filter(chip => {\n            if (!chip)\n                return false;\n            const found = chip.items.find(fragment => fragment.chipId === image.id) && !registeredChips.has(chip.identifyKey);\n            if (found) {\n                registeredChips.add(chip.identifyKey);\n            }\n            return found;\n        });\n    }\n    toObject() {\n        return {\n            chipCountX: this.width,\n            chipCountY: this.height,\n            values: this.values.items,\n            palette: this.palette.map(data => data ? data.toObject() : null)\n        };\n    }\n    static fromObject(val) {\n        const palette = val.palette.map(data => {\n            if (!data)\n                return null;\n            if (isAutoTileMapChipProperties(data)) {\n                return AutoTileMapChip.fromObject(data);\n            }\n            return MapChip.fromObject(data);\n        });\n        const tiledMapData = new TiledMapData(val.chipCountX, val.chipCountY, []);\n        tiledMapData.setValuePalette(val.values, palette);\n        return tiledMapData;\n    }\n}\n//# sourceMappingURL=TiledMapData.js.map","/**\n * @license\n * Copyright 2021 piyoppi\n * SPDX-License-Identifier: MIT\n */\nexport function transferEach(srcX, srcY, width, height, destX, destY, srcWidth, srcHeight, destWidth, destHeight, callback) {\n    for (let x = 0; x < width; x++) {\n        const putX = destX + x;\n        const pickupX = srcX + x;\n        if (putX < 0 || putX >= destWidth)\n            continue;\n        if (pickupX < 0 || pickupX >= srcWidth)\n            continue;\n        for (let y = 0; y < height; y++) {\n            const putY = destY + y;\n            const pickupY = srcY + y;\n            if (putY < 0 || putY >= destHeight)\n                continue;\n            if (pickupY < 0 || pickupY >= srcHeight)\n                continue;\n            callback(pickupX, pickupY, putX, putY);\n        }\n    }\n}\n//# sourceMappingURL=TransferEach.js.map","/**\n * @license\n * Copyright 2021 piyoppi\n * SPDX-License-Identifier: MIT\n */\nexport class MapRenderer {\n    constructor(_tiledMap) {\n        this._tiledMap = _tiledMap;\n        this._backgroundRgba = { r: 255, g: 255, b: 255, a: 1.0 };\n    }\n    setTiledMap(tiledMap) {\n        this._tiledMap = tiledMap;\n    }\n    renderAll(ctx) {\n        this._tiledMap.datas.forEach(data => this.render(data, ctx));\n    }\n    renderLayer(index, ctx) {\n        this.render(this._tiledMap.datas[index], ctx);\n    }\n    render(data, ctx) {\n        data.items.forEach((value, index) => {\n            const position = this._tiledMap.convertMapNumberToPosition(index);\n            this.putOrClearChipToCanvas(ctx, value, position.x, position.y);\n        });\n    }\n    putOrClearChipToCanvas(ctx, mapChip, chipX, chipY, isTemporaryRendering = false) {\n        if (!mapChip) {\n            this._clearChipToCanvas(ctx, chipX, chipY, isTemporaryRendering);\n        }\n        else {\n            mapChip.items.forEach(item => {\n                this._putChipToCanvas(ctx, item, chipX, chipY);\n            });\n        }\n    }\n    _clearChipToCanvas(ctx, chipX, chipY, isTemporaryRendering) {\n        const position = this._tiledMap.convertChipPositionToPixel(chipX, chipY);\n        ctx.clearRect(position.x, position.y, this._tiledMap.chipWidth, this._tiledMap.chipHeight);\n        if (isTemporaryRendering) {\n            ctx.fillStyle = `rgba(${this._backgroundRgba.r},${this._backgroundRgba.g},${this._backgroundRgba.b},${this._backgroundRgba.a})`;\n            ctx.fillRect(position.x, position.y, this._tiledMap.chipWidth, this._tiledMap.chipHeight);\n        }\n    }\n    _putChipToCanvas(ctx, mapChip, chipX, chipY) {\n        const mapChips = this._tiledMap.mapChipsCollection.findById(mapChip.chipId);\n        const image = mapChips === null || mapChips === void 0 ? void 0 : mapChips.image;\n        if (!image)\n            return;\n        const renderingArea = this._getRenderingArea(mapChip);\n        const position = this._tiledMap.convertChipPositionToPixel(chipX, chipY);\n        position.x += renderingArea.destOffsetX;\n        position.y += renderingArea.destOffsetY;\n        ctx.clearRect(position.x, position.y, renderingArea.width, renderingArea.height);\n        ctx.drawImage(image, renderingArea.x, renderingArea.y, renderingArea.width, renderingArea.height, position.x, position.y, renderingArea.width, renderingArea.height);\n    }\n    _getRenderingArea(mapChip) {\n        const width = this._tiledMap.chipWidth;\n        const height = this._tiledMap.chipHeight;\n        const x = mapChip.x * width;\n        const y = mapChip.y * height;\n        if (mapChip.renderingArea === 15) {\n            return { x, y, width, height, destOffsetX: 0, destOffsetY: 0 };\n        }\n        const halfWidth = Math.round(width / 2);\n        const halfHeight = Math.round(height / 2);\n        switch (mapChip.renderingArea) {\n            case 1:\n                return { x, y, width: halfWidth, height: halfHeight, destOffsetX: 0, destOffsetY: 0 };\n            case 2:\n                return { x: x + halfWidth, y, width: halfWidth, height: halfHeight, destOffsetX: halfWidth, destOffsetY: 0 };\n            case 3:\n                return { x, y, width, height: halfHeight, destOffsetX: 0, destOffsetY: 0 };\n            case 4:\n                return { x, y: y + halfHeight, width: halfWidth, height: halfHeight, destOffsetX: 0, destOffsetY: halfHeight };\n            case 5:\n                return { x, y, width: halfWidth, height, destOffsetX: 0, destOffsetY: 0 };\n            case 8:\n                return { x: x + halfWidth, y: y + halfHeight, width: halfWidth, height: halfHeight, destOffsetX: halfWidth, destOffsetY: halfHeight };\n            case 10:\n                return { x: x + halfWidth, y, width: halfWidth, height, destOffsetX: halfWidth, destOffsetY: 0 };\n            case 12:\n                return { x, y: y + halfHeight, width, height: halfHeight, destOffsetX: 0, destOffsetY: halfHeight };\n        }\n    }\n}\n//# sourceMappingURL=MapRenderer.js.map","/**\n * @license\n * Copyright 2021 piyoppi\n * SPDX-License-Identifier: MIT\n */\nimport { MapChipsCollection } from './MapChipsCollection';\nimport { AutoTiles } from './AutoTile/AutoTiles';\nimport { TiledMapData } from './MapData/TiledMapData';\nimport { ColiderMap } from './MapData/ColiderMap';\nexport class TiledMap {\n    constructor(_chipCountX, _chipCountY, _chipWidth, _chipHeight) {\n        this._chipCountX = _chipCountX;\n        this._chipCountY = _chipCountY;\n        this._chipWidth = _chipWidth;\n        this._chipHeight = _chipHeight;\n        this._mapChipImages = new MapChipsCollection();\n        this._autoTiles = new AutoTiles();\n        this._datas = [];\n        this._coliders = new ColiderMap(this._chipCountX, this._chipCountY);\n        this.addLayer();\n    }\n    get chipWidth() {\n        return this._chipWidth;\n    }\n    get chipHeight() {\n        return this._chipHeight;\n    }\n    get chipCountX() {\n        return this._chipCountX;\n    }\n    get chipCountY() {\n        return this._chipCountY;\n    }\n    get mapChipsCollection() {\n        return this._mapChipImages;\n    }\n    get autoTiles() {\n        return this._autoTiles;\n    }\n    get datas() {\n        return this._datas;\n    }\n    get coliders() {\n        return this._coliders;\n    }\n    convertChipPositionToPixel(chipX, chipY) {\n        return {\n            x: chipX * this.chipWidth,\n            y: chipY * this.chipHeight\n        };\n    }\n    put(mapChip, chipX, chipY, index) {\n        this._datas[index].put(mapChip, chipX, chipY);\n    }\n    toObject() {\n        return {\n            chipCountX: this._chipCountX,\n            chipCountY: this._chipCountY,\n            chipWidth: this._chipWidth,\n            chipHeight: this._chipHeight,\n            mapChipImages: this._mapChipImages.toObject(),\n            autoTiles: this._autoTiles.toObject(),\n            tiledMapDatas: this._datas.map(data => data.toObject()),\n            coliders: this._coliders.toObject()\n        };\n    }\n    addLayer() {\n        this._datas.push(new TiledMapData(this._chipCountX, this._chipCountY));\n    }\n    convertMapNumberToPosition(num) {\n        return {\n            x: num % this._chipCountX,\n            y: Math.floor(num / this._chipCountX)\n        };\n    }\n    resize(chipCountX, chipCountY) {\n        this._chipCountX = chipCountX;\n        this._chipCountY = chipCountY;\n        this._datas.forEach(item => item.resize(chipCountX, chipCountY, null));\n        this._coliders.resize(chipCountX, chipCountY, 0);\n    }\n    setSerializedProperties(val) {\n        this._mapChipImages.fromObject(val.mapChipImages);\n        this._autoTiles.fromObject(val.autoTiles);\n        this._datas = val.tiledMapDatas.map(tiledMapData => TiledMapData.fromObject(tiledMapData));\n        this._coliders = ColiderMap.fromObject(val.coliders);\n    }\n    static fromObject(val) {\n        const tiledMap = new TiledMap(val.chipCountX, val.chipCountY, val.chipWidth, val.chipHeight);\n        tiledMap.setSerializedProperties({ mapChipImages: val.mapChipImages, autoTiles: val.autoTiles, tiledMapDatas: val.tiledMapDatas, coliders: val.coliders });\n        return tiledMap;\n    }\n}\n//# sourceMappingURL=TiledMap.js.map","/**\n * @license\n * Copyright 2021 piyoppi\n * SPDX-License-Identifier: MIT\n */\nexport { TiledMap } from './TiledMap';\nexport { TiledMapData } from './MapData/TiledMapData';\nexport { MapChipImage } from './MapChipImage';\nexport { MapChipsCollection } from './MapChipsCollection';\nexport { MapChipFragment, MapChip, AutoTileMapChip, isAutoTileMapChip } from './MapChip';\nexport { AutoTiles } from './AutoTile/AutoTiles';\nexport { AutoTile } from './AutoTile/AutoTile';\nexport { DefaultAutoTileImportStrategy } from './AutoTile/DefaultAutoTileImportStrategy';\nexport { ColiderMap } from './MapData/ColiderMap';\nexport { MapRenderer } from './MapRenderer';\n//# sourceMappingURL=main.js.map","/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n/**\n * Whether the current browser supports `adoptedStyleSheets`.\n */\nexport const supportsAdoptingStyleSheets = window.ShadowRoot &&\n    (window.ShadyCSS === undefined || window.ShadyCSS.nativeShadow) &&\n    'adoptedStyleSheets' in Document.prototype &&\n    'replace' in CSSStyleSheet.prototype;\nconst constructionToken = Symbol();\nexport class CSSResult {\n    constructor(cssText, safeToken) {\n        if (safeToken !== constructionToken) {\n            throw new Error('CSSResult is not constructable. Use `unsafeCSS` or `css` instead.');\n        }\n        this.cssText = cssText;\n    }\n    // Note, this is a getter so that it's lazy. In practice, this means\n    // stylesheets are not created until the first element instance is made.\n    get styleSheet() {\n        // Note, if `supportsAdoptingStyleSheets` is true then we assume\n        // CSSStyleSheet is constructable.\n        if (supportsAdoptingStyleSheets && this._styleSheet === undefined) {\n            this._styleSheet = new CSSStyleSheet();\n            this._styleSheet.replaceSync(this.cssText);\n        }\n        return this._styleSheet;\n    }\n    toString() {\n        return this.cssText;\n    }\n}\nconst cssResultCache = new Map();\nconst getCSSResult = (cssText) => {\n    let result = cssResultCache.get(cssText);\n    if (result === undefined) {\n        cssResultCache.set(cssText, (result = new CSSResult(cssText, constructionToken)));\n    }\n    return result;\n};\nconst textFromCSSResult = (value) => {\n    if (value instanceof CSSResult) {\n        return value.cssText;\n    }\n    else if (typeof value === 'number') {\n        return value;\n    }\n    else {\n        throw new Error(`Value passed to 'css' function must be a 'css' function result: ` +\n            `${value}. Use 'unsafeCSS' to pass non-literal values, but take care ` +\n            `to ensure page security.`);\n    }\n};\n/**\n * Wrap a value for interpolation in a [[`css`]] tagged template literal.\n *\n * This is unsafe because untrusted CSS text can be used to phone home\n * or exfiltrate data to an attacker controlled site. Take care to only use\n * this with trusted input.\n */\nexport const unsafeCSS = (value) => {\n    return getCSSResult(typeof value === 'string' ? value : String(value));\n};\n/**\n * Template tag which which can be used with LitElement's [[LitElement.styles |\n * `styles`]] property to set element styles. For security reasons, only literal\n * string values may be used. To incorporate non-literal values [[`unsafeCSS`]]\n * may be used inside a template string part.\n */\nexport const css = (strings, ...values) => {\n    const cssText = strings.length === 1\n        ? strings[0]\n        : values.reduce((acc, v, idx) => acc + textFromCSSResult(v) + strings[idx + 1], strings[0]);\n    return getCSSResult(cssText);\n};\n/**\n * Applies the given styles to a `shadowRoot`. When Shadow DOM is\n * available but `adoptedStyleSheets` is not, styles are appended to the\n * `shadowRoot` to [mimic spec behavior](https://wicg.github.io/construct-stylesheets/#using-constructed-stylesheets).\n * Note, when shimming is used, any styles that are subsequently placed into\n * the shadowRoot should be placed *before* any shimmed adopted styles. This\n * will match spec behavior that gives adopted sheets precedence over styles in\n * shadowRoot.\n */\nexport const adoptStyles = (renderRoot, styles) => {\n    if (supportsAdoptingStyleSheets) {\n        renderRoot.adoptedStyleSheets = styles.map((s) => s instanceof CSSStyleSheet ? s : s.styleSheet);\n    }\n    else {\n        styles.forEach((s) => {\n            const style = document.createElement('style');\n            style.textContent = s.cssText;\n            renderRoot.appendChild(style);\n        });\n    }\n};\nconst cssResultFromStyleSheet = (sheet) => {\n    let cssText = '';\n    for (const rule of sheet.cssRules) {\n        cssText += rule.cssText;\n    }\n    return unsafeCSS(cssText);\n};\nexport const getCompatibleStyle = supportsAdoptingStyleSheets\n    ? (s) => s\n    : (s) => s instanceof CSSStyleSheet ? cssResultFromStyleSheet(s) : s;\n//# sourceMappingURL=css-tag.js.map","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nexport const legacyPrototypeMethod = (descriptor, proto, name) => {\n    Object.defineProperty(proto, name, descriptor);\n};\nexport const standardPrototypeMethod = (descriptor, element) => ({\n    kind: 'method',\n    placement: 'prototype',\n    key: element.key,\n    descriptor,\n});\n/**\n * Helper for decorating a property that is compatible with both TypeScript\n * and Babel decorators. The optional `finisher` can be used to perform work on\n * the class. The optional `descriptor` should return a PropertyDescriptor\n * to install for the given property.\n *\n * @param finisher {function} Optional finisher method; receives the element\n * constructor and property key as arguments and has no return value.\n * @param descriptor {function} Optional descriptor method; receives the\n * property key as an argument and returns a property descriptor to define for\n * the given property.\n * @returns {ClassElement|void}\n */\nexport const decorateProperty = ({ finisher, descriptor, }) => (protoOrDescriptor, name\n// Note TypeScript requires the return type to be `void|any`\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n) => {\n    var _a;\n    // TypeScript / Babel legacy mode\n    if (name !== undefined) {\n        const ctor = protoOrDescriptor\n            .constructor;\n        if (descriptor !== undefined) {\n            Object.defineProperty(protoOrDescriptor, name, descriptor(name));\n        }\n        finisher === null || finisher === void 0 ? void 0 : finisher(ctor, name);\n        // Babel standard mode\n    }\n    else {\n        // Note, the @property decorator saves `key` as `originalKey`\n        // so try to use it here.\n        const key = (_a = \n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        protoOrDescriptor.originalKey) !== null && _a !== void 0 ? _a : protoOrDescriptor.key;\n        const info = descriptor != undefined\n            ? {\n                kind: 'method',\n                placement: 'prototype',\n                key,\n                descriptor: descriptor(protoOrDescriptor.key),\n            }\n            : { ...protoOrDescriptor, key };\n        if (finisher != undefined) {\n            info.finisher = function (ctor) {\n                finisher(ctor, key);\n            };\n        }\n        return info;\n    }\n};\n//# sourceMappingURL=base.js.map","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nconst legacyCustomElement = (tagName, clazz) => {\n    window.customElements.define(tagName, clazz);\n    // Cast as any because TS doesn't recognize the return type as being a\n    // subtype of the decorated class when clazz is typed as\n    // `Constructor<HTMLElement>` for some reason.\n    // `Constructor<HTMLElement>` is helpful to make sure the decorator is\n    // applied to elements however.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return clazz;\n};\nconst standardCustomElement = (tagName, descriptor) => {\n    const { kind, elements } = descriptor;\n    return {\n        kind,\n        elements,\n        // This callback is called once the class is otherwise fully defined\n        finisher(clazz) {\n            window.customElements.define(tagName, clazz);\n        },\n    };\n};\n/**\n * Class decorator factory that defines the decorated class as a custom element.\n *\n * ```\n * @customElement('my-element')\n * class MyElement extends LitElement {\n *   render() {\n *     return html``;\n *   }\n * }\n * ```\n * @category Decorator\n * @param tagName The tag name of the custom element to define.\n */\nexport const customElement = (tagName) => (classOrDescriptor) => typeof classOrDescriptor === 'function'\n    ? legacyCustomElement(tagName, classOrDescriptor)\n    : standardCustomElement(tagName, classOrDescriptor);\n//# sourceMappingURL=custom-element.js.map","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { decorateProperty } from './base.js';\n/**\n * Adds event listener options to a method used as an event listener in a\n * lit-html template.\n *\n * @param options An object that specifies event listener options as accepted by\n * `EventTarget#addEventListener` and `EventTarget#removeEventListener`.\n *\n * Current browsers support the `capture`, `passive`, and `once` options. See:\n * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters\n *\n * @example\n * ```ts\n * class MyElement {\n *   clicked = false;\n *\n *   render() {\n *     return html`\n *       <div @click=${this._onClick}`>\n *         <button></button>\n *       </div>\n *     `;\n *   }\n *\n *   @eventOptions({capture: true})\n *   _onClick(e) {\n *     this.clicked = true;\n *   }\n * }\n * ```\n * @category Decorator\n */\nexport function eventOptions(options) {\n    return decorateProperty({\n        finisher: (ctor, name) => {\n            Object.assign(ctor.prototype[name], options);\n        },\n    });\n}\n//# sourceMappingURL=event-options.js.map","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nconst standardProperty = (options, element) => {\n    // When decorating an accessor, pass it through and add property metadata.\n    // Note, the `hasOwnProperty` check in `createProperty` ensures we don't\n    // stomp over the user's accessor.\n    if (element.kind === 'method' &&\n        element.descriptor &&\n        !('value' in element.descriptor)) {\n        return {\n            ...element,\n            finisher(clazz) {\n                clazz.createProperty(element.key, options);\n            },\n        };\n    }\n    else {\n        // createProperty() takes care of defining the property, but we still\n        // must return some kind of descriptor, so return a descriptor for an\n        // unused prototype field. The finisher calls createProperty().\n        return {\n            kind: 'field',\n            key: Symbol(),\n            placement: 'own',\n            descriptor: {},\n            // store the original key so subsequent decorators have access to it.\n            originalKey: element.key,\n            // When @babel/plugin-proposal-decorators implements initializers,\n            // do this instead of the initializer below. See:\n            // https://github.com/babel/babel/issues/9260 extras: [\n            //   {\n            //     kind: 'initializer',\n            //     placement: 'own',\n            //     initializer: descriptor.initializer,\n            //   }\n            // ],\n            initializer() {\n                if (typeof element.initializer === 'function') {\n                    this[element.key] = element.initializer.call(this);\n                }\n            },\n            finisher(clazz) {\n                clazz.createProperty(element.key, options);\n            },\n        };\n    }\n};\nconst legacyProperty = (options, proto, name) => {\n    proto.constructor.createProperty(name, options);\n};\n/**\n * A property decorator which creates a reactive property that reflects a\n * corresponding attribute value. When a decorated property is set\n * the element will update and render. A [[`PropertyDeclaration`]] may\n * optionally be supplied to configure property features.\n *\n * This decorator should only be used for public fields. As public fields,\n * properties should be considered as primarily settable by element users,\n * either via attribute or the property itself.\n *\n * Generally, properties that are changed by the element should be private or\n * protected fields and should use the [[`state`]] decorator.\n *\n * However, sometimes element code does need to set a public property. This\n * should typically only be done in response to user interaction, and an event\n * should be fired informing the user; for example, a checkbox sets its\n * `checked` property when clicked and fires a `changed` event. Mutating public\n * properties should typically not be done for non-primitive (object or array)\n * properties. In other cases when an element needs to manage state, a private\n * property decorated via the [[`state`]] decorator should be used. When needed,\n * state properties can be initialized via public properties to facilitate\n * complex interactions.\n *\n * @example\n * ```ts\n * class MyElement {\n *   @property({ type: Boolean })\n *   clicked = false;\n * }\n * ```\n * @category Decorator\n * @ExportDecoratedItems\n */\nexport function property(options) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return (protoOrDescriptor, name) => name !== undefined\n        ? legacyProperty(options, protoOrDescriptor, name)\n        : standardProperty(options, protoOrDescriptor);\n}\n//# sourceMappingURL=property.js.map","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { decorateProperty } from './base.js';\n/**\n * A property decorator that converts a class property into a getter\n * that executes a querySelectorAll on the element's renderRoot.\n *\n * @param selector A DOMString containing one or more selectors to match.\n *\n * See:\n * https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll\n *\n * @example\n * ```ts\n * class MyElement {\n *   @queryAll('div')\n *   divs;\n *\n *   render() {\n *     return html`\n *       <div id=\"first\"></div>\n *       <div id=\"second\"></div>\n *     `;\n *   }\n * }\n * ```\n * @category Decorator\n */\nexport function queryAll(selector) {\n    return decorateProperty({\n        descriptor: (_name) => ({\n            get() {\n                var _a;\n                return (_a = this.renderRoot) === null || _a === void 0 ? void 0 : _a.querySelectorAll(selector);\n            },\n            enumerable: true,\n            configurable: true,\n        }),\n    });\n}\n//# sourceMappingURL=query-all.js.map","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { decorateProperty } from './base.js';\n// TODO(sorvell): Remove when https://github.com/webcomponents/polyfills/issues/397 is addressed.\n// x-browser support for matches\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst ElementProto = Element.prototype;\nconst legacyMatches = ElementProto.msMatchesSelector || ElementProto.webkitMatchesSelector;\n/**\n * A property decorator that converts a class property into a getter that\n * returns the `assignedNodes` of the given named `slot`. Note, the type of\n * this property should be annotated as `NodeListOf<HTMLElement>`.\n *\n * @param slotName A string name of the slot.\n * @param flatten A boolean which when true flattens the assigned nodes,\n *     meaning any assigned nodes that are slot elements are replaced with their\n *     assigned nodes.\n * @param selector A string which filters the results to elements that match\n *     the given css selector.\n *\n * * @example\n * ```ts\n * class MyElement {\n *   @queryAssignedNodes('list', true, '.item')\n *   listItems;\n *\n *   render() {\n *     return html`\n *       <slot name=\"list\"></slot>\n *     `;\n *   }\n * }\n * ```\n * @category Decorator\n */\nexport function queryAssignedNodes(slotName = '', flatten = false, selector = '') {\n    return decorateProperty({\n        descriptor: (_name) => ({\n            get() {\n                var _a, _b;\n                const slotSelector = `slot${slotName ? `[name=${slotName}]` : ':not([name])'}`;\n                const slot = (_a = this.renderRoot) === null || _a === void 0 ? void 0 : _a.querySelector(slotSelector);\n                let nodes = (_b = slot) === null || _b === void 0 ? void 0 : _b.assignedNodes({ flatten });\n                if (nodes && selector) {\n                    nodes = nodes.filter((node) => node.nodeType === Node.ELEMENT_NODE &&\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        (node.matches\n                            ? node.matches(selector)\n                            : legacyMatches.call(node, selector)));\n                }\n                return nodes;\n            },\n            enumerable: true,\n            configurable: true,\n        }),\n    });\n}\n//# sourceMappingURL=query-assigned-nodes.js.map","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { decorateProperty } from './base.js';\n// Note, in the future, we may extend this decorator to support the use case\n// where the queried element may need to do work to become ready to interact\n// with (e.g. load some implementation code). If so, we might elect to\n// add a second argument defining a function that can be run to make the\n// queried element loaded/updated/ready.\n/**\n * A property decorator that converts a class property into a getter that\n * returns a promise that resolves to the result of a querySelector on the\n * element's renderRoot done after the element's `updateComplete` promise\n * resolves. When the queried property may change with element state, this\n * decorator can be used instead of requiring users to await the\n * `updateComplete` before accessing the property.\n *\n * @param selector A DOMString containing one or more selectors to match.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector\n *\n * @example\n * ```ts\n * class MyElement {\n *   @queryAsync('#first')\n *   first;\n *\n *   render() {\n *     return html`\n *       <div id=\"first\"></div>\n *       <div id=\"second\"></div>\n *     `;\n *   }\n * }\n *\n * // external usage\n * async doSomethingWithFirst() {\n *  (await aMyElement.first).doSomething();\n * }\n * ```\n * @category Decorator\n */\nexport function queryAsync(selector) {\n    return decorateProperty({\n        descriptor: (_name) => ({\n            async get() {\n                var _a;\n                await this.updateComplete;\n                return (_a = this.renderRoot) === null || _a === void 0 ? void 0 : _a.querySelector(selector);\n            },\n            enumerable: true,\n            configurable: true,\n        }),\n    });\n}\n//# sourceMappingURL=query-async.js.map","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { decorateProperty } from './base.js';\n/**\n * A property decorator that converts a class property into a getter that\n * executes a querySelector on the element's renderRoot.\n *\n * @param selector A DOMString containing one or more selectors to match.\n * @param cache An optional boolean which when true performs the DOM query only\n *     once and caches the result.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector\n *\n * @example\n *\n * ```ts\n * class MyElement {\n *   @query('#first')\n *   first;\n *\n *   render() {\n *     return html`\n *       <div id=\"first\"></div>\n *       <div id=\"second\"></div>\n *     `;\n *   }\n * }\n * ```\n * @category Decorator\n */\nexport function query(selector, cache) {\n    return decorateProperty({\n        descriptor: (name) => {\n            const descriptor = {\n                get() {\n                    var _a;\n                    return (_a = this.renderRoot) === null || _a === void 0 ? void 0 : _a.querySelector(selector);\n                },\n                enumerable: true,\n                configurable: true,\n            };\n            if (cache) {\n                const key = typeof name === 'symbol' ? Symbol() : `__${name}`;\n                descriptor.get = function () {\n                    var _a;\n                    if (this[key] === undefined) {\n                        this[key] = (_a = this.renderRoot) === null || _a === void 0 ? void 0 : _a.querySelector(selector);\n                    }\n                    return this[key];\n                };\n            }\n            return descriptor;\n        },\n    });\n}\n//# sourceMappingURL=query.js.map","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n/*\n * IMPORTANT: For compatibility with tsickle and the Closure JS compiler, all\n * property decorators (but not class decorators) in this file that have\n * an @ExportDecoratedItems annotation must be defined as a regular function,\n * not an arrow function.\n */\nimport { property } from './property.js';\n/**\n * Declares a private or protected reactive property that still triggers\n * updates to the element when it changes. It does not reflect from the\n * corresponding attribute.\n *\n * Properties declared this way must not be used from HTML or HTML templating\n * systems, they're solely for properties internal to the element. These\n * properties may be renamed by optimization tools like closure compiler.\n * @category Decorator\n */\nexport function state(options) {\n    return property({\n        ...options,\n        state: true,\n        attribute: false,\n    });\n}\n//# sourceMappingURL=state.js.map","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nvar _a, _b, _c, _d;\nvar _e;\nvar _f;\n/**\n * Use this module if you want to create your own base class extending\n * [[ReactiveElement]].\n * @packageDocumentation\n */\nimport { getCompatibleStyle, adoptStyles, } from './css-tag.js';\nexport * from './css-tag.js';\nconst DEV_MODE = true;\nlet requestUpdateThenable;\nif (DEV_MODE) {\n    // TODO(sorvell): Add a link to the docs about using dev v. production mode.\n    console.warn(`Running in dev mode. Do not use in production!`);\n    // Issue platform support warning.\n    if (((_a = window.ShadyDOM) === null || _a === void 0 ? void 0 : _a.inUse) &&\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        globalThis['reactiveElementPlatformSupport'] === undefined) {\n        console.warn(`Shadow DOM is being polyfilled via ShadyDOM but ` +\n            `the \\`polyfill-support\\` module has not been loaded.`);\n    }\n    requestUpdateThenable = {\n        then: (onfulfilled, _onrejected) => {\n            console.warn(`\\`requestUpdate\\` no longer returns a Promise.` +\n                `Use \\`updateComplete\\` instead.`);\n            if (onfulfilled !== undefined) {\n                onfulfilled(false);\n            }\n        },\n    };\n}\n/*\n * When using Closure Compiler, JSCompiler_renameProperty(property, object) is\n * replaced at compile time by the munged name for object[property]. We cannot\n * alias this function, so we have to use a small shim that has the same\n * behavior when not compiling.\n */\n/*@__INLINE__*/\nconst JSCompiler_renameProperty = (prop, _obj) => prop;\nexport const defaultConverter = {\n    toAttribute(value, type) {\n        switch (type) {\n            case Boolean:\n                value = value ? '' : null;\n                break;\n            case Object:\n            case Array:\n                // if the value is `null` or `undefined` pass this through\n                // to allow removing/no change behavior.\n                value = value == null ? value : JSON.stringify(value);\n                break;\n        }\n        return value;\n    },\n    fromAttribute(value, type) {\n        let fromValue = value;\n        switch (type) {\n            case Boolean:\n                fromValue = value !== null;\n                break;\n            case Number:\n                fromValue = value === null ? null : Number(value);\n                break;\n            case Object:\n            case Array:\n                // Do *not* generate exception when invalid JSON is set as elements\n                // don't normally complain on being mis-configured.\n                // TODO(sorvell): Do generate exception in *dev mode*.\n                try {\n                    // Assert to adhere to Bazel's \"must type assert JSON parse\" rule.\n                    fromValue = JSON.parse(value);\n                }\n                catch (e) {\n                    fromValue = null;\n                }\n                break;\n        }\n        return fromValue;\n    },\n};\n/**\n * Change function that returns true if `value` is different from `oldValue`.\n * This method is used as the default for a property's `hasChanged` function.\n */\nexport const notEqual = (value, old) => {\n    // This ensures (old==NaN, value==NaN) always returns false\n    return old !== value && (old === old || value === value);\n};\nconst defaultPropertyDeclaration = {\n    attribute: true,\n    type: String,\n    converter: defaultConverter,\n    reflect: false,\n    hasChanged: notEqual,\n};\n/**\n * The Closure JS Compiler doesn't currently have good support for static\n * property semantics where \"this\" is dynamic (e.g.\n * https://github.com/google/closure-compiler/issues/3177 and others) so we use\n * this hack to bypass any rewriting by the compiler.\n */\nconst finalized = 'finalized';\n/**\n * Base element class which manages element properties and attributes. When\n * properties change, the `update` method is asynchronously called. This method\n * should be supplied by subclassers to render updates as desired.\n * @noInheritDoc\n */\nexport class ReactiveElement extends HTMLElement {\n    constructor() {\n        super();\n        this.__instanceProperties = new Map();\n        this.__pendingConnectionPromise = undefined;\n        this.__enableConnection = undefined;\n        /**\n         * @category updates\n         */\n        this.isUpdatePending = false;\n        /**\n         * @category updates\n         */\n        this.hasUpdated = false;\n        /**\n         * Name of currently reflecting property\n         */\n        this.__reflectingProperty = null;\n        this._initialize();\n    }\n    /**\n     * @nocollapse\n     */\n    static addInitializer(initializer) {\n        var _a;\n        (_a = this._initializers) !== null && _a !== void 0 ? _a : (this._initializers = []);\n        this._initializers.push(initializer);\n    }\n    /**\n     * Returns a list of attributes corresponding to the registered properties.\n     * @nocollapse\n     * @category attributes\n     */\n    static get observedAttributes() {\n        // note: piggy backing on this to ensure we're finalized.\n        this.finalize();\n        const attributes = [];\n        // Use forEach so this works even if for/of loops are compiled to for loops\n        // expecting arrays\n        this.elementProperties.forEach((v, p) => {\n            const attr = this.__attributeNameForProperty(p, v);\n            if (attr !== undefined) {\n                this.__attributeToPropertyMap.set(attr, p);\n                attributes.push(attr);\n            }\n        });\n        return attributes;\n    }\n    /**\n     * Creates a property accessor on the element prototype if one does not exist\n     * and stores a PropertyDeclaration for the property with the given options.\n     * The property setter calls the property's `hasChanged` property option\n     * or uses a strict identity check to determine whether or not to request\n     * an update.\n     *\n     * This method may be overridden to customize properties; however,\n     * when doing so, it's important to call `super.createProperty` to ensure\n     * the property is setup correctly. This method calls\n     * `getPropertyDescriptor` internally to get a descriptor to install.\n     * To customize what properties do when they are get or set, override\n     * `getPropertyDescriptor`. To customize the options for a property,\n     * implement `createProperty` like this:\n     *\n     * static createProperty(name, options) {\n     *   options = Object.assign(options, {myOption: true});\n     *   super.createProperty(name, options);\n     * }\n     *\n     * @nocollapse\n     * @category properties\n     */\n    static createProperty(name, options = defaultPropertyDeclaration) {\n        // if this is a state property, force the attribute to false.\n        if (options.state) {\n            // Cast as any since this is readonly.\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            options.attribute = false;\n        }\n        // Note, since this can be called by the `@property` decorator which\n        // is called before `finalize`, we ensure finalization has been kicked off.\n        this.finalize();\n        this.elementProperties.set(name, options);\n        // Do not generate an accessor if the prototype already has one, since\n        // it would be lost otherwise and that would never be the user's intention;\n        // Instead, we expect users to call `requestUpdate` themselves from\n        // user-defined accessors. Note that if the super has an accessor we will\n        // still overwrite it\n        if (!options.noAccessor && !this.prototype.hasOwnProperty(name)) {\n            const key = typeof name === 'symbol' ? Symbol() : `__${name}`;\n            const descriptor = this.getPropertyDescriptor(name, key, options);\n            if (descriptor !== undefined) {\n                Object.defineProperty(this.prototype, name, descriptor);\n            }\n        }\n    }\n    /**\n     * Returns a property descriptor to be defined on the given named property.\n     * If no descriptor is returned, the property will not become an accessor.\n     * For example,\n     *\n     *   class MyElement extends LitElement {\n     *     static getPropertyDescriptor(name, key, options) {\n     *       const defaultDescriptor =\n     *           super.getPropertyDescriptor(name, key, options);\n     *       const setter = defaultDescriptor.set;\n     *       return {\n     *         get: defaultDescriptor.get,\n     *         set(value) {\n     *           setter.call(this, value);\n     *           // custom action.\n     *         },\n     *         configurable: true,\n     *         enumerable: true\n     *       }\n     *     }\n     *   }\n     *\n     * @nocollapse\n     * @category properties\n     */\n    static getPropertyDescriptor(name, key, options) {\n        return {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            get() {\n                return this[key];\n            },\n            set(value) {\n                const oldValue = this[name];\n                this[key] = value;\n                this.requestUpdate(name, oldValue, options);\n            },\n            configurable: true,\n            enumerable: true,\n        };\n    }\n    /**\n     * Returns the property options associated with the given property.\n     * These options are defined with a PropertyDeclaration via the `properties`\n     * object or the `@property` decorator and are registered in\n     * `createProperty(...)`.\n     *\n     * Note, this method should be considered \"final\" and not overridden. To\n     * customize the options for a given property, override `createProperty`.\n     *\n     * @nocollapse\n     * @final\n     * @category properties\n     */\n    static getPropertyOptions(name) {\n        return this.elementProperties.get(name) || defaultPropertyDeclaration;\n    }\n    /**\n     * Creates property accessors for registered properties, sets up element\n     * styling, and ensures any superclasses are also finalized. Returns true if\n     * the element was finalized.\n     * @nocollapse\n     */\n    static finalize() {\n        if (this.hasOwnProperty(finalized)) {\n            return false;\n        }\n        this[finalized] = true;\n        // finalize any superclasses\n        const superCtor = Object.getPrototypeOf(this);\n        superCtor.finalize();\n        this.elementProperties = new Map(superCtor.elementProperties);\n        // initialize Map populated in observedAttributes\n        this.__attributeToPropertyMap = new Map();\n        // make any properties\n        // Note, only process \"own\" properties since this element will inherit\n        // any properties defined on the superClass, and finalization ensures\n        // the entire prototype chain is finalized.\n        if (this.hasOwnProperty(JSCompiler_renameProperty('properties', this))) {\n            const props = this.properties;\n            // support symbols in properties (IE11 does not support this)\n            const propKeys = [\n                ...Object.getOwnPropertyNames(props),\n                ...Object.getOwnPropertySymbols(props),\n            ];\n            // This for/of is ok because propKeys is an array\n            for (const p of propKeys) {\n                // note, use of `any` is due to TypeScript lack of support for symbol in\n                // index types\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                this.createProperty(p, props[p]);\n            }\n        }\n        this.elementStyles = this.finalizeStyles(this.styles);\n        // DEV mode warnings\n        if (DEV_MODE) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const warnRemoved = (obj, name) => {\n                if (obj[name] !== undefined) {\n                    console.warn(`\\`${name}\\` is implemented. It ` +\n                        `has been removed from this version of ReactiveElement.` +\n                        ` See the changelog at https://github.com/lit/lit/blob/main/packages/reactive-element/CHANGELOG.md`);\n                }\n            };\n            [`initialize`, `requestUpdateInternal`, `_getUpdateComplete`].forEach((name) => \n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            warnRemoved(this.prototype, name));\n        }\n        return true;\n    }\n    /**\n     * Takes the styles the user supplied via the `static styles` property and\n     * returns the array of styles to apply to the element.\n     * Override this method to integrate into a style management system.\n     *\n     * Styles are deduplicated preserving the _last_ instance in the list. This\n     * is a performance optimization to avoid duplicated styles that can occur\n     * especially when composing via subclassing. The last item is kept to try\n     * to preserve the cascade order with the assumption that it's most important\n     * that last added styles override previous styles.\n     *\n     * @nocollapse\n     * @category styles\n     */\n    static finalizeStyles(styles) {\n        const elementStyles = [];\n        if (Array.isArray(styles)) {\n            // Dedupe the flattened array in reverse order to preserve the last items.\n            // TODO(sorvell): casting to Array<unknown> works around TS error that\n            // appears to come from trying to flatten a type CSSResultArray.\n            const set = new Set(styles.flat(Infinity).reverse());\n            // Then preserve original order by adding the set items in reverse order.\n            for (const s of set) {\n                elementStyles.unshift(getCompatibleStyle(s));\n            }\n        }\n        else if (styles !== undefined) {\n            elementStyles.push(getCompatibleStyle(styles));\n        }\n        return elementStyles;\n    }\n    /**\n     * Returns the property name for the given attribute `name`.\n     * @nocollapse\n     */\n    static __attributeNameForProperty(name, options) {\n        const attribute = options.attribute;\n        return attribute === false\n            ? undefined\n            : typeof attribute === 'string'\n                ? attribute\n                : typeof name === 'string'\n                    ? name.toLowerCase()\n                    : undefined;\n    }\n    /**\n     * Internal only override point for customizing work done when elements\n     * are constructed.\n     *\n     * @internal\n     */\n    _initialize() {\n        var _a;\n        this.__updatePromise = new Promise((res) => (this.enableUpdating = res));\n        this._$changedProperties = new Map();\n        this.__saveInstanceProperties();\n        // ensures first update will be caught by an early access of\n        // `updateComplete`\n        this.requestUpdate();\n        (_a = this.constructor._initializers) === null || _a === void 0 ? void 0 : _a.forEach((i) => i(this));\n    }\n    /**\n     * @category controllers\n     */\n    addController(controller) {\n        var _a, _b;\n        ((_a = this.__controllers) !== null && _a !== void 0 ? _a : (this.__controllers = [])).push(controller);\n        // If a controller is added after the element has been connected,\n        // call hostConnected. Note, re-using existence of `renderRoot` here\n        // (which is set in connectedCallback) to avoid the need to track a\n        // first connected state.\n        if (this.renderRoot !== undefined && this.isConnected) {\n            (_b = controller.hostConnected) === null || _b === void 0 ? void 0 : _b.call(controller);\n        }\n    }\n    /**\n     * @category controllers\n     */\n    removeController(controller) {\n        var _a;\n        // Note, if the indexOf is -1, the >>> will flip the sign which makes the\n        // splice do nothing.\n        (_a = this.__controllers) === null || _a === void 0 ? void 0 : _a.splice(this.__controllers.indexOf(controller) >>> 0, 1);\n    }\n    /**\n     * Fixes any properties set on the instance before upgrade time.\n     * Otherwise these would shadow the accessor and break these properties.\n     * The properties are stored in a Map which is played back after the\n     * constructor runs. Note, on very old versions of Safari (<=9) or Chrome\n     * (<=41), properties created for native platform properties like (`id` or\n     * `name`) may not have default values set in the element constructor. On\n     * these browsers native properties appear on instances and therefore their\n     * default value will overwrite any element default (e.g. if the element sets\n     * this.id = 'id' in the constructor, the 'id' will become '' since this is\n     * the native platform default).\n     */\n    __saveInstanceProperties() {\n        // Use forEach so this works even if for/of loops are compiled to for loops\n        // expecting arrays\n        this.constructor.elementProperties.forEach((_v, p) => {\n            if (this.hasOwnProperty(p)) {\n                this.__instanceProperties.set(p, this[p]);\n                delete this[p];\n            }\n        });\n    }\n    /**\n     * Returns the node into which the element should render and by default\n     * creates and returns an open shadowRoot. Implement to customize where the\n     * element's DOM is rendered. For example, to render into the element's\n     * childNodes, return `this`.\n     *\n     * @return Returns a node into which to render.\n     * @category rendering\n     */\n    createRenderRoot() {\n        var _a;\n        const renderRoot = (_a = this.shadowRoot) !== null && _a !== void 0 ? _a : this.attachShadow(this.constructor.shadowRootOptions);\n        adoptStyles(renderRoot, this.constructor.elementStyles);\n        return renderRoot;\n    }\n    /**\n     * On first connection, creates the element's renderRoot, sets up\n     * element styling, and enables updating.\n     * @category lifecycle\n     */\n    connectedCallback() {\n        var _a;\n        // create renderRoot before first update.\n        if (this.renderRoot === undefined) {\n            this.renderRoot = this.createRenderRoot();\n        }\n        this.enableUpdating(true);\n        (_a = this.__controllers) === null || _a === void 0 ? void 0 : _a.forEach((c) => { var _a; return (_a = c.hostConnected) === null || _a === void 0 ? void 0 : _a.call(c); });\n        // If we were disconnected, re-enable updating by resolving the pending\n        // connection promise\n        if (this.__enableConnection) {\n            this.__enableConnection();\n            this.__pendingConnectionPromise = this.__enableConnection = undefined;\n        }\n    }\n    /**\n     * Note, this method should be considered final and not overridden. It is\n     * overridden on the element instance with a function that triggers the first\n     * update.\n     * @category updates\n     */\n    enableUpdating(_requestedUpdate) { }\n    /**\n     * Allows for `super.disconnectedCallback()` in extensions while\n     * reserving the possibility of making non-breaking feature additions\n     * when disconnecting at some point in the future.\n     * @category lifecycle\n     */\n    disconnectedCallback() {\n        var _a;\n        (_a = this.__controllers) === null || _a === void 0 ? void 0 : _a.forEach((c) => { var _a; return (_a = c.hostDisconnected) === null || _a === void 0 ? void 0 : _a.call(c); });\n        this.__pendingConnectionPromise = new Promise((r) => (this.__enableConnection = r));\n    }\n    /**\n     * Synchronizes property values when attributes change.\n     * @category attributes\n     */\n    attributeChangedCallback(name, _old, value) {\n        this._$attributeToProperty(name, value);\n    }\n    __propertyToAttribute(name, value, options = defaultPropertyDeclaration) {\n        var _a, _b;\n        const attr = this\n            .constructor.__attributeNameForProperty(name, options);\n        if (attr !== undefined && options.reflect === true) {\n            const toAttribute = (_b = (_a = options.converter) === null || _a === void 0 ? void 0 : _a.toAttribute) !== null && _b !== void 0 ? _b : defaultConverter.toAttribute;\n            const attrValue = toAttribute(value, options.type);\n            if (DEV_MODE &&\n                this.constructor.enabledWarnings.indexOf('migration') >= 0 &&\n                attrValue === undefined) {\n                console.warn(`The attribute value for the ` +\n                    `${name} property is undefined. The attribute will be ` +\n                    `removed, but in the previous version of ReactiveElement, the ` +\n                    `attribute would not have changed.`);\n            }\n            // Track if the property is being reflected to avoid\n            // setting the property again via `attributeChangedCallback`. Note:\n            // 1. this takes advantage of the fact that the callback is synchronous.\n            // 2. will behave incorrectly if multiple attributes are in the reaction\n            // stack at time of calling. However, since we process attributes\n            // in `update` this should not be possible (or an extreme corner case\n            // that we'd like to discover).\n            // mark state reflecting\n            this.__reflectingProperty = name;\n            if (attrValue == null) {\n                this.removeAttribute(attr);\n            }\n            else {\n                this.setAttribute(attr, attrValue);\n            }\n            // mark state not reflecting\n            this.__reflectingProperty = null;\n        }\n    }\n    /** @internal */\n    _$attributeToProperty(name, value) {\n        var _a, _b, _c;\n        const ctor = this.constructor;\n        // Note, hint this as an `AttributeMap` so closure clearly understands\n        // the type; it has issues with tracking types through statics\n        const propName = ctor.__attributeToPropertyMap.get(name);\n        // Use tracking info to avoid reflecting a property value to an attribute\n        // if it was just set because the attribute changed.\n        if (propName !== undefined && this.__reflectingProperty !== propName) {\n            const options = ctor.getPropertyOptions(propName);\n            const converter = options.converter;\n            const fromAttribute = (_c = (_b = (_a = converter) === null || _a === void 0 ? void 0 : _a.fromAttribute) !== null && _b !== void 0 ? _b : (typeof converter === 'function'\n                ? converter\n                : null)) !== null && _c !== void 0 ? _c : defaultConverter.fromAttribute;\n            // mark state reflecting\n            this.__reflectingProperty = propName;\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            this[propName] = fromAttribute(value, options.type);\n            // mark state not reflecting\n            this.__reflectingProperty = null;\n        }\n    }\n    /**\n     * Requests an update which is processed asynchronously. This should be called\n     * when an element should update based on some state not triggered by setting\n     * a reactive property. In this case, pass no arguments. It should also be\n     * called when manually implementing a property setter. In this case, pass the\n     * property `name` and `oldValue` to ensure that any configured property\n     * options are honored.\n     *\n     * @param name name of requesting property\n     * @param oldValue old value of requesting property\n     * @param options property options to use instead of the previously\n     *     configured options\n     * @category updates\n     */\n    requestUpdate(name, oldValue, options) {\n        let shouldRequestUpdate = true;\n        // If we have a property key, perform property update steps.\n        if (name !== undefined) {\n            options =\n                options ||\n                    this.constructor.getPropertyOptions(name);\n            const hasChanged = options.hasChanged || notEqual;\n            if (hasChanged(this[name], oldValue)) {\n                if (!this._$changedProperties.has(name)) {\n                    this._$changedProperties.set(name, oldValue);\n                }\n                // Add to reflecting properties set.\n                // Note, it's important that every change has a chance to add the\n                // property to `_reflectingProperties`. This ensures setting\n                // attribute + property reflects correctly.\n                if (options.reflect === true && this.__reflectingProperty !== name) {\n                    if (this.__reflectingProperties === undefined) {\n                        this.__reflectingProperties = new Map();\n                    }\n                    this.__reflectingProperties.set(name, options);\n                }\n            }\n            else {\n                // Abort the request if the property should not be considered changed.\n                shouldRequestUpdate = false;\n            }\n        }\n        if (!this.isUpdatePending && shouldRequestUpdate) {\n            this.__updatePromise = this.__enqueueUpdate();\n        }\n        // Note, since this no longer returns a promise, in dev mode we return a\n        // thenable which warns if it's called.\n        return DEV_MODE ? requestUpdateThenable : undefined;\n    }\n    /**\n     * Sets up the element to asynchronously update.\n     */\n    async __enqueueUpdate() {\n        this.isUpdatePending = true;\n        try {\n            // Ensure any previous update has resolved before updating.\n            // This `await` also ensures that property changes are batched.\n            await this.__updatePromise;\n            // If we were disconnected, wait until re-connected to flush an update\n            while (this.__pendingConnectionPromise) {\n                await this.__pendingConnectionPromise;\n            }\n        }\n        catch (e) {\n            // Refire any previous errors async so they do not disrupt the update\n            // cycle. Errors are refired so developers have a chance to observe\n            // them, and this can be done by implementing\n            // `window.onunhandledrejection`.\n            Promise.reject(e);\n        }\n        const result = this.performUpdate();\n        // If `performUpdate` returns a Promise, we await it. This is done to\n        // enable coordinating updates with a scheduler. Note, the result is\n        // checked to avoid delaying an additional microtask unless we need to.\n        if (result != null) {\n            await result;\n        }\n        return !this.isUpdatePending;\n    }\n    /**\n     * Performs an element update. Note, if an exception is thrown during the\n     * update, `firstUpdated` and `updated` will not be called.\n     *\n     * You can override this method to change the timing of updates. If this\n     * method is overridden, `super.performUpdate()` must be called.\n     *\n     * For instance, to schedule updates to occur just before the next frame:\n     *\n     * ```\n     * protected async performUpdate(): Promise<unknown> {\n     *   await new Promise((resolve) => requestAnimationFrame(() => resolve()));\n     *   super.performUpdate();\n     * }\n     * ```\n     * @category updates\n     */\n    performUpdate() {\n        var _a;\n        // Abort any update if one is not pending when this is called.\n        // This can happen if `performUpdate` is called early to \"flush\"\n        // the update.\n        if (!this.isUpdatePending) {\n            return;\n        }\n        // create renderRoot before first update.\n        if (!this.hasUpdated) {\n            // Produce warning if any class properties are shadowed by class fields\n            if (DEV_MODE) {\n                const shadowedProperties = [];\n                this.constructor.elementProperties.forEach((_v, p) => {\n                    var _a;\n                    if (this.hasOwnProperty(p) && !((_a = this.__instanceProperties) === null || _a === void 0 ? void 0 : _a.has(p))) {\n                        shadowedProperties.push(p);\n                    }\n                });\n                if (shadowedProperties.length) {\n                    // TODO(sorvell): Link to docs explanation of this issue.\n                    console.warn(`The following properties will not trigger updates as expected ` +\n                        `because they are set using class fields: ` +\n                        `${shadowedProperties.join(', ')}. ` +\n                        `Native class fields and some compiled output will overwrite ` +\n                        `accessors used for detecting changes. To fix this issue, ` +\n                        `either initialize properties in the constructor or adjust ` +\n                        `your compiler settings; for example, for TypeScript set ` +\n                        `\\`useDefineForClassFields: false\\` in your \\`tsconfig.json\\`.`);\n                }\n            }\n        }\n        // Mixin instance properties once, if they exist.\n        if (this.__instanceProperties) {\n            // Use forEach so this works even if for/of loops are compiled to for loops\n            // expecting arrays\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            this.__instanceProperties.forEach((v, p) => (this[p] = v));\n            this.__instanceProperties = undefined;\n        }\n        let shouldUpdate = false;\n        const changedProperties = this._$changedProperties;\n        try {\n            shouldUpdate = this.shouldUpdate(changedProperties);\n            if (shouldUpdate) {\n                this.willUpdate(changedProperties);\n                (_a = this.__controllers) === null || _a === void 0 ? void 0 : _a.forEach((c) => { var _a; return (_a = c.hostUpdate) === null || _a === void 0 ? void 0 : _a.call(c); });\n                this.update(changedProperties);\n            }\n            else {\n                this.__markUpdated();\n            }\n        }\n        catch (e) {\n            // Prevent `firstUpdated` and `updated` from running when there's an\n            // update exception.\n            shouldUpdate = false;\n            // Ensure element can accept additional updates after an exception.\n            this.__markUpdated();\n            throw e;\n        }\n        // The update is no longer considered pending and further updates are now allowed.\n        if (shouldUpdate) {\n            this._$didUpdate(changedProperties);\n        }\n    }\n    /**\n     * @category updates\n     */\n    willUpdate(_changedProperties) { }\n    // Note, this is an override point for polyfill-support.\n    // @internal\n    _$didUpdate(changedProperties) {\n        var _a;\n        (_a = this.__controllers) === null || _a === void 0 ? void 0 : _a.forEach((c) => { var _a; return (_a = c.hostUpdated) === null || _a === void 0 ? void 0 : _a.call(c); });\n        if (!this.hasUpdated) {\n            this.hasUpdated = true;\n            this.firstUpdated(changedProperties);\n        }\n        this.updated(changedProperties);\n        if (DEV_MODE &&\n            this.isUpdatePending &&\n            this.constructor.enabledWarnings.indexOf('change-in-update') >= 0) {\n            console.warn(`An update was requested (generally because a property was set) ` +\n                `after an update completed, causing a new update to be scheduled. ` +\n                `This is inefficient and should be avoided unless the next update ` +\n                `can only be scheduled as a side effect of the previous update.`);\n        }\n    }\n    __markUpdated() {\n        this._$changedProperties = new Map();\n        this.isUpdatePending = false;\n    }\n    /**\n     * Returns a Promise that resolves when the element has completed updating.\n     * The Promise value is a boolean that is `true` if the element completed the\n     * update without triggering another update. The Promise result is `false` if\n     * a property was set inside `updated()`. If the Promise is rejected, an\n     * exception was thrown during the update.\n     *\n     * To await additional asynchronous work, override the `getUpdateComplete`\n     * method. For example, it is sometimes useful to await a rendered element\n     * before fulfilling this Promise. To do this, first await\n     * `super.getUpdateComplete()`, then any subsequent state.\n     *\n     * @return A promise of a boolean that indicates if the update resolved\n     *     without triggering another update.\n     * @category updates\n     */\n    get updateComplete() {\n        return this.getUpdateComplete();\n    }\n    /**\n     * Override point for the `updateComplete` promise.\n     *\n     * It is not safe to override the `updateComplete` getter directly due to a\n     * limitation in TypeScript which means it is not possible to call a\n     * superclass getter (e.g. `super.updateComplete.then(...)`) when the target\n     * language is ES5 (https://github.com/microsoft/TypeScript/issues/338).\n     * This method should be overridden instead. For example:\n     *\n     *   class MyElement extends LitElement {\n     *     async getUpdateComplete() {\n     *       await super.getUpdateComplete();\n     *       await this._myChild.updateComplete;\n     *     }\n     *   }\n     * @category updates\n     */\n    getUpdateComplete() {\n        return this.__updatePromise;\n    }\n    /**\n     * Controls whether or not `update` should be called when the element requests\n     * an update. By default, this method always returns `true`, but this can be\n     * customized to control when to update.\n     *\n     * @param _changedProperties Map of changed properties with old values\n     * @category updates\n     */\n    shouldUpdate(_changedProperties) {\n        return true;\n    }\n    /**\n     * Updates the element. This method reflects property values to attributes.\n     * It can be overridden to render and keep updated element DOM.\n     * Setting properties inside this method will *not* trigger\n     * another update.\n     *\n     * @param _changedProperties Map of changed properties with old values\n     * @category updates\n     */\n    update(_changedProperties) {\n        if (this.__reflectingProperties !== undefined) {\n            // Use forEach so this works even if for/of loops are compiled to for\n            // loops expecting arrays\n            this.__reflectingProperties.forEach((v, k) => this.__propertyToAttribute(k, this[k], v));\n            this.__reflectingProperties = undefined;\n        }\n        this.__markUpdated();\n    }\n    /**\n     * Invoked whenever the element is updated. Implement to perform\n     * post-updating tasks via DOM APIs, for example, focusing an element.\n     *\n     * Setting properties inside this method will trigger the element to update\n     * again after this update cycle completes.\n     *\n     * @param _changedProperties Map of changed properties with old values\n     * @category updates\n     */\n    updated(_changedProperties) { }\n    /**\n     * Invoked when the element is first updated. Implement to perform one time\n     * work on the element after update.\n     *\n     * Setting properties inside this method will trigger the element to update\n     * again after this update cycle completes.\n     *\n     * @param _changedProperties Map of changed properties with old values\n     * @category updates\n     */\n    firstUpdated(_changedProperties) { }\n}\n_f = finalized;\n/**\n * Marks class as having finished creating properties.\n */\nReactiveElement[_f] = true;\n/**\n * Memoized list of all element properties, including any superclass properties.\n * Created lazily on user subclasses when finalizing the class.\n * @nocollapse\n * @category properties\n */\nReactiveElement.elementProperties = new Map();\n/**\n * Memoized list of all element styles.\n * Created lazily on user subclasses when finalizing the class.\n * @nocollapse\n * @category styles\n */\nReactiveElement.elementStyles = [];\n/**\n * Options used when calling `attachShadow`. Set this property to customize\n * the options for the shadowRoot; for example, to create a closed\n * shadowRoot: `{mode: 'closed'}`.\n *\n * Note, these options are used in `createRenderRoot`. If this method\n * is customized, options should be respected if possible.\n * @nocollapse\n * @category rendering\n */\nReactiveElement.shadowRootOptions = { mode: 'open' };\n// Apply polyfills if available\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n(_c = (_b = globalThis)['reactiveElementPlatformSupport']) === null || _c === void 0 ? void 0 : _c.call(_b, { ReactiveElement });\n// Dev mode warnings...\nif (DEV_MODE) {\n    // Default warning set.\n    ReactiveElement.enabledWarnings = ['change-in-update'];\n    const ensureOwnWarnings = function (ctor) {\n        if (!ctor.hasOwnProperty(JSCompiler_renameProperty('enabledWarnings', ctor))) {\n            ctor.enabledWarnings = ctor.enabledWarnings.slice();\n        }\n    };\n    ReactiveElement.enableWarning = function (warning) {\n        ensureOwnWarnings(this);\n        if (this.enabledWarnings.indexOf(warning) < 0) {\n            this.enabledWarnings.push(warning);\n        }\n    };\n    ReactiveElement.disableWarning = function (warning) {\n        ensureOwnWarnings(this);\n        const i = this.enabledWarnings.indexOf(warning);\n        if (i >= 0) {\n            this.enabledWarnings.splice(i, 1);\n        }\n    };\n}\n// IMPORTANT: do not change the property name or the assignment expression.\n// This line will be used in regexes to search for ReactiveElement usage.\n// TODO(justinfagnani): inject version number at build time\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n((_d = (_e = globalThis)['reactiveElementVersions']) !== null && _d !== void 0 ? _d : (_e['reactiveElementVersions'] = [])).push('1.0.0-rc.2');\n//# sourceMappingURL=reactive-element.js.map","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nvar _a, _b, _c, _d, _e;\nvar _f;\n/**\n * The main LitElement module, which defines the [[`LitElement`]] base class and\n * related APIs.\n *\n *  LitElement components can define a template and a set of observed\n * properties. Changing an observed property triggers a re-render of the\n * element.\n *\n *  Import [[`LitElement`]] and [[`html`]] from this module to create a\n * component:\n *\n *  ```js\n * import {LitElement, html} from 'lit-element';\n *\n * class MyElement extends LitElement {\n *\n *   // Declare observed properties\n *   static get properties() {\n *     return {\n *       adjective: {}\n *     }\n *   }\n *\n *   constructor() {\n *     this.adjective = 'awesome';\n *   }\n *\n *   // Define the element's template\n *   render() {\n *     return html`<p>your ${adjective} template here</p>`;\n *   }\n * }\n *\n * customElements.define('my-element', MyElement);\n * ```\n *\n * `LitElement` extends [[`ReactiveElement`]] and adds lit-html templating.\n * The `ReactiveElement` class is provided for users that want to build\n * their own custom element base classes that don't use lit-html.\n *\n * @packageDocumentation\n */\nimport { ReactiveElement } from '@lit/reactive-element';\nimport { render, noChange } from 'lit-html';\nexport * from '@lit/reactive-element';\nexport * from 'lit-html';\n// For backwards compatibility export ReactiveElement as UpdatingElement. Note,\n// IE transpilation requires exporting like this.\nexport const UpdatingElement = ReactiveElement;\nconst DEV_MODE = true;\n// IMPORTANT: do not change the property name or the assignment expression.\n// This line will be used in regexes to search for LitElement usage.\n// TODO(justinfagnani): inject version number at build time\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n((_a = (_f = globalThis)['litElementVersions']) !== null && _a !== void 0 ? _a : (_f['litElementVersions'] = [])).push('3.0.0-rc.2');\n/**\n * Base element class that manages element properties and attributes, and\n * renders a lit-html template.\n *\n * To define a component, subclass `LitElement` and implement a\n * `render` method to provide the component's template. Define properties\n * using the [[`properties`]] property or the [[`property`]] decorator.\n */\nexport class LitElement extends ReactiveElement {\n    constructor() {\n        super(...arguments);\n        /**\n         * @category rendering\n         */\n        this.renderOptions = { host: this };\n        this.__childPart = undefined;\n    }\n    /**\n     * @category rendering\n     */\n    createRenderRoot() {\n        var _a;\n        var _b;\n        const renderRoot = super.createRenderRoot();\n        // When adoptedStyleSheets are shimmed, they are inserted into the\n        // shadowRoot by createRenderRoot. Adjust the renderBefore node so that\n        // any styles in Lit content render before adoptedStyleSheets. This is\n        // important so that adoptedStyleSheets have precedence over styles in\n        // the shadowRoot.\n        (_a = (_b = this.renderOptions).renderBefore) !== null && _a !== void 0 ? _a : (_b.renderBefore = renderRoot.firstChild);\n        return renderRoot;\n    }\n    /**\n     * Updates the element. This method reflects property values to attributes\n     * and calls `render` to render DOM via lit-html. Setting properties inside\n     * this method will *not* trigger another update.\n     * @param changedProperties Map of changed properties with old values\n     * @category updates\n     */\n    update(changedProperties) {\n        // Setting properties in `render` should not trigger an update. Since\n        // updates are allowed after super.update, it's important to call `render`\n        // before that.\n        const value = this.render();\n        super.update(changedProperties);\n        this.__childPart = render(value, this.renderRoot, this.renderOptions);\n    }\n    // TODO(kschaaf): Consider debouncing directive disconnection so element moves\n    // do not thrash directive callbacks\n    // https://github.com/lit/lit/issues/1457\n    /**\n     * @category lifecycle\n     */\n    connectedCallback() {\n        var _a;\n        super.connectedCallback();\n        (_a = this.__childPart) === null || _a === void 0 ? void 0 : _a.setConnected(true);\n    }\n    /**\n     * @category lifecycle\n     */\n    disconnectedCallback() {\n        var _a;\n        super.disconnectedCallback();\n        (_a = this.__childPart) === null || _a === void 0 ? void 0 : _a.setConnected(false);\n    }\n    /**\n     * Invoked on each update to perform rendering tasks. This method may return\n     * any value renderable by lit-html's `ChildPart` - typically a\n     * `TemplateResult`. Setting properties inside this method will *not* trigger\n     * the element to update.\n     * @category rendering\n     */\n    render() {\n        return noChange;\n    }\n}\n/**\n * Ensure this class is marked as `finalized` as an optimization ensuring\n * it will not needlessly try to `finalize`.\n *\n * Note this property name is a string to prevent breaking Closure JS Compiler\n * optimizations. See @lit/reactive-element for more information.\n */\nLitElement['finalized'] = true;\nLitElement._$litElement$ = true;\n// Install hydration if available\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n(_c = (_b = globalThis)['litElementHydrateSupport']) === null || _c === void 0 ? void 0 : _c.call(_b, { LitElement });\n// Apply polyfills if available\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n(_e = (_d = globalThis)['litElementPlatformSupport']) === null || _e === void 0 ? void 0 : _e.call(_d, { LitElement });\n// DEV mode warnings\nif (DEV_MODE) {\n    // Note, for compatibility with closure compilation, this access\n    // needs to be as a string property index.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    LitElement['finalize'] = function () {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const finalized = ReactiveElement.finalize.call(this);\n        if (!finalized) {\n            return false;\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const warnRemoved = (obj, name) => {\n            if (obj[name] !== undefined) {\n                console.warn(`\\`${name}\\` is implemented. It ` +\n                    `has been removed from this version of LitElement. `\n                // TODO(sorvell): add link to changelog when location has stabilized.\n                // + See the changelog at https://github.com/lit/lit/blob/main/packages/lit-element/CHANGELOG.md`\n                );\n            }\n        };\n        [`render`, `getStyles`].forEach((name) => \n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        warnRemoved(this, name));\n        [`adoptStyles`].forEach((name) => \n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        warnRemoved(this.prototype, name));\n        return true;\n    };\n}\n/**\n * END USERS SHOULD NOT RELY ON THIS OBJECT.\n *\n * Private exports for use by other Lit packages, not intended for use by\n * external users.\n *\n * We currently do not make a mangled rollup build of the lit-ssr code. In order\n * to keep a number of (otherwise private) top-level exports  mangled in the\n * client side code, we export a _Φ object containing those members (or\n * helper methods for accessing private fields of those members), and then\n * re-export them for use in lit-ssr. This keeps lit-ssr agnostic to whether the\n * client-side code is being used in `dev` mode or `prod` mode.\n *\n * This has a unique name, to disambiguate it from private exports in\n * lit-html, since this module re-exports all of lit-html.\n *\n * @private\n */\nexport const _Φ = {\n    _$attributeToProperty: (el, name, value) => {\n        // eslint-disable-next-line\n        el._$attributeToProperty(name, value);\n    },\n    // eslint-disable-next-line\n    _$changedProperties: (el) => el._$changedProperties,\n};\n//# sourceMappingURL=lit-element.js.map","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nvar _a, _b, _c, _d, _e;\nvar _f;\nconst DEV_MODE = true;\nconst ENABLE_EXTRA_SECURITY_HOOKS = true;\nconst ENABLE_SHADYDOM_NOPATCH = true;\nif (DEV_MODE) {\n    console.warn('lit-html is in dev mode. Not recommended for production!');\n}\nconst wrap = ENABLE_SHADYDOM_NOPATCH && ((_a = window.ShadyDOM) === null || _a === void 0 ? void 0 : _a.inUse) &&\n    ((_b = window.ShadyDOM) === null || _b === void 0 ? void 0 : _b.noPatch) === true\n    ? window.ShadyDOM.wrap\n    : (node) => node;\nconst trustedTypes = globalThis.trustedTypes;\n/**\n * Our TrustedTypePolicy for HTML which is declared using the html template\n * tag function.\n *\n * That HTML is a developer-authored constant, and is parsed with innerHTML\n * before any untrusted expressions have been mixed in. Therefor it is\n * considered safe by construction.\n */\nconst policy = trustedTypes\n    ? trustedTypes.createPolicy('lit-html', {\n        createHTML: (s) => s,\n    })\n    : undefined;\nconst identityFunction = (value) => value;\nconst noopSanitizer = (_node, _name, _type) => identityFunction;\n/** Sets the global sanitizer factory. */\nconst setSanitizer = (newSanitizer) => {\n    if (!ENABLE_EXTRA_SECURITY_HOOKS) {\n        return;\n    }\n    if (sanitizerFactoryInternal !== noopSanitizer) {\n        throw new Error(`Attempted to overwrite existing lit-html security policy.` +\n            ` setSanitizeDOMValueFactory should be called at most once.`);\n    }\n    sanitizerFactoryInternal = newSanitizer;\n};\n/**\n * Only used in internal tests, not a part of the public API.\n */\nconst _testOnlyClearSanitizerFactoryDoNotCallOrElse = () => {\n    sanitizerFactoryInternal = noopSanitizer;\n};\nconst createSanitizer = (node, name, type) => {\n    return sanitizerFactoryInternal(node, name, type);\n};\n// Added to an attribute name to mark the attribute as bound so we can find\n// it easily.\nconst boundAttributeSuffix = '$lit$';\n// This marker is used in many syntactic positions in HTML, so it must be\n// a valid element name and attribute name. We don't support dynamic names (yet)\n// but this at least ensures that the parse tree is closer to the template\n// intention.\nconst marker = `lit$${String(Math.random()).slice(9)}$`;\n// String used to tell if a comment is a marker comment\nconst markerMatch = '?' + marker;\n// Text used to insert a comment marker node. We use processing instruction\n// syntax because it's slightly smaller, but parses as a comment node.\nconst nodeMarker = `<${markerMatch}>`;\nconst d = document;\n// Creates a dynamic marker. We never have to search for these in the DOM.\nconst createMarker = (v = '') => d.createComment(v);\nconst isPrimitive = (value) => value === null || (typeof value != 'object' && typeof value != 'function');\nconst isArray = Array.isArray;\nconst isIterable = (value) => {\n    var _a;\n    return isArray(value) ||\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        typeof ((_a = value) === null || _a === void 0 ? void 0 : _a[Symbol.iterator]) === 'function';\n};\nconst SPACE_CHAR = `[ \\t\\n\\f\\r]`;\nconst ATTR_VALUE_CHAR = `[^ \\t\\n\\f\\r\"'\\`<>=]`;\nconst NAME_CHAR = `[^\\\\s\"'>=/]`;\n// These regexes represent the five parsing states that we care about in the\n// Template's HTML scanner. They match the *end* of the state they're named\n// after.\n// Depending on the match, we transition to a new state. If there's no match,\n// we stay in the same state.\n// Note that the regexes are stateful. We utilize lastIndex and sync it\n// across the multiple regexes used. In addition to the five regexes below\n// we also dynamically create a regex to find the matching end tags for raw\n// text elements.\n/**\n * End of text is: `<` followed by:\n *   (comment start) or (tag) or (dynamic tag binding)\n */\nconst textEndRegex = /<(?:(!--|\\/[^a-zA-Z])|(\\/?[a-zA-Z][^>\\s]*)|(\\/?$))/g;\nconst COMMENT_START = 1;\nconst TAG_NAME = 2;\nconst DYNAMIC_TAG_NAME = 3;\nconst commentEndRegex = /-->/g;\n/**\n * Comments not started with <!--, like </{, can be ended by a single `>`\n */\nconst comment2EndRegex = />/g;\n/**\n * The tagEnd regex matches the end of the \"inside an opening\" tag syntax\n * position. It either matches a `>`, an attribute-like sequence, or the end\n * of the string after a space (attribute-name position ending).\n *\n * See attributes in the HTML spec:\n * https://www.w3.org/TR/html5/syntax.html#elements-attributes\n *\n * \" \\t\\n\\f\\r\" are HTML space characters:\n * https://infra.spec.whatwg.org/#ascii-whitespace\n *\n * So an attribute is:\n *  * The name: any character except a whitespace character, (\"), ('), \">\",\n *    \"=\", or \"/\". Note: this is different from the HTML spec which also excludes control characters.\n *  * Followed by zero or more space characters\n *  * Followed by \"=\"\n *  * Followed by zero or more space characters\n *  * Followed by:\n *    * Any character except space, ('), (\"), \"<\", \">\", \"=\", (`), or\n *    * (\") then any non-(\"), or\n *    * (') then any non-(')\n */\nconst tagEndRegex = new RegExp(`>|${SPACE_CHAR}(?:(${NAME_CHAR}+)(${SPACE_CHAR}*=${SPACE_CHAR}*(?:${ATTR_VALUE_CHAR}|(\"|')|))|$)`, 'g');\nconst ENTIRE_MATCH = 0;\nconst ATTRIBUTE_NAME = 1;\nconst SPACES_AND_EQUALS = 2;\nconst QUOTE_CHAR = 3;\nconst singleQuoteAttrEndRegex = /'/g;\nconst doubleQuoteAttrEndRegex = /\"/g;\n/**\n * Matches the raw text elements.\n *\n * Comments are not parsed within raw text elements, so we need to search their\n * text content for marker strings.\n */\nconst rawTextElement = /^(?:script|style|textarea)$/i;\n/** TemplateResult types */\nconst HTML_RESULT = 1;\nconst SVG_RESULT = 2;\n// TemplatePart types\n// IMPORTANT: these must match the values in PartType\nconst ATTRIBUTE_PART = 1;\nconst CHILD_PART = 2;\nconst PROPERTY_PART = 3;\nconst BOOLEAN_ATTRIBUTE_PART = 4;\nconst EVENT_PART = 5;\nconst ELEMENT_PART = 6;\nconst COMMENT_PART = 7;\n/**\n * Generates a template literal tag function that returns a TemplateResult with\n * the given result type.\n */\nconst tag = (_$litType$) => (strings, ...values) => ({\n    _$litType$,\n    strings,\n    values,\n});\n/**\n * Interprets a template literal as an HTML template that can efficiently\n * render to and update a container.\n */\nexport const html = tag(HTML_RESULT);\n/**\n * Interprets a template literal as an SVG template that can efficiently\n * render to and update a container.\n */\nexport const svg = tag(SVG_RESULT);\n/**\n * A sentinel value that signals that a value was handled by a directive and\n * should not be written to the DOM.\n */\nexport const noChange = Symbol.for('lit-noChange');\n/**\n * A sentinel value that signals a ChildPart to fully clear its content.\n */\nexport const nothing = Symbol.for('lit-nothing');\n/**\n * The cache of prepared templates, keyed by the tagged TemplateStringsArray\n * and _not_ accounting for the specific template tag used. This means that\n * template tags cannot be dynamic - the must statically be one of html, svg,\n * or attr. This restriction simplifies the cache lookup, which is on the hot\n * path for rendering.\n */\nconst templateCache = new WeakMap();\n/**\n * Renders a value, usually a lit-html TemplateResult, to the container.\n * @param value\n * @param container\n * @param options\n */\nexport const render = (value, container, options) => {\n    var _a, _b;\n    const partOwnerNode = (_a = options === null || options === void 0 ? void 0 : options.renderBefore) !== null && _a !== void 0 ? _a : container;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let part = partOwnerNode._$litPart$;\n    if (part === undefined) {\n        const endNode = (_b = options === null || options === void 0 ? void 0 : options.renderBefore) !== null && _b !== void 0 ? _b : null;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        partOwnerNode._$litPart$ = part = new ChildPart(container.insertBefore(createMarker(), endNode), endNode, undefined, options);\n    }\n    part._$setValue(value);\n    return part;\n};\nif (ENABLE_EXTRA_SECURITY_HOOKS) {\n    render.setSanitizer = setSanitizer;\n    render.createSanitizer = createSanitizer;\n    if (DEV_MODE) {\n        render._testOnlyClearSanitizerFactoryDoNotCallOrElse = _testOnlyClearSanitizerFactoryDoNotCallOrElse;\n    }\n}\nconst walker = d.createTreeWalker(d, 129 /* NodeFilter.SHOW_{ELEMENT|COMMENT} */, null, false);\nlet sanitizerFactoryInternal = noopSanitizer;\n/**\n * Returns an HTML string for the given TemplateStringsArray and result type\n * (HTML or SVG), along with the case-sensitive bound attribute names in\n * template order. The HTML contains comment comment markers denoting the\n * `ChildPart`s and suffixes on bound attributes denoting the `AttributeParts`.\n *\n * @param strings template strings array\n * @param type HTML or SVG\n * @return Array containing `[html, attrNames]` (array returned for terseness,\n *     to avoid object fields since this code is shared with non-minified SSR\n *     code)\n */\nconst getTemplateHtml = (strings, type) => {\n    // Insert makers into the template HTML to represent the position of\n    // bindings. The following code scans the template strings to determine the\n    // syntactic position of the bindings. They can be in text position, where\n    // we insert an HTML comment, attribute value position, where we insert a\n    // sentinel string and re-write the attribute name, or inside a tag where\n    // we insert the sentinel string.\n    const l = strings.length - 1;\n    // Stores the case-sensitive bound attribute names in the order of their\n    // parts. ElementParts are also reflected in this array as undefined\n    // rather than a string, to disambiguate from attribute bindings.\n    const attrNames = [];\n    let html = type === SVG_RESULT ? '<svg>' : '';\n    // When we're inside a raw text tag (not it's text content), the regex\n    // will still be tagRegex so we can find attributes, but will switch to\n    // this regex when the tag ends.\n    let rawTextEndRegex;\n    // The current parsing state, represented as a reference to one of the\n    // regexes\n    let regex = textEndRegex;\n    for (let i = 0; i < l; i++) {\n        const s = strings[i];\n        // The index of the end of the last attribute name. When this is\n        // positive at end of a string, it means we're in an attribute value\n        // position and need to rewrite the attribute name.\n        // We also use a special value of -2 to indicate that we encountered\n        // the end of a string in attribute name position.\n        let attrNameEndIndex = -1;\n        let attrName;\n        let lastIndex = 0;\n        let match;\n        // The conditions in this loop handle the current parse state, and the\n        // assignments to the `regex` variable are the state transitions.\n        while (lastIndex < s.length) {\n            // Make sure we start searching from where we previously left off\n            regex.lastIndex = lastIndex;\n            match = regex.exec(s);\n            if (match === null) {\n                break;\n            }\n            lastIndex = regex.lastIndex;\n            if (regex === textEndRegex) {\n                if (match[COMMENT_START] === '!--') {\n                    regex = commentEndRegex;\n                }\n                else if (match[COMMENT_START] !== undefined) {\n                    // We started a weird comment, like </{\n                    regex = comment2EndRegex;\n                }\n                else if (match[TAG_NAME] !== undefined) {\n                    if (rawTextElement.test(match[TAG_NAME])) {\n                        // Record if we encounter a raw-text element. We'll switch to\n                        // this regex at the end of the tag.\n                        rawTextEndRegex = new RegExp(`</${match[TAG_NAME]}`, 'g');\n                    }\n                    regex = tagEndRegex;\n                }\n                else if (match[DYNAMIC_TAG_NAME] !== undefined) {\n                    // dynamic tag name\n                    regex = tagEndRegex;\n                }\n            }\n            else if (regex === tagEndRegex) {\n                if (match[ENTIRE_MATCH] === '>') {\n                    // End of a tag. If we had started a raw-text element, use that\n                    // regex\n                    regex = rawTextEndRegex !== null && rawTextEndRegex !== void 0 ? rawTextEndRegex : textEndRegex;\n                    // We may be ending an unquoted attribute value, so make sure we\n                    // clear any pending attrNameEndIndex\n                    attrNameEndIndex = -1;\n                }\n                else if (match[ATTRIBUTE_NAME] === undefined) {\n                    // Attribute name position\n                    attrNameEndIndex = -2;\n                }\n                else {\n                    attrNameEndIndex = regex.lastIndex - match[SPACES_AND_EQUALS].length;\n                    attrName = match[ATTRIBUTE_NAME];\n                    regex =\n                        match[QUOTE_CHAR] === undefined\n                            ? tagEndRegex\n                            : match[QUOTE_CHAR] === '\"'\n                                ? doubleQuoteAttrEndRegex\n                                : singleQuoteAttrEndRegex;\n                }\n            }\n            else if (regex === doubleQuoteAttrEndRegex ||\n                regex === singleQuoteAttrEndRegex) {\n                regex = tagEndRegex;\n            }\n            else if (regex === commentEndRegex || regex === comment2EndRegex) {\n                regex = textEndRegex;\n            }\n            else {\n                // Not one of the five state regexes, so it must be the dynamically\n                // created raw text regex and we're at the close of that element.\n                regex = tagEndRegex;\n                rawTextEndRegex = undefined;\n            }\n        }\n        if (DEV_MODE) {\n            // If we have a attrNameEndIndex, which indicates that we should\n            // rewrite the attribute name, assert that we're in a valid attribute\n            // position - either in a tag, or a quoted attribute value.\n            console.assert(attrNameEndIndex === -1 ||\n                regex === tagEndRegex ||\n                regex === singleQuoteAttrEndRegex ||\n                regex === doubleQuoteAttrEndRegex, 'unexpected parse state B');\n        }\n        // We have four cases:\n        //  1. We're in text position, and not in a raw text element\n        //     (regex === textEndRegex): insert a comment marker.\n        //  2. We have a non-negative attrNameEndIndex which means we need to\n        //     rewrite the attribute name to add a bound attribute suffix.\n        //  3. We're at the non-first binding in a multi-binding attribute, use a\n        //     plain marker.\n        //  4. We're somewhere else inside the tag. If we're in attribute name\n        //     position (attrNameEndIndex === -2), add a sequential suffix to\n        //     generate a unique attribute name.\n        // Detect a binding next to self-closing tag end and insert a space to\n        // separate the marker from the tag end:\n        const end = regex === tagEndRegex && strings[i + 1].startsWith('/>') ? ' ' : '';\n        html +=\n            regex === textEndRegex\n                ? s + nodeMarker\n                : attrNameEndIndex >= 0\n                    ? (attrNames.push(attrName),\n                        s.slice(0, attrNameEndIndex) +\n                            boundAttributeSuffix +\n                            s.slice(attrNameEndIndex)) +\n                        marker +\n                        end\n                    : s +\n                        marker +\n                        (attrNameEndIndex === -2 ? (attrNames.push(undefined), i) : end);\n    }\n    const htmlResult = html + (strings[l] || '<?>') + (type === SVG_RESULT ? '</svg>' : '');\n    // Returned as an array for terseness\n    return [\n        policy !== undefined\n            ? policy.createHTML(htmlResult)\n            : htmlResult,\n        attrNames,\n    ];\n};\nclass Template {\n    constructor({ strings, _$litType$: type }, options) {\n        /** @internal */\n        this.parts = [];\n        let node;\n        let nodeIndex = 0;\n        let attrNameIndex = 0;\n        const partCount = strings.length - 1;\n        const parts = this.parts;\n        // Create template element\n        const [html, attrNames] = getTemplateHtml(strings, type);\n        this.el = Template.createElement(html, options);\n        walker.currentNode = this.el.content;\n        // Reparent SVG nodes into template root\n        if (type === SVG_RESULT) {\n            const content = this.el.content;\n            const svgElement = content.firstChild;\n            svgElement.remove();\n            content.append(...svgElement.childNodes);\n        }\n        // Walk the template to find binding markers and create TemplateParts\n        while ((node = walker.nextNode()) !== null && parts.length < partCount) {\n            if (node.nodeType === 1) {\n                // TODO (justinfagnani): for attempted dynamic tag names, we don't\n                // increment the bindingIndex, and it'll be off by 1 in the element\n                // and off by two after it.\n                if (node.hasAttributes()) {\n                    // We defer removing bound attributes because on IE we might not be\n                    // iterating attributes in their template order, and would sometimes\n                    // remove an attribute that we still need to create a part for.\n                    const attrsToRemove = [];\n                    for (const name of node.getAttributeNames()) {\n                        // `name` is the name of the attribute we're iterating over, but not\n                        // _neccessarily_ the name of the attribute we will create a part\n                        // for. They can be different in browsers that don't iterate on\n                        // attributes in source order. In that case the attrNames array\n                        // contains the attribute name we'll process next. We only need the\n                        // attribute name here to know if we should process a bound attribute\n                        // on this element.\n                        if (name.endsWith(boundAttributeSuffix) ||\n                            name.startsWith(marker)) {\n                            const realName = attrNames[attrNameIndex++];\n                            attrsToRemove.push(name);\n                            if (realName !== undefined) {\n                                // Lowercase for case-sensitive SVG attributes like viewBox\n                                const value = node.getAttribute(realName.toLowerCase() + boundAttributeSuffix);\n                                const statics = value.split(marker);\n                                const m = /([.?@])?(.*)/.exec(realName);\n                                parts.push({\n                                    type: ATTRIBUTE_PART,\n                                    index: nodeIndex,\n                                    name: m[2],\n                                    strings: statics,\n                                    ctor: m[1] === '.'\n                                        ? PropertyPart\n                                        : m[1] === '?'\n                                            ? BooleanAttributePart\n                                            : m[1] === '@'\n                                                ? EventPart\n                                                : AttributePart,\n                                });\n                            }\n                            else {\n                                parts.push({\n                                    type: ELEMENT_PART,\n                                    index: nodeIndex,\n                                });\n                            }\n                        }\n                    }\n                    for (const name of attrsToRemove) {\n                        node.removeAttribute(name);\n                    }\n                }\n                // TODO (justinfagnani): benchmark the regex against testing for each\n                // of the 3 raw text element names.\n                if (rawTextElement.test(node.tagName)) {\n                    // For raw text elements we need to split the text content on\n                    // markers, create a Text node for each segment, and create\n                    // a TemplatePart for each marker.\n                    const strings = node.textContent.split(marker);\n                    const lastIndex = strings.length - 1;\n                    if (lastIndex > 0) {\n                        node.textContent = trustedTypes\n                            ? trustedTypes.emptyScript\n                            : '';\n                        // Generate a new text node for each literal section\n                        // These nodes are also used as the markers for node parts\n                        // We can't use empty text nodes as markers because they're\n                        // normalized in some browsers (TODO: check)\n                        for (let i = 0; i < lastIndex; i++) {\n                            node.append(strings[i], createMarker());\n                            // Walk past the marker node we just added\n                            walker.nextNode();\n                            parts.push({ type: CHILD_PART, index: ++nodeIndex });\n                        }\n                        // Note because this marker is added after the walker's current\n                        // node, it will be walked to in the outer loop (and ignored), so\n                        // we don't need to adjust nodeIndex here\n                        node.append(strings[lastIndex], createMarker());\n                    }\n                }\n            }\n            else if (node.nodeType === 8) {\n                const data = node.data;\n                if (data === markerMatch) {\n                    parts.push({ type: CHILD_PART, index: nodeIndex });\n                }\n                else {\n                    let i = -1;\n                    while ((i = node.data.indexOf(marker, i + 1)) !== -1) {\n                        // Comment node has a binding marker inside, make an inactive part\n                        // The binding won't work, but subsequent bindings will\n                        // TODO (justinfagnani): consider whether it's even worth it to\n                        // make bindings in comments work\n                        parts.push({ type: COMMENT_PART, index: nodeIndex });\n                        // Move to the end of the match\n                        i += marker.length - 1;\n                    }\n                }\n            }\n            nodeIndex++;\n        }\n    }\n    // Overridden via `litHtmlPlatformSupport` to provide platform support.\n    static createElement(html, _options) {\n        const el = d.createElement('template');\n        el.innerHTML = html;\n        return el;\n    }\n}\nfunction resolveDirective(part, value, parent = part, attributeIndex) {\n    var _a, _b, _c;\n    var _d;\n    // Bail early if the value is explicitly noChange. Note, this means any\n    // nested directive is still attached and is not run.\n    if (value === noChange) {\n        return value;\n    }\n    let currentDirective = attributeIndex !== undefined\n        ? (_a = parent.__directives) === null || _a === void 0 ? void 0 : _a[attributeIndex] : parent.__directive;\n    const nextDirectiveConstructor = isPrimitive(value)\n        ? undefined\n        : value._$litDirective$;\n    if ((currentDirective === null || currentDirective === void 0 ? void 0 : currentDirective.constructor) !== nextDirectiveConstructor) {\n        (_b = currentDirective === null || currentDirective === void 0 ? void 0 : currentDirective._$setDirectiveConnected) === null || _b === void 0 ? void 0 : _b.call(currentDirective, false);\n        if (nextDirectiveConstructor === undefined) {\n            currentDirective = undefined;\n        }\n        else {\n            currentDirective = new nextDirectiveConstructor(part);\n            currentDirective._$initialize(part, parent, attributeIndex);\n        }\n        if (attributeIndex !== undefined) {\n            ((_c = (_d = parent).__directives) !== null && _c !== void 0 ? _c : (_d.__directives = []))[attributeIndex] = currentDirective;\n        }\n        else {\n            parent.__directive = currentDirective;\n        }\n    }\n    if (currentDirective !== undefined) {\n        value = resolveDirective(part, currentDirective._$resolve(part, value.values), currentDirective, attributeIndex);\n    }\n    return value;\n}\n/**\n * An updateable instance of a Template. Holds references to the Parts used to\n * update the template instance.\n */\nclass TemplateInstance {\n    constructor(template, parent) {\n        /** @internal */\n        this._parts = [];\n        /** @internal */\n        this._$disconnectableChildren = undefined;\n        this._$template = template;\n        this._$parent = parent;\n    }\n    // This method is separate from the constructor because we need to return a\n    // DocumentFragment and we don't want to hold onto it with an instance field.\n    _clone(options) {\n        var _a;\n        const { el: { content }, parts: parts, } = this._$template;\n        const fragment = ((_a = options === null || options === void 0 ? void 0 : options.creationScope) !== null && _a !== void 0 ? _a : d).importNode(content, true);\n        walker.currentNode = fragment;\n        let node = walker.nextNode();\n        let nodeIndex = 0;\n        let partIndex = 0;\n        let templatePart = parts[0];\n        while (templatePart !== undefined) {\n            if (nodeIndex === templatePart.index) {\n                let part;\n                if (templatePart.type === CHILD_PART) {\n                    part = new ChildPart(node, node.nextSibling, this, options);\n                }\n                else if (templatePart.type === ATTRIBUTE_PART) {\n                    part = new templatePart.ctor(node, templatePart.name, templatePart.strings, this, options);\n                }\n                else if (templatePart.type === ELEMENT_PART) {\n                    part = new ElementPart(node, this, options);\n                }\n                this._parts.push(part);\n                templatePart = parts[++partIndex];\n            }\n            if (nodeIndex !== (templatePart === null || templatePart === void 0 ? void 0 : templatePart.index)) {\n                node = walker.nextNode();\n                nodeIndex++;\n            }\n        }\n        return fragment;\n    }\n    _update(values) {\n        let i = 0;\n        for (const part of this._parts) {\n            if (part !== undefined) {\n                if (part.strings !== undefined) {\n                    part._$setValue(values, part, i);\n                    // The number of values the part consumes is part.strings.length - 1\n                    // since values are in between template spans. We increment i by 1\n                    // later in the loop, so increment it by part.strings.length - 2 here\n                    i += part.strings.length - 2;\n                }\n                else {\n                    part._$setValue(values[i]);\n                }\n            }\n            i++;\n        }\n    }\n}\nclass ChildPart {\n    constructor(startNode, endNode, parent, options) {\n        this.type = CHILD_PART;\n        // The following fields will be patched onto ChildParts when required by\n        // AsyncDirective\n        /** @internal */\n        this._$disconnectableChildren = undefined;\n        this._$startNode = startNode;\n        this._$endNode = endNode;\n        this._$parent = parent;\n        this.options = options;\n        if (ENABLE_EXTRA_SECURITY_HOOKS) {\n            // Explicitly initialize for consistent class shape.\n            this._textSanitizer = undefined;\n        }\n    }\n    /**\n     * Sets the connection state for any `AsyncDirectives` contained\n     * within this part and runs their `disconnected` or `reconnected`, according\n     * to the `isConnected` argument.\n     */\n    setConnected(isConnected) {\n        var _a;\n        (_a = this._$setChildPartConnected) === null || _a === void 0 ? void 0 : _a.call(this, isConnected);\n    }\n    /**\n     * The parent node into which the part renders its content.\n     *\n     * A ChildPart's content consists of a range of adjacent child nodes of\n     * `.parentNode`, possibly bordered by 'marker nodes' (`.startNode` and\n     * `.endNode`).\n     *\n     * - If both `.startNode` and `.endNode` are non-null, then the part's content\n     * consists of all siblings between `.startNode` and `.endNode`, exclusively.\n     *\n     * - If `.startNode` is non-null but `.endNode` is null, then the part's\n     * content consists of all siblings following `.startNode`, up to and\n     * including the last child of `.parentNode`. If `.endNode` is non-null, then\n     * `.startNode` will always be non-null.\n     *\n     * - If both `.endNode` and `.startNode` are null, then the part's content\n     * consists of all child nodes of `.parentNode`.\n     */\n    get parentNode() {\n        return wrap(this._$startNode).parentNode;\n    }\n    /**\n     * The part's leading marker node, if any. See `.parentNode` for more\n     * information.\n     */\n    get startNode() {\n        return this._$startNode;\n    }\n    /**\n     * The part's trailing marker node, if any. See `.parentNode` for more\n     * information.\n     */\n    get endNode() {\n        return this._$endNode;\n    }\n    _$setValue(value, directiveParent = this) {\n        value = resolveDirective(this, value, directiveParent);\n        if (isPrimitive(value)) {\n            // Non-rendering child values. It's important that these do not render\n            // empty text nodes to avoid issues with preventing default <slot>\n            // fallback content.\n            if (value === nothing || value == null || value === '') {\n                if (this._$committedValue !== nothing) {\n                    this._$clear();\n                }\n                this._$committedValue = nothing;\n            }\n            else if (value !== this._$committedValue && value !== noChange) {\n                this._commitText(value);\n            }\n        }\n        else if (value._$litType$ !== undefined) {\n            this._commitTemplateResult(value);\n        }\n        else if (value.nodeType !== undefined) {\n            this._commitNode(value);\n        }\n        else if (isIterable(value)) {\n            this._commitIterable(value);\n        }\n        else {\n            // Fallback, will render the string representation\n            this._commitText(value);\n        }\n    }\n    _insert(node, ref = this._$endNode) {\n        return wrap(wrap(this._$startNode).parentNode).insertBefore(node, ref);\n    }\n    _commitNode(value) {\n        var _a;\n        if (this._$committedValue !== value) {\n            this._$clear();\n            if (ENABLE_EXTRA_SECURITY_HOOKS &&\n                sanitizerFactoryInternal !== noopSanitizer) {\n                const parentNodeName = (_a = this._$startNode.parentNode) === null || _a === void 0 ? void 0 : _a.nodeName;\n                if (parentNodeName === 'STYLE' || parentNodeName === 'SCRIPT') {\n                    this._insert(new Text('/* lit-html will not write ' +\n                        'TemplateResults to scripts and styles */'));\n                    return;\n                }\n            }\n            this._$committedValue = this._insert(value);\n        }\n    }\n    _commitText(value) {\n        const node = wrap(this._$startNode).nextSibling;\n        // TODO(justinfagnani): Can we just check if this._$committedValue is primitive?\n        if (node !== null &&\n            node.nodeType === 3 /* Node.TEXT_NODE */ &&\n            (this._$endNode === null\n                ? wrap(node).nextSibling === null\n                : node === wrap(this._$endNode).previousSibling)) {\n            if (ENABLE_EXTRA_SECURITY_HOOKS) {\n                if (this._textSanitizer === undefined) {\n                    this._textSanitizer = createSanitizer(node, 'data', 'property');\n                }\n                value = this._textSanitizer(value);\n            }\n            // If we only have a single text node between the markers, we can just\n            // set its value, rather than replacing it.\n            node.data = value;\n        }\n        else {\n            if (ENABLE_EXTRA_SECURITY_HOOKS) {\n                const textNode = document.createTextNode('');\n                this._commitNode(textNode);\n                // When setting text content, for security purposes it matters a lot\n                // what the parent is. For example, <style> and <script> need to be\n                // handled with care, while <span> does not. So first we need to put a\n                // text node into the document, then we can sanitize its contentx.\n                if (this._textSanitizer === undefined) {\n                    this._textSanitizer = createSanitizer(textNode, 'data', 'property');\n                }\n                value = this._textSanitizer(value);\n                textNode.data = value;\n            }\n            else {\n                this._commitNode(d.createTextNode(value));\n            }\n        }\n        this._$committedValue = value;\n    }\n    _commitTemplateResult(result) {\n        var _a;\n        const { values, _$litType$ } = result;\n        // If $litType$ is a number, result is a plain TemplateResult and we get\n        // the template from the template cache. If not, result is a\n        // CompiledTemplateResult and _$litType$ is a CompiledTemplate and we need\n        // to create the <template> element the first time we see it.\n        const template = typeof _$litType$ === 'number'\n            ? this._$getTemplate(result)\n            : (_$litType$.el === undefined &&\n                (_$litType$.el = Template.createElement(_$litType$.h, this.options)),\n                _$litType$);\n        if (((_a = this._$committedValue) === null || _a === void 0 ? void 0 : _a._$template) === template) {\n            this._$committedValue._update(values);\n        }\n        else {\n            const instance = new TemplateInstance(template, this);\n            const fragment = instance._clone(this.options);\n            instance._update(values);\n            this._commitNode(fragment);\n            this._$committedValue = instance;\n        }\n    }\n    // Overridden via `litHtmlPlatformSupport` to provide platform support.\n    /** @internal */\n    _$getTemplate(result) {\n        let template = templateCache.get(result.strings);\n        if (template === undefined) {\n            templateCache.set(result.strings, (template = new Template(result)));\n        }\n        return template;\n    }\n    _commitIterable(value) {\n        // For an Iterable, we create a new InstancePart per item, then set its\n        // value to the item. This is a little bit of overhead for every item in\n        // an Iterable, but it lets us recurse easily and efficiently update Arrays\n        // of TemplateResults that will be commonly returned from expressions like:\n        // array.map((i) => html`${i}`), by reusing existing TemplateInstances.\n        // If value is an array, then the previous render was of an\n        // iterable and value will contain the ChildParts from the previous\n        // render. If value is not an array, clear this part and make a new\n        // array for ChildParts.\n        if (!isArray(this._$committedValue)) {\n            this._$committedValue = [];\n            this._$clear();\n        }\n        // Lets us keep track of how many items we stamped so we can clear leftover\n        // items from a previous render\n        const itemParts = this._$committedValue;\n        let partIndex = 0;\n        let itemPart;\n        for (const item of value) {\n            if (partIndex === itemParts.length) {\n                // If no existing part, create a new one\n                // TODO (justinfagnani): test perf impact of always creating two parts\n                // instead of sharing parts between nodes\n                // https://github.com/lit/lit/issues/1266\n                itemParts.push((itemPart = new ChildPart(this._insert(createMarker()), this._insert(createMarker()), this, this.options)));\n            }\n            else {\n                // Reuse an existing part\n                itemPart = itemParts[partIndex];\n            }\n            itemPart._$setValue(item);\n            partIndex++;\n        }\n        if (partIndex < itemParts.length) {\n            // itemParts always have end nodes\n            this._$clear(itemPart && wrap(itemPart._$endNode).nextSibling, partIndex);\n            // Truncate the parts array so _value reflects the current state\n            itemParts.length = partIndex;\n        }\n    }\n    /**\n     * Removes the nodes contained within this Part from the DOM.\n     *\n     * @param start Start node to clear from, for clearing a subset of the part's\n     *     DOM (used when truncating iterables)\n     * @param from  When `start` is specified, the index within the iterable from\n     *     which ChildParts are being removed, used for disconnecting directives in\n     *     those Parts.\n     *\n     * @internal\n     */\n    _$clear(start = wrap(this._$startNode).nextSibling, from) {\n        var _a;\n        (_a = this._$setChildPartConnected) === null || _a === void 0 ? void 0 : _a.call(this, false, true, from);\n        while (start && start !== this._$endNode) {\n            const n = wrap(start).nextSibling;\n            wrap(start).remove();\n            start = n;\n        }\n    }\n}\nclass AttributePart {\n    constructor(element, name, strings, parent, options) {\n        this.type = ATTRIBUTE_PART;\n        /** @internal */\n        this._$committedValue = nothing;\n        /** @internal */\n        this._$disconnectableChildren = undefined;\n        /** @internal */\n        this._setDirectiveConnected = undefined;\n        this.element = element;\n        this.name = name;\n        this._$parent = parent;\n        this.options = options;\n        if (strings.length > 2 || strings[0] !== '' || strings[1] !== '') {\n            this._$committedValue = new Array(strings.length - 1).fill(nothing);\n            this.strings = strings;\n        }\n        else {\n            this._$committedValue = nothing;\n        }\n        if (ENABLE_EXTRA_SECURITY_HOOKS) {\n            this._sanitizer = undefined;\n        }\n    }\n    get tagName() {\n        return this.element.tagName;\n    }\n    /**\n     * Sets the value of this part by resolving the value from possibly multiple\n     * values and static strings and committing it to the DOM.\n     * If this part is single-valued, `this._strings` will be undefined, and the\n     * method will be called with a single value argument. If this part is\n     * multi-value, `this._strings` will be defined, and the method is called\n     * with the value array of the part's owning TemplateInstance, and an offset\n     * into the value array from which the values should be read.\n     * This method is overloaded this way to eliminate short-lived array slices\n     * of the template instance values, and allow a fast-path for single-valued\n     * parts.\n     *\n     * @param value The part value, or an array of values for multi-valued parts\n     * @param valueIndex the index to start reading values from. `undefined` for\n     *   single-valued parts\n     * @param noCommit causes the part to not commit its value to the DOM. Used\n     *   in hydration to prime attribute parts with their first-rendered value,\n     *   but not set the attribute, and in SSR to no-op the DOM operation and\n     *   capture the value for serialization.\n     *\n     * @internal\n     */\n    _$setValue(value, directiveParent = this, valueIndex, noCommit) {\n        const strings = this.strings;\n        // Whether any of the values has changed, for dirty-checking\n        let change = false;\n        if (strings === undefined) {\n            // Single-value binding case\n            value = resolveDirective(this, value, directiveParent, 0);\n            change =\n                !isPrimitive(value) ||\n                    (value !== this._$committedValue && value !== noChange);\n            if (change) {\n                this._$committedValue = value;\n            }\n        }\n        else {\n            // Interpolation case\n            const values = value;\n            value = strings[0];\n            let i, v;\n            for (i = 0; i < strings.length - 1; i++) {\n                v = resolveDirective(this, values[valueIndex + i], directiveParent, i);\n                if (v === noChange) {\n                    // If the user-provided value is `noChange`, use the previous value\n                    v = this._$committedValue[i];\n                }\n                change || (change = !isPrimitive(v) || v !== this._$committedValue[i]);\n                if (v === nothing) {\n                    value = nothing;\n                }\n                else if (value !== nothing) {\n                    value += (v !== null && v !== void 0 ? v : '') + strings[i + 1];\n                }\n                // We always record each value, even if one is `nothing`, for future\n                // change detection.\n                this._$committedValue[i] = v;\n            }\n        }\n        if (change && !noCommit) {\n            this._commitValue(value);\n        }\n    }\n    /** @internal */\n    _commitValue(value) {\n        if (value === nothing) {\n            wrap(this.element).removeAttribute(this.name);\n        }\n        else {\n            if (ENABLE_EXTRA_SECURITY_HOOKS) {\n                if (this._sanitizer === undefined) {\n                    this._sanitizer = sanitizerFactoryInternal(this.element, this.name, 'attribute');\n                }\n                value = this._sanitizer(value !== null && value !== void 0 ? value : '');\n            }\n            wrap(this.element).setAttribute(this.name, (value !== null && value !== void 0 ? value : ''));\n        }\n    }\n}\nclass PropertyPart extends AttributePart {\n    constructor() {\n        super(...arguments);\n        this.type = PROPERTY_PART;\n    }\n    /** @internal */\n    _commitValue(value) {\n        if (ENABLE_EXTRA_SECURITY_HOOKS) {\n            if (this._sanitizer === undefined) {\n                this._sanitizer = sanitizerFactoryInternal(this.element, this.name, 'property');\n            }\n            value = this._sanitizer(value);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this.element[this.name] = value === nothing ? undefined : value;\n    }\n}\nclass BooleanAttributePart extends AttributePart {\n    constructor() {\n        super(...arguments);\n        this.type = BOOLEAN_ATTRIBUTE_PART;\n    }\n    /** @internal */\n    _commitValue(value) {\n        if (value && value !== nothing) {\n            wrap(this.element).setAttribute(this.name, '');\n        }\n        else {\n            wrap(this.element).removeAttribute(this.name);\n        }\n    }\n}\nclass EventPart extends AttributePart {\n    constructor() {\n        super(...arguments);\n        this.type = EVENT_PART;\n    }\n    // EventPart does not use the base _$setValue/_resolveValue implementation\n    // since the dirty checking is more complex\n    /** @internal */\n    _$setValue(newListener, directiveParent = this) {\n        var _a;\n        newListener = (_a = resolveDirective(this, newListener, directiveParent, 0)) !== null && _a !== void 0 ? _a : nothing;\n        if (newListener === noChange) {\n            return;\n        }\n        const oldListener = this._$committedValue;\n        // If the new value is nothing or any options change we have to remove the\n        // part as a listener.\n        const shouldRemoveListener = (newListener === nothing && oldListener !== nothing) ||\n            newListener.capture !==\n                oldListener.capture ||\n            newListener.once !==\n                oldListener.once ||\n            newListener.passive !==\n                oldListener.passive;\n        // If the new value is not nothing and we removed the listener, we have\n        // to add the part as a listener.\n        const shouldAddListener = newListener !== nothing &&\n            (oldListener === nothing || shouldRemoveListener);\n        if (shouldRemoveListener) {\n            this.element.removeEventListener(this.name, this, oldListener);\n        }\n        if (shouldAddListener) {\n            // Beware: IE11 and Chrome 41 don't like using the listener as the\n            // options object. Figure out how to deal w/ this in IE11 - maybe\n            // patch addEventListener?\n            this.element.addEventListener(this.name, this, newListener);\n        }\n        this._$committedValue = newListener;\n    }\n    handleEvent(event) {\n        var _a, _b;\n        if (typeof this._$committedValue === 'function') {\n            // TODO (justinfagnani): do we need to default to this.element?\n            // It'll always be the same as `e.currentTarget`.\n            this._$committedValue.call((_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.host) !== null && _b !== void 0 ? _b : this.element, event);\n        }\n        else {\n            this._$committedValue.handleEvent(event);\n        }\n    }\n}\nclass ElementPart {\n    constructor(element, parent, options) {\n        this.element = element;\n        this.type = ELEMENT_PART;\n        /** @internal */\n        this._$disconnectableChildren = undefined;\n        /** @internal */\n        this._setDirectiveConnected = undefined;\n        this._$parent = parent;\n        this.options = options;\n    }\n    _$setValue(value) {\n        resolveDirective(this, value);\n    }\n}\n/**\n * END USERS SHOULD NOT RELY ON THIS OBJECT.\n *\n * Private exports for use by other Lit packages, not intended for use by\n * external users.\n *\n * We currently do not make a mangled rollup build of the lit-ssr code. In order\n * to keep a number of (otherwise private) top-level exports  mangled in the\n * client side code, we export a _Σ object containing those members (or\n * helper methods for accessing private fields of those members), and then\n * re-export them for use in lit-ssr. This keeps lit-ssr agnostic to whether the\n * client-side code is being used in `dev` mode or `prod` mode.\n *\n * This has a unique name, to disambiguate it from private exports in\n * lit-element, which re-exports all of lit-html.\n *\n * @private\n */\nexport const _Σ = {\n    // Used in lit-ssr\n    _boundAttributeSuffix: boundAttributeSuffix,\n    _marker: marker,\n    _markerMatch: markerMatch,\n    _HTML_RESULT: HTML_RESULT,\n    _getTemplateHtml: getTemplateHtml,\n    // Used in hydrate\n    _TemplateInstance: TemplateInstance,\n    _isIterable: isIterable,\n    _resolveDirective: resolveDirective,\n    // Used in tests and private-ssr-support\n    _ChildPart: ChildPart,\n    _AttributePart: AttributePart,\n    _BooleanAttributePart: BooleanAttributePart,\n    _EventPart: EventPart,\n    _PropertyPart: PropertyPart,\n    _ElementPart: ElementPart,\n};\n// Apply polyfills if available\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n(_d = (_c = globalThis)['litHtmlPlatformSupport']) === null || _d === void 0 ? void 0 : _d.call(_c, Template, ChildPart);\n// IMPORTANT: do not change the property name or the assignment expression.\n// This line will be used in regexes to search for lit-html usage.\n// TODO(justinfagnani): inject version number at build time\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n((_e = (_f = globalThis)['litHtmlVersions']) !== null && _e !== void 0 ? _e : (_f['litHtmlVersions'] = [])).push('2.0.0-rc.3');\n//# sourceMappingURL=lit-html.js.map","export*from\"@lit/reactive-element/decorators/custom-element.js\";export*from\"@lit/reactive-element/decorators/property.js\";export*from\"@lit/reactive-element/decorators/state.js\";export*from\"@lit/reactive-element/decorators/event-options.js\";export*from\"@lit/reactive-element/decorators/query.js\";export*from\"@lit/reactive-element/decorators/query-all.js\";export*from\"@lit/reactive-element/decorators/query-async.js\";export*from\"@lit/reactive-element/decorators/query-assigned-nodes.js\";\n//# sourceMappingURL=decorators.js.map\n","import\"@lit/reactive-element\";import\"lit-html\";export*from\"lit-element/lit-element.js\";\n//# sourceMappingURL=index.js.map\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { Projects, defineComponent } from '@piyoppi/pico2map-ui-components';\nimport { TiledMap, MapChipImage } from '@piyoppi/pico2map-tiled';\n// Define some custom elements\ndefineComponent();\n// Map size is 15 x 10, MapChip size is 32 x 32px\nconst tiledMap = new TiledMap(15, 10, 32, 32);\n// MapChip image (using 'chip.png' and chipId = 1)\nconst mapChipImage = new MapChipImage(\"images/chip.png\", 1);\nconst init = async () => {\n    await mapChipImage.waitWhileLoading();\n    tiledMap.mapChipsCollection.push(mapChipImage);\n    // Attach tiledMap to project(projectId: 1)\n    Projects.add(tiledMap, 1);\n};\ninit();\n"],"names":[],"sourceRoot":""}