/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./simple_map_editor/src/simple_map_editor.ts":
/*!****************************************************!*\
  !*** ./simple_map_editor/src/simple_map_editor.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _piyoppi_pico2map_ui_components__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @piyoppi/pico2map-ui-components */ \"../map-editor-components/dist/main.js\");\n/* harmony import */ var _piyoppi_pico2map_ui_components__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_piyoppi_pico2map_ui_components__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _piyoppi_pico2map_tiled__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @piyoppi/pico2map-tiled */ \"../tiled-map/dist/main.js\");\n/* harmony import */ var _piyoppi_pico2map_tiled__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_piyoppi_pico2map_tiled__WEBPACK_IMPORTED_MODULE_1__);\n\n\n// Define some custom elements\n(0,_piyoppi_pico2map_ui_components__WEBPACK_IMPORTED_MODULE_0__.defineComponent)();\n// Get some elements\nconst mapCanvas = document.getElementById('mapCanvas');\nconst coliderCanvas = document.getElementById('coliderCanvas');\nconst mapChipSelector = document.getElementById('mapChipSelector');\nconst autoTileSelector = document.getElementById('autoTileSelector');\nconst loadButton = document.getElementById('load');\nconst saveButton = document.getElementById('save');\nconst addLayerButton = document.getElementById('addlayer');\nconst rectangleRadioButton = document.getElementById('rectangle');\nconst eraseRadioButton = document.getElementById('erase');\nconst penRadioButton = document.getElementById('pen');\nconst mapChipModeRadioButton = document.getElementById('mapChipMode');\nconst coliderModeRadioButton = document.getElementById('coliderMode');\nconst coliderGroup = document.getElementById('coliderGroup');\nconst coliderTypeNoneRadioButton = document.getElementById('coliderTypeNone');\nconst coliderTypeColiderRadioButton = document.getElementById('coliderTypeColider');\nconst layerSelector = document.getElementById('layer');\ncoliderCanvas.style.display = 'none';\nfunction setProjectId(id) {\n    mapChipSelector.setAttribute('projectId', id.toString());\n    autoTileSelector.setAttribute('projectId', id.toString());\n    mapCanvas.setAttribute('projectId', id.toString());\n    coliderCanvas.setAttribute('projectId', id.toString());\n}\nasync function initialize() {\n    const mapChipImage = new _piyoppi_pico2map_tiled__WEBPACK_IMPORTED_MODULE_1__.MapChipImage(\"images/chip.png\", 1);\n    const autoTileImage = new _piyoppi_pico2map_tiled__WEBPACK_IMPORTED_MODULE_1__.MapChipImage(\"images/auto-tile-sample.png\", 2);\n    await mapChipImage.waitWhileLoading();\n    await autoTileImage.waitWhileLoading();\n    const chipSize = { width: 32, height: 32 };\n    let tiledMap = new _piyoppi_pico2map_tiled__WEBPACK_IMPORTED_MODULE_1__.TiledMap(30, 30, chipSize.width, chipSize.height);\n    tiledMap.addLayer();\n    tiledMap.addLayer();\n    // import MapChipImage and setup AutoTiles\n    tiledMap.mapChipsCollection.push(mapChipImage);\n    tiledMap.mapChipsCollection.push(autoTileImage);\n    tiledMap.autoTiles.import(new _piyoppi_pico2map_tiled__WEBPACK_IMPORTED_MODULE_1__.DefaultAutoTileImportStrategy(autoTileImage, chipSize.width, chipSize.height));\n    const project = _piyoppi_pico2map_ui_components__WEBPACK_IMPORTED_MODULE_0__.Projects.add(tiledMap);\n    setProjectId(project.projectId);\n    // Deserialze a data\n    loadButton.onclick = async () => {\n        const serializedData = localStorage.getItem('mapData');\n        if (!serializedData)\n            return;\n        tiledMap = _piyoppi_pico2map_tiled__WEBPACK_IMPORTED_MODULE_1__.TiledMap.fromObject(JSON.parse(serializedData));\n        // The image needs to be set again\n        tiledMap.mapChipsCollection.push(mapChipImage);\n        tiledMap.mapChipsCollection.push(autoTileImage);\n        const newProject = _piyoppi_pico2map_ui_components__WEBPACK_IMPORTED_MODULE_0__.Projects.add(tiledMap);\n        setProjectId(newProject.projectId);\n        layerSelector.innerHTML = '';\n        tiledMap.datas.forEach((_, index) => layerSelector.appendChild(new Option(index.toString(), index.toString())));\n    };\n    // Serialize a tiled-map data and set to the localStorage\n    saveButton.onclick = () => localStorage.setItem('mapData', JSON.stringify(tiledMap.toObject()));\n    // Set a pen\n    rectangleRadioButton.addEventListener('change', () => {\n        mapCanvas.setAttribute('brush', 'RectangleBrush');\n        coliderCanvas.setAttribute('brush', 'RectangleBrush');\n    });\n    penRadioButton.addEventListener('change', () => {\n        mapCanvas.setAttribute('brush', 'Pen');\n        coliderCanvas.setAttribute('brush', 'Pen');\n    });\n    // Set eraser arrangement\n    // DefaultEraseArrangement put empty MapChips.\n    eraseRadioButton.addEventListener('change', () => mapCanvas.setAttribute('arrangement', 'DefaultEraseArrangement'));\n    mapChipModeRadioButton.addEventListener('change', _ => {\n        // Set arrangement map-chips mode\n        coliderCanvas.style.display = 'none';\n        mapCanvas.removeAttribute('cursorHidden');\n        coliderGroup.style.display = coliderModeRadioButton.checked ? 'block' : 'none';\n    });\n    coliderModeRadioButton?.addEventListener('change', _ => {\n        // Set colider-edit mode\n        coliderCanvas.style.display = 'block';\n        mapCanvas.setAttribute('cursorHidden', 'true');\n        coliderGroup.style.display = coliderModeRadioButton.checked ? 'block' : 'none';\n    });\n    // Set an active colider type\n    coliderTypeNoneRadioButton.addEventListener('change', () => {\n        coliderCanvas?.setAttribute('coliderType', '0');\n        coliderCanvas?.setAttribute('subColiderType', '1');\n    });\n    coliderTypeColiderRadioButton.addEventListener('change', () => {\n        coliderCanvas?.setAttribute('coliderType', '1');\n        coliderCanvas?.setAttribute('subColiderType', '0');\n    });\n    autoTileSelector.addEventListener('autotile-selected', (e) => {\n        // Set a AutoTileArrangement.\n        // AutoTileArrangement arranges appropriate MapChips.\n        mapCanvas.setAttribute('arrangement', 'AutoTileArrangement');\n        mapCanvas.setAttribute('brush', 'RectangleBrush');\n        // Set an active AutoTile\n        mapCanvas.setAttribute('autoTileId', e.detail.id.toString());\n        rectangleRadioButton.checked = true;\n    });\n    mapChipSelector.addEventListener('mapchip-selected', (e) => {\n        // Set an active MapChip\n        mapCanvas.setAttribute('arrangement', 'DefaultArrangement');\n        mapCanvas.setAttribute('mapChipFragmentProperties', JSON.stringify(e.detail.selectedMapChipProperties));\n    });\n    mapCanvas.addEventListener('mapchip-picked', e => {\n        mapCanvas.setAttribute('arrangement', (0,_piyoppi_pico2map_ui_components__WEBPACK_IMPORTED_MODULE_0__.PickedArrangementSelector)(e.detail));\n    });\n    layerSelector.addEventListener('change', e => {\n        if (!(e.target instanceof HTMLSelectElement))\n            return;\n        mapCanvas.setAttribute('activeLayer', e.target.value);\n    });\n    addLayerButton.addEventListener('click', () => {\n        tiledMap.addLayer();\n        const currentLayerIndex = tiledMap.datas.length - 1;\n        layerSelector.appendChild(new Option(currentLayerIndex.toString(), currentLayerIndex.toString()));\n    });\n    penRadioButton.checked = true;\n}\ninitialize();\n\n\n//# sourceURL=webpack://@piyoppi/pico2map-samples/./simple_map_editor/src/simple_map_editor.ts?");

/***/ }),

/***/ "../map-editor-components/dist/main.js":
/*!*********************************************!*\
  !*** ../map-editor-components/dist/main.js ***!
  \*********************************************/
/***/ ((module) => {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(self, function() {\nreturn /******/ (() => { // webpackBootstrap\n/******/ \tvar __webpack_modules__ = ([\n/* 0 */,\n/* 1 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_519__) => {\n\n\"use strict\";\n__nested_webpack_require_519__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_519__.d(__webpack_exports__, {\n/* harmony export */   \"MapChipSelectorComponent\": () => (/* binding */ MapChipSelectorComponent)\n/* harmony export */ });\n/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_519__(2);\n/* harmony import */ var lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_519__(7);\n/* harmony import */ var _piyoppi_pico2map_editor__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_519__(17);\n/* harmony import */ var _piyoppi_pico2map_editor__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__nested_webpack_require_519__.n(_piyoppi_pico2map_editor__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _Helpers_CursorPositionCalculator__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_519__(18);\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\nclass MapChipSelectorComponent extends lit__WEBPACK_IMPORTED_MODULE_0__.LitElement {\n    constructor() {\n        super(...arguments);\n        this._gridImageSrc = '';\n        this.gridImageGenerator = new _piyoppi_pico2map_editor__WEBPACK_IMPORTED_MODULE_2__.GridImageGenerator();\n        this.cursorPositionCalculator = new _Helpers_CursorPositionCalculator__WEBPACK_IMPORTED_MODULE_3__.CursorPositionCalculator();\n        this._project = null;\n        this._mapChipSelector = null;\n        this._imageSrc = '';\n        this._afterReplacedMapChipImageCallbackItem = null;\n        this._projectId = -1;\n        this._chipId = -1;\n        this.cursorChipX = 0;\n        this.cursorChipY = 0;\n        this.selectedX = 0;\n        this.selectedY = 0;\n        this.selectedWidth = 0;\n        this.selectedHeight = 0;\n    }\n    get gridColor() {\n        return this.gridImageGenerator.gridColor;\n    }\n    set gridColor(value) {\n        const oldValue = this.gridImageGenerator.gridColor;\n        this.gridImageGenerator.gridColor = value;\n        this.requestUpdate('gridColor', oldValue);\n    }\n    get projectId() {\n        return this._projectId;\n    }\n    set projectId(value) {\n        const oldValue = this._projectId;\n        this._projectId = value;\n        this._setupProject();\n        if (this._project) {\n            this.setupMapChipSelector();\n        }\n        else {\n            this.reset();\n        }\n        this.requestUpdate('projectId', oldValue);\n    }\n    get chipId() {\n        return this._chipId;\n    }\n    set chipId(value) {\n        const oldValue = this._chipId;\n        this._chipId = value;\n        this.setupMapChipSelector();\n        this.requestUpdate('chipId', oldValue);\n    }\n    get mapChipSelector() {\n        if (!this._mapChipSelector)\n            throw new Error('The project is not set');\n        return this._mapChipSelector;\n    }\n    get gridWidth() {\n        var _a;\n        return ((_a = this._project) === null || _a === void 0 ? void 0 : _a.tiledMap.chipWidth) || 0;\n    }\n    get gridHeight() {\n        var _a;\n        return ((_a = this._project) === null || _a === void 0 ? void 0 : _a.tiledMap.chipHeight) || 0;\n    }\n    get cursorPosition() {\n        return {\n            x: this.cursorChipX * this.gridWidth,\n            y: this.cursorChipY * this.gridHeight\n        };\n    }\n    get subscribedProjectEvent() {\n        return !!this._afterReplacedMapChipImageCallbackItem;\n    }\n    _setupProject() {\n        this._project = _piyoppi_pico2map_editor__WEBPACK_IMPORTED_MODULE_2__.Projects.fromProjectId(this._projectId);\n        if (!this._project)\n            return;\n        this._subscribeProjectEvent();\n    }\n    _subscribeProjectEvent() {\n        if (!this._project || this._afterReplacedMapChipImageCallbackItem)\n            return;\n        this._afterReplacedMapChipImageCallbackItem = this._project.setCallback('afterReplacedMapChipImage', () => this.setupMapChipSelector());\n    }\n    _unsubscribeProjectEvent() {\n        if (!this._project)\n            return;\n        if (this._afterReplacedMapChipImageCallbackItem)\n            this._project.removeCallback('afterReplacedMapChipImage', this._afterReplacedMapChipImageCallbackItem);\n        this._afterReplacedMapChipImageCallbackItem = null;\n    }\n    setupMapChipSelector() {\n        if (!this._project)\n            return;\n        const chipImage = this._project.tiledMap.mapChipsCollection.findById(this._chipId);\n        if (!chipImage) {\n            this.reset();\n            return;\n        }\n        this._mapChipSelector = new _piyoppi_pico2map_editor__WEBPACK_IMPORTED_MODULE_2__.MapChipSelector(this._project.tiledMap, chipImage);\n        this._imageSrc = this._mapChipSelector.chipImage.src;\n        this.requestUpdate();\n    }\n    reset() {\n        this._mapChipSelector = null;\n        this._imageSrc = '';\n    }\n    mouseUp(e) {\n        const mouseCursorPosition = this.cursorPositionCalculator.getMouseCursorPosition(e.pageX, e.pageY);\n        this.mapChipSelector.mouseUp(mouseCursorPosition.x, mouseCursorPosition.y);\n        const selectedChips = this.mapChipSelector.selectedChips;\n        this.dispatchEvent(new CustomEvent('mapchip-selected', {\n            detail: { selectedMapChipProperties: selectedChips.map(chip => chip.toObject()) },\n            bubbles: true,\n            composed: true\n        }));\n        this.syncSelectedCursor();\n    }\n    mouseMove(e) {\n        const mouseCursorPosition = this.cursorPositionCalculator.getMouseCursorPosition(e.pageX, e.pageY);\n        this.mapChipSelector.mouseMove(mouseCursorPosition.x, mouseCursorPosition.y);\n        this.syncSelectedCursor();\n        const chip = this.mapChipSelector.convertFromImagePositionToChipPosition(mouseCursorPosition.x, mouseCursorPosition.y);\n        this.cursorChipX = chip.x;\n        this.cursorChipY = chip.y;\n    }\n    mouseDown(e) {\n        const mouseCursorPosition = this.cursorPositionCalculator.getMouseCursorPosition(e.pageX, e.pageY);\n        this.mapChipSelector.mouseDown(mouseCursorPosition.x, mouseCursorPosition.y);\n        this.syncSelectedCursor();\n    }\n    syncSelectedCursor() {\n        if (!this.mapChipSelector.selecting)\n            return;\n        const startPosition = this.mapChipSelector.startPosition;\n        const selectedSize = this.mapChipSelector.selectedSize;\n        this.selectedX = startPosition.x;\n        this.selectedY = startPosition.y;\n        this.selectedWidth = selectedSize.width;\n        this.selectedHeight = selectedSize.height;\n    }\n    firstUpdated() {\n        var _a;\n        const element = (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.getElementById('boundary');\n        if (element)\n            this.cursorPositionCalculator.setElement(element);\n    }\n    render() {\n        var _a, _b;\n        this.gridImageGenerator.setGridSize(this.gridWidth, this.gridHeight);\n        if (this.gridImageGenerator.changed) {\n            this._gridImageSrc = this.gridImageGenerator.generateLinePart().toDataURL();\n        }\n        return lit__WEBPACK_IMPORTED_MODULE_0__.html `\n      <style>\n        .grid {\n          background-image: url(\"${this._gridImageSrc}\");\n          width: ${((_a = this._mapChipSelector) === null || _a === void 0 ? void 0 : _a.chipImage.image.width) || 0}px;\n          height: ${((_b = this._mapChipSelector) === null || _b === void 0 ? void 0 : _b.chipImage.image.height) || 0}px;\n        }\n\n        .cursor {\n          width: ${this.gridWidth}px;\n          height: ${this.gridHeight}px;\n          left: ${this.cursorPosition.x}px;\n          top: ${this.cursorPosition.y}px;\n        }\n\n        .selected {\n          width: ${this.selectedWidth}px;\n          height: ${this.selectedHeight}px;\n          left: ${this.selectedX}px;\n          top: ${this.selectedY}px;\n        }\n      </style>\n\n      <div id=\"boundary\">\n        <img id=\"chip-image\" src=\"${this._imageSrc}\">\n        <div\n          class=\"grid-image grid\"\n          @mousemove=\"${(e) => this.mouseMove(e)}\"\n          @mousedown=\"${(e) => this.mouseDown(e)}\"\n          @mouseup=\"${(e) => this.mouseUp(e)}\"\n        ></div>\n        ${this._imageSrc ? lit__WEBPACK_IMPORTED_MODULE_0__.html `<div class=\"cursor\"></div>` : null}\n        ${(this._imageSrc && this.selectedWidth > 0 && this.selectedHeight > 0) ? lit__WEBPACK_IMPORTED_MODULE_0__.html `<div class=\"selected\"></div>` : null}\n      </div>\n    `;\n    }\n    static get styles() {\n        return lit__WEBPACK_IMPORTED_MODULE_0__.css `\n      .grid-image {\n        position: absolute;\n        top: 0;\n        left: 0;\n        background-repeat: repeat;\n      }\n\n      .cursor, .selected {\n        position: absolute;\n        border-style: solid;\n        box-sizing: border-box;\n      }\n\n      .cursor {\n        border-color: red;\n        pointer-events: none;\n      }\n\n      .selected {\n        border-color: blue;\n        pointer-events: none;\n      }\n\n      #boundary {\n        position: relative;\n      }\n\n      #chip-image {\n        display: block;\n        user-select: none;\n      }\n    `;\n    }\n    disconnectedCallback() {\n        super.disconnectedCallback();\n        this._unsubscribeProjectEvent();\n    }\n    connectedCallback() {\n        super.connectedCallback();\n        this._subscribeProjectEvent();\n    }\n}\n__decorate([\n    (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({ type: String })\n], MapChipSelectorComponent.prototype, \"gridColor\", null);\n__decorate([\n    (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({ type: Number })\n], MapChipSelectorComponent.prototype, \"projectId\", null);\n__decorate([\n    (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({ type: Number })\n], MapChipSelectorComponent.prototype, \"chipId\", null);\n__decorate([\n    (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({ type: Number })\n], MapChipSelectorComponent.prototype, \"cursorChipX\", void 0);\n__decorate([\n    (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({ type: Number })\n], MapChipSelectorComponent.prototype, \"cursorChipY\", void 0);\n__decorate([\n    (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({ type: Number })\n], MapChipSelectorComponent.prototype, \"selectedX\", void 0);\n__decorate([\n    (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({ type: Number })\n], MapChipSelectorComponent.prototype, \"selectedY\", void 0);\n__decorate([\n    (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({ type: Number })\n], MapChipSelectorComponent.prototype, \"selectedWidth\", void 0);\n__decorate([\n    (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({ type: Number })\n], MapChipSelectorComponent.prototype, \"selectedHeight\", void 0);\n\n\n/***/ }),\n/* 2 */\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __nested_webpack_require_11700__) => {\n\n\"use strict\";\n__nested_webpack_require_11700__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_11700__.d(__webpack_exports__, {\n/* harmony export */   \"CSSResult\": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.CSSResult),\n/* harmony export */   \"LitElement\": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.LitElement),\n/* harmony export */   \"ReactiveElement\": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.ReactiveElement),\n/* harmony export */   \"UpdatingElement\": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.UpdatingElement),\n/* harmony export */   \"_Σ\": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__[\"_Σ\"]),\n/* harmony export */   \"_Φ\": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__[\"_Φ\"]),\n/* harmony export */   \"adoptStyles\": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.adoptStyles),\n/* harmony export */   \"css\": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.css),\n/* harmony export */   \"defaultConverter\": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.defaultConverter),\n/* harmony export */   \"getCompatibleStyle\": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.getCompatibleStyle),\n/* harmony export */   \"html\": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.html),\n/* harmony export */   \"noChange\": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.noChange),\n/* harmony export */   \"notEqual\": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.notEqual),\n/* harmony export */   \"nothing\": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.nothing),\n/* harmony export */   \"render\": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.render),\n/* harmony export */   \"supportsAdoptingStyleSheets\": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.supportsAdoptingStyleSheets),\n/* harmony export */   \"svg\": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.svg),\n/* harmony export */   \"unsafeCSS\": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.unsafeCSS)\n/* harmony export */ });\n/* harmony import */ var _lit_reactive_element__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_11700__(3);\n/* harmony import */ var lit_html__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_11700__(5);\n/* harmony import */ var lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_11700__(6);\n\n//# sourceMappingURL=index.js.map\n\n\n/***/ }),\n/* 3 */\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __nested_webpack_require_14680__) => {\n\n\"use strict\";\n__nested_webpack_require_14680__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_14680__.d(__webpack_exports__, {\n/* harmony export */   \"CSSResult\": () => (/* reexport safe */ _css_tag_js__WEBPACK_IMPORTED_MODULE_0__.CSSResult),\n/* harmony export */   \"adoptStyles\": () => (/* reexport safe */ _css_tag_js__WEBPACK_IMPORTED_MODULE_0__.adoptStyles),\n/* harmony export */   \"css\": () => (/* reexport safe */ _css_tag_js__WEBPACK_IMPORTED_MODULE_0__.css),\n/* harmony export */   \"getCompatibleStyle\": () => (/* reexport safe */ _css_tag_js__WEBPACK_IMPORTED_MODULE_0__.getCompatibleStyle),\n/* harmony export */   \"supportsAdoptingStyleSheets\": () => (/* reexport safe */ _css_tag_js__WEBPACK_IMPORTED_MODULE_0__.supportsAdoptingStyleSheets),\n/* harmony export */   \"unsafeCSS\": () => (/* reexport safe */ _css_tag_js__WEBPACK_IMPORTED_MODULE_0__.unsafeCSS),\n/* harmony export */   \"ReactiveElement\": () => (/* binding */ a),\n/* harmony export */   \"defaultConverter\": () => (/* binding */ o),\n/* harmony export */   \"notEqual\": () => (/* binding */ n)\n/* harmony export */ });\n/* harmony import */ var _css_tag_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_14680__(4);\n\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */var s,e,h,r;const o={toAttribute(t,i){switch(i){case Boolean:t=t?\"\":null;break;case Object:case Array:t=null==t?t:JSON.stringify(t)}return t},fromAttribute(t,i){let s=t;switch(i){case Boolean:s=null!==t;break;case Number:s=null===t?null:Number(t);break;case Object:case Array:try{s=JSON.parse(t)}catch(t){s=null}}return s}},n=(t,i)=>i!==t&&(i==i||t==t),l={attribute:!0,type:String,converter:o,reflect:!1,hasChanged:n};class a extends HTMLElement{constructor(){super(),this.Πi=new Map,this.Πo=void 0,this.Πl=void 0,this.isUpdatePending=!1,this.hasUpdated=!1,this.Πh=null,this.u()}static addInitializer(t){var i;null!==(i=this.v)&&void 0!==i||(this.v=[]),this.v.push(t)}static get observedAttributes(){this.finalize();const t=[];return this.elementProperties.forEach(((i,s)=>{const e=this.Πp(s,i);void 0!==e&&(this.Πm.set(e,s),t.push(e))})),t}static createProperty(t,i=l){if(i.state&&(i.attribute=!1),this.finalize(),this.elementProperties.set(t,i),!i.noAccessor&&!this.prototype.hasOwnProperty(t)){const s=\"symbol\"==typeof t?Symbol():\"__\"+t,e=this.getPropertyDescriptor(t,s,i);void 0!==e&&Object.defineProperty(this.prototype,t,e)}}static getPropertyDescriptor(t,i,s){return{get(){return this[i]},set(e){const h=this[t];this[i]=e,this.requestUpdate(t,h,s)},configurable:!0,enumerable:!0}}static getPropertyOptions(t){return this.elementProperties.get(t)||l}static finalize(){if(this.hasOwnProperty(\"finalized\"))return!1;this.finalized=!0;const t=Object.getPrototypeOf(this);if(t.finalize(),this.elementProperties=new Map(t.elementProperties),this.Πm=new Map,this.hasOwnProperty(\"properties\")){const t=this.properties,i=[...Object.getOwnPropertyNames(t),...Object.getOwnPropertySymbols(t)];for(const s of i)this.createProperty(s,t[s])}return this.elementStyles=this.finalizeStyles(this.styles),!0}static finalizeStyles(i){const s=[];if(Array.isArray(i)){const e=new Set(i.flat(1/0).reverse());for(const i of e)s.unshift((0,_css_tag_js__WEBPACK_IMPORTED_MODULE_0__.getCompatibleStyle)(i))}else void 0!==i&&s.push((0,_css_tag_js__WEBPACK_IMPORTED_MODULE_0__.getCompatibleStyle)(i));return s}static Πp(t,i){const s=i.attribute;return!1===s?void 0:\"string\"==typeof s?s:\"string\"==typeof t?t.toLowerCase():void 0}u(){var t;this.Πg=new Promise((t=>this.enableUpdating=t)),this.L=new Map,this.Π_(),this.requestUpdate(),null===(t=this.constructor.v)||void 0===t||t.forEach((t=>t(this)))}addController(t){var i,s;(null!==(i=this.ΠU)&&void 0!==i?i:this.ΠU=[]).push(t),void 0!==this.renderRoot&&this.isConnected&&(null===(s=t.hostConnected)||void 0===s||s.call(t))}removeController(t){var i;null===(i=this.ΠU)||void 0===i||i.splice(this.ΠU.indexOf(t)>>>0,1)}Π_(){this.constructor.elementProperties.forEach(((t,i)=>{this.hasOwnProperty(i)&&(this.Πi.set(i,this[i]),delete this[i])}))}createRenderRoot(){var t;const s=null!==(t=this.shadowRoot)&&void 0!==t?t:this.attachShadow(this.constructor.shadowRootOptions);return (0,_css_tag_js__WEBPACK_IMPORTED_MODULE_0__.adoptStyles)(s,this.constructor.elementStyles),s}connectedCallback(){var t;void 0===this.renderRoot&&(this.renderRoot=this.createRenderRoot()),this.enableUpdating(!0),null===(t=this.ΠU)||void 0===t||t.forEach((t=>{var i;return null===(i=t.hostConnected)||void 0===i?void 0:i.call(t)})),this.Πl&&(this.Πl(),this.Πo=this.Πl=void 0)}enableUpdating(t){}disconnectedCallback(){var t;null===(t=this.ΠU)||void 0===t||t.forEach((t=>{var i;return null===(i=t.hostDisconnected)||void 0===i?void 0:i.call(t)})),this.Πo=new Promise((t=>this.Πl=t))}attributeChangedCallback(t,i,s){this.K(t,s)}Πj(t,i,s=l){var e,h;const r=this.constructor.Πp(t,s);if(void 0!==r&&!0===s.reflect){const n=(null!==(h=null===(e=s.converter)||void 0===e?void 0:e.toAttribute)&&void 0!==h?h:o.toAttribute)(i,s.type);this.Πh=t,null==n?this.removeAttribute(r):this.setAttribute(r,n),this.Πh=null}}K(t,i){var s,e,h;const r=this.constructor,n=r.Πm.get(t);if(void 0!==n&&this.Πh!==n){const t=r.getPropertyOptions(n),l=t.converter,a=null!==(h=null!==(e=null===(s=l)||void 0===s?void 0:s.fromAttribute)&&void 0!==e?e:\"function\"==typeof l?l:null)&&void 0!==h?h:o.fromAttribute;this.Πh=n,this[n]=a(i,t.type),this.Πh=null}}requestUpdate(t,i,s){let e=!0;void 0!==t&&(((s=s||this.constructor.getPropertyOptions(t)).hasChanged||n)(this[t],i)?(this.L.has(t)||this.L.set(t,i),!0===s.reflect&&this.Πh!==t&&(void 0===this.Πk&&(this.Πk=new Map),this.Πk.set(t,s))):e=!1),!this.isUpdatePending&&e&&(this.Πg=this.Πq())}async Πq(){this.isUpdatePending=!0;try{for(await this.Πg;this.Πo;)await this.Πo}catch(t){Promise.reject(t)}const t=this.performUpdate();return null!=t&&await t,!this.isUpdatePending}performUpdate(){var t;if(!this.isUpdatePending)return;this.hasUpdated,this.Πi&&(this.Πi.forEach(((t,i)=>this[i]=t)),this.Πi=void 0);let i=!1;const s=this.L;try{i=this.shouldUpdate(s),i?(this.willUpdate(s),null===(t=this.ΠU)||void 0===t||t.forEach((t=>{var i;return null===(i=t.hostUpdate)||void 0===i?void 0:i.call(t)})),this.update(s)):this.Π$()}catch(t){throw i=!1,this.Π$(),t}i&&this.E(s)}willUpdate(t){}E(t){var i;null===(i=this.ΠU)||void 0===i||i.forEach((t=>{var i;return null===(i=t.hostUpdated)||void 0===i?void 0:i.call(t)})),this.hasUpdated||(this.hasUpdated=!0,this.firstUpdated(t)),this.updated(t)}Π$(){this.L=new Map,this.isUpdatePending=!1}get updateComplete(){return this.getUpdateComplete()}getUpdateComplete(){return this.Πg}shouldUpdate(t){return!0}update(t){void 0!==this.Πk&&(this.Πk.forEach(((t,i)=>this.Πj(i,this[i],t))),this.Πk=void 0),this.Π$()}updated(t){}firstUpdated(t){}}a.finalized=!0,a.elementProperties=new Map,a.elementStyles=[],a.shadowRootOptions={mode:\"open\"},null===(e=(s=globalThis).reactiveElementPlatformSupport)||void 0===e||e.call(s,{ReactiveElement:a}),(null!==(h=(r=globalThis).reactiveElementVersions)&&void 0!==h?h:r.reactiveElementVersions=[]).push(\"1.0.0-rc.2\");\n//# sourceMappingURL=reactive-element.js.map\n\n\n/***/ }),\n/* 4 */\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __nested_webpack_require_21905__) => {\n\n\"use strict\";\n__nested_webpack_require_21905__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_21905__.d(__webpack_exports__, {\n/* harmony export */   \"CSSResult\": () => (/* binding */ s),\n/* harmony export */   \"adoptStyles\": () => (/* binding */ S),\n/* harmony export */   \"css\": () => (/* binding */ i),\n/* harmony export */   \"getCompatibleStyle\": () => (/* binding */ u),\n/* harmony export */   \"supportsAdoptingStyleSheets\": () => (/* binding */ t),\n/* harmony export */   \"unsafeCSS\": () => (/* binding */ r)\n/* harmony export */ });\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nconst t=window.ShadowRoot&&(void 0===window.ShadyCSS||window.ShadyCSS.nativeShadow)&&\"adoptedStyleSheets\"in Document.prototype&&\"replace\"in CSSStyleSheet.prototype,e=Symbol();class s{constructor(t,s){if(s!==e)throw Error(\"CSSResult is not constructable. Use `unsafeCSS` or `css` instead.\");this.cssText=t}get styleSheet(){return t&&void 0===this.t&&(this.t=new CSSStyleSheet,this.t.replaceSync(this.cssText)),this.t}toString(){return this.cssText}}const n=new Map,o=t=>{let o=n.get(t);return void 0===o&&n.set(t,o=new s(t,e)),o},r=t=>o(\"string\"==typeof t?t:t+\"\"),i=(t,...e)=>{const n=1===t.length?t[0]:e.reduce(((e,n,o)=>e+(t=>{if(t instanceof s)return t.cssText;if(\"number\"==typeof t)return t;throw Error(\"Value passed to 'css' function must be a 'css' function result: \"+t+\". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.\")})(n)+t[o+1]),t[0]);return o(n)},S=(e,s)=>{t?e.adoptedStyleSheets=s.map((t=>t instanceof CSSStyleSheet?t:t.styleSheet)):s.forEach((t=>{const s=document.createElement(\"style\");s.textContent=t.cssText,e.appendChild(s)}))},u=t?t=>t:t=>t instanceof CSSStyleSheet?(t=>{let e=\"\";for(const s of t.cssRules)e+=s.cssText;return r(e)})(t):t;\n//# sourceMappingURL=css-tag.js.map\n\n\n/***/ }),\n/* 5 */\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __nested_webpack_require_23875__) => {\n\n\"use strict\";\n__nested_webpack_require_23875__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_23875__.d(__webpack_exports__, {\n/* harmony export */   \"_Σ\": () => (/* binding */ Z),\n/* harmony export */   \"html\": () => (/* binding */ T),\n/* harmony export */   \"noChange\": () => (/* binding */ w),\n/* harmony export */   \"nothing\": () => (/* binding */ A),\n/* harmony export */   \"render\": () => (/* binding */ V),\n/* harmony export */   \"svg\": () => (/* binding */ x)\n/* harmony export */ });\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nvar t,i,s,e;const o=globalThis.trustedTypes,l=o?o.createPolicy(\"lit-html\",{createHTML:t=>t}):void 0,n=`lit$${(Math.random()+\"\").slice(9)}$`,h=\"?\"+n,r=`<${h}>`,u=document,c=(t=\"\")=>u.createComment(t),d=t=>null===t||\"object\"!=typeof t&&\"function\"!=typeof t,v=Array.isArray,a=t=>{var i;return v(t)||\"function\"==typeof(null===(i=t)||void 0===i?void 0:i[Symbol.iterator])},f=/<(?:(!--|\\/[^a-zA-Z])|(\\/?[a-zA-Z][^>\\s]*)|(\\/?$))/g,_=/-->/g,m=/>/g,p=/>|[ \t\\n\f\\r](?:([^\\s\"'>=/]+)([ \t\\n\f\\r]*=[ \t\\n\f\\r]*(?:[^ \t\\n\f\\r\"'`<>=]|(\"|')|))|$)/g,$=/'/g,g=/\"/g,y=/^(?:script|style|textarea)$/i,b=t=>(i,...s)=>({_$litType$:t,strings:i,values:s}),T=b(1),x=b(2),w=Symbol.for(\"lit-noChange\"),A=Symbol.for(\"lit-nothing\"),P=new WeakMap,V=(t,i,s)=>{var e,o;const l=null!==(e=null==s?void 0:s.renderBefore)&&void 0!==e?e:i;let n=l._$litPart$;if(void 0===n){const t=null!==(o=null==s?void 0:s.renderBefore)&&void 0!==o?o:null;l._$litPart$=n=new C(i.insertBefore(c(),t),t,void 0,s)}return n.I(t),n},E=u.createTreeWalker(u,129,null,!1),M=(t,i)=>{const s=t.length-1,e=[];let o,h=2===i?\"<svg>\":\"\",u=f;for(let i=0;i<s;i++){const s=t[i];let l,c,d=-1,v=0;for(;v<s.length&&(u.lastIndex=v,c=u.exec(s),null!==c);)v=u.lastIndex,u===f?\"!--\"===c[1]?u=_:void 0!==c[1]?u=m:void 0!==c[2]?(y.test(c[2])&&(o=RegExp(\"</\"+c[2],\"g\")),u=p):void 0!==c[3]&&(u=p):u===p?\">\"===c[0]?(u=null!=o?o:f,d=-1):void 0===c[1]?d=-2:(d=u.lastIndex-c[2].length,l=c[1],u=void 0===c[3]?p:'\"'===c[3]?g:$):u===g||u===$?u=p:u===_||u===m?u=f:(u=p,o=void 0);const a=u===p&&t[i+1].startsWith(\"/>\")?\" \":\"\";h+=u===f?s+r:d>=0?(e.push(l),s.slice(0,d)+\"$lit$\"+s.slice(d)+n+a):s+n+(-2===d?(e.push(void 0),i):a)}const c=h+(t[s]||\"<?>\")+(2===i?\"</svg>\":\"\");return[void 0!==l?l.createHTML(c):c,e]};class N{constructor({strings:t,_$litType$:i},s){let e;this.parts=[];let l=0,r=0;const u=t.length-1,d=this.parts,[v,a]=M(t,i);if(this.el=N.createElement(v,s),E.currentNode=this.el.content,2===i){const t=this.el.content,i=t.firstChild;i.remove(),t.append(...i.childNodes)}for(;null!==(e=E.nextNode())&&d.length<u;){if(1===e.nodeType){if(e.hasAttributes()){const t=[];for(const i of e.getAttributeNames())if(i.endsWith(\"$lit$\")||i.startsWith(n)){const s=a[r++];if(t.push(i),void 0!==s){const t=e.getAttribute(s.toLowerCase()+\"$lit$\").split(n),i=/([.?@])?(.*)/.exec(s);d.push({type:1,index:l,name:i[2],strings:t,ctor:\".\"===i[1]?I:\"?\"===i[1]?L:\"@\"===i[1]?R:H})}else d.push({type:6,index:l})}for(const i of t)e.removeAttribute(i)}if(y.test(e.tagName)){const t=e.textContent.split(n),i=t.length-1;if(i>0){e.textContent=o?o.emptyScript:\"\";for(let s=0;s<i;s++)e.append(t[s],c()),E.nextNode(),d.push({type:2,index:++l});e.append(t[i],c())}}}else if(8===e.nodeType)if(e.data===h)d.push({type:2,index:l});else{let t=-1;for(;-1!==(t=e.data.indexOf(n,t+1));)d.push({type:7,index:l}),t+=n.length-1}l++}}static createElement(t,i){const s=u.createElement(\"template\");return s.innerHTML=t,s}}function S(t,i,s=t,e){var o,l,n,h;if(i===w)return i;let r=void 0!==e?null===(o=s.Σi)||void 0===o?void 0:o[e]:s.Σo;const u=d(i)?void 0:i._$litDirective$;return(null==r?void 0:r.constructor)!==u&&(null===(l=null==r?void 0:r.O)||void 0===l||l.call(r,!1),void 0===u?r=void 0:(r=new u(t),r.T(t,s,e)),void 0!==e?(null!==(n=(h=s).Σi)&&void 0!==n?n:h.Σi=[])[e]=r:s.Σo=r),void 0!==r&&(i=S(t,r.S(t,i.values),r,e)),i}class k{constructor(t,i){this.l=[],this.N=void 0,this.D=t,this.M=i}u(t){var i;const{el:{content:s},parts:e}=this.D,o=(null!==(i=null==t?void 0:t.creationScope)&&void 0!==i?i:u).importNode(s,!0);E.currentNode=o;let l=E.nextNode(),n=0,h=0,r=e[0];for(;void 0!==r;){if(n===r.index){let i;2===r.type?i=new C(l,l.nextSibling,this,t):1===r.type?i=new r.ctor(l,r.name,r.strings,this,t):6===r.type&&(i=new z(l,this,t)),this.l.push(i),r=e[++h]}n!==(null==r?void 0:r.index)&&(l=E.nextNode(),n++)}return o}v(t){let i=0;for(const s of this.l)void 0!==s&&(void 0!==s.strings?(s.I(t,s,i),i+=s.strings.length-2):s.I(t[i])),i++}}class C{constructor(t,i,s,e){this.type=2,this.N=void 0,this.A=t,this.B=i,this.M=s,this.options=e}setConnected(t){var i;null===(i=this.P)||void 0===i||i.call(this,t)}get parentNode(){return this.A.parentNode}get startNode(){return this.A}get endNode(){return this.B}I(t,i=this){t=S(this,t,i),d(t)?t===A||null==t||\"\"===t?(this.H!==A&&this.R(),this.H=A):t!==this.H&&t!==w&&this.m(t):void 0!==t._$litType$?this._(t):void 0!==t.nodeType?this.$(t):a(t)?this.g(t):this.m(t)}k(t,i=this.B){return this.A.parentNode.insertBefore(t,i)}$(t){this.H!==t&&(this.R(),this.H=this.k(t))}m(t){const i=this.A.nextSibling;null!==i&&3===i.nodeType&&(null===this.B?null===i.nextSibling:i===this.B.previousSibling)?i.data=t:this.$(u.createTextNode(t)),this.H=t}_(t){var i;const{values:s,_$litType$:e}=t,o=\"number\"==typeof e?this.C(t):(void 0===e.el&&(e.el=N.createElement(e.h,this.options)),e);if((null===(i=this.H)||void 0===i?void 0:i.D)===o)this.H.v(s);else{const t=new k(o,this),i=t.u(this.options);t.v(s),this.$(i),this.H=t}}C(t){let i=P.get(t.strings);return void 0===i&&P.set(t.strings,i=new N(t)),i}g(t){v(this.H)||(this.H=[],this.R());const i=this.H;let s,e=0;for(const o of t)e===i.length?i.push(s=new C(this.k(c()),this.k(c()),this,this.options)):s=i[e],s.I(o),e++;e<i.length&&(this.R(s&&s.B.nextSibling,e),i.length=e)}R(t=this.A.nextSibling,i){var s;for(null===(s=this.P)||void 0===s||s.call(this,!1,!0,i);t&&t!==this.B;){const i=t.nextSibling;t.remove(),t=i}}}class H{constructor(t,i,s,e,o){this.type=1,this.H=A,this.N=void 0,this.V=void 0,this.element=t,this.name=i,this.M=e,this.options=o,s.length>2||\"\"!==s[0]||\"\"!==s[1]?(this.H=Array(s.length-1).fill(A),this.strings=s):this.H=A}get tagName(){return this.element.tagName}I(t,i=this,s,e){const o=this.strings;let l=!1;if(void 0===o)t=S(this,t,i,0),l=!d(t)||t!==this.H&&t!==w,l&&(this.H=t);else{const e=t;let n,h;for(t=o[0],n=0;n<o.length-1;n++)h=S(this,e[s+n],i,n),h===w&&(h=this.H[n]),l||(l=!d(h)||h!==this.H[n]),h===A?t=A:t!==A&&(t+=(null!=h?h:\"\")+o[n+1]),this.H[n]=h}l&&!e&&this.W(t)}W(t){t===A?this.element.removeAttribute(this.name):this.element.setAttribute(this.name,null!=t?t:\"\")}}class I extends H{constructor(){super(...arguments),this.type=3}W(t){this.element[this.name]=t===A?void 0:t}}class L extends H{constructor(){super(...arguments),this.type=4}W(t){t&&t!==A?this.element.setAttribute(this.name,\"\"):this.element.removeAttribute(this.name)}}class R extends H{constructor(){super(...arguments),this.type=5}I(t,i=this){var s;if((t=null!==(s=S(this,t,i,0))&&void 0!==s?s:A)===w)return;const e=this.H,o=t===A&&e!==A||t.capture!==e.capture||t.once!==e.once||t.passive!==e.passive,l=t!==A&&(e===A||o);o&&this.element.removeEventListener(this.name,this,e),l&&this.element.addEventListener(this.name,this,t),this.H=t}handleEvent(t){var i,s;\"function\"==typeof this.H?this.H.call(null!==(s=null===(i=this.options)||void 0===i?void 0:i.host)&&void 0!==s?s:this.element,t):this.H.handleEvent(t)}}class z{constructor(t,i,s){this.element=t,this.type=6,this.N=void 0,this.V=void 0,this.M=i,this.options=s}I(t){S(this,t)}}const Z={Z:\"$lit$\",U:n,Y:h,q:1,X:M,tt:k,it:a,st:S,et:C,ot:H,nt:L,rt:R,lt:I,ht:z};null===(i=(t=globalThis).litHtmlPlatformSupport)||void 0===i||i.call(t,N,C),(null!==(s=(e=globalThis).litHtmlVersions)&&void 0!==s?s:e.litHtmlVersions=[]).push(\"2.0.0-rc.3\");\n//# sourceMappingURL=lit-html.js.map\n\n\n/***/ }),\n/* 6 */\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __nested_webpack_require_31830__) => {\n\n\"use strict\";\n__nested_webpack_require_31830__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_31830__.d(__webpack_exports__, {\n/* harmony export */   \"CSSResult\": () => (/* reexport safe */ _lit_reactive_element__WEBPACK_IMPORTED_MODULE_0__.CSSResult),\n/* harmony export */   \"ReactiveElement\": () => (/* reexport safe */ _lit_reactive_element__WEBPACK_IMPORTED_MODULE_0__.ReactiveElement),\n/* harmony export */   \"adoptStyles\": () => (/* reexport safe */ _lit_reactive_element__WEBPACK_IMPORTED_MODULE_0__.adoptStyles),\n/* harmony export */   \"css\": () => (/* reexport safe */ _lit_reactive_element__WEBPACK_IMPORTED_MODULE_0__.css),\n/* harmony export */   \"defaultConverter\": () => (/* reexport safe */ _lit_reactive_element__WEBPACK_IMPORTED_MODULE_0__.defaultConverter),\n/* harmony export */   \"getCompatibleStyle\": () => (/* reexport safe */ _lit_reactive_element__WEBPACK_IMPORTED_MODULE_0__.getCompatibleStyle),\n/* harmony export */   \"notEqual\": () => (/* reexport safe */ _lit_reactive_element__WEBPACK_IMPORTED_MODULE_0__.notEqual),\n/* harmony export */   \"supportsAdoptingStyleSheets\": () => (/* reexport safe */ _lit_reactive_element__WEBPACK_IMPORTED_MODULE_0__.supportsAdoptingStyleSheets),\n/* harmony export */   \"unsafeCSS\": () => (/* reexport safe */ _lit_reactive_element__WEBPACK_IMPORTED_MODULE_0__.unsafeCSS),\n/* harmony export */   \"_Σ\": () => (/* reexport safe */ lit_html__WEBPACK_IMPORTED_MODULE_1__[\"_Σ\"]),\n/* harmony export */   \"html\": () => (/* reexport safe */ lit_html__WEBPACK_IMPORTED_MODULE_1__.html),\n/* harmony export */   \"noChange\": () => (/* reexport safe */ lit_html__WEBPACK_IMPORTED_MODULE_1__.noChange),\n/* harmony export */   \"nothing\": () => (/* reexport safe */ lit_html__WEBPACK_IMPORTED_MODULE_1__.nothing),\n/* harmony export */   \"render\": () => (/* reexport safe */ lit_html__WEBPACK_IMPORTED_MODULE_1__.render),\n/* harmony export */   \"svg\": () => (/* reexport safe */ lit_html__WEBPACK_IMPORTED_MODULE_1__.svg),\n/* harmony export */   \"LitElement\": () => (/* binding */ h),\n/* harmony export */   \"UpdatingElement\": () => (/* binding */ c),\n/* harmony export */   \"_Φ\": () => (/* binding */ u)\n/* harmony export */ });\n/* harmony import */ var _lit_reactive_element__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_31830__(3);\n/* harmony import */ var lit_html__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_31830__(5);\n\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */var i,l,o,s,n,a;const c=_lit_reactive_element__WEBPACK_IMPORTED_MODULE_0__.ReactiveElement;(null!==(i=(a=globalThis).litElementVersions)&&void 0!==i?i:a.litElementVersions=[]).push(\"3.0.0-rc.2\");class h extends _lit_reactive_element__WEBPACK_IMPORTED_MODULE_0__.ReactiveElement{constructor(){super(...arguments),this.renderOptions={host:this},this.Φt=void 0}createRenderRoot(){var t,e;const r=super.createRenderRoot();return null!==(t=(e=this.renderOptions).renderBefore)&&void 0!==t||(e.renderBefore=r.firstChild),r}update(t){const r=this.render();super.update(t),this.Φt=(0,lit_html__WEBPACK_IMPORTED_MODULE_1__.render)(r,this.renderRoot,this.renderOptions)}connectedCallback(){var t;super.connectedCallback(),null===(t=this.Φt)||void 0===t||t.setConnected(!0)}disconnectedCallback(){var t;super.disconnectedCallback(),null===(t=this.Φt)||void 0===t||t.setConnected(!1)}render(){return lit_html__WEBPACK_IMPORTED_MODULE_1__.noChange}}h.finalized=!0,h._$litElement$=!0,null===(o=(l=globalThis).litElementHydrateSupport)||void 0===o||o.call(l,{LitElement:h}),null===(n=(s=globalThis).litElementPlatformSupport)||void 0===n||n.call(s,{LitElement:h});const u={K:(t,e,r)=>{t.K(e,r)},L:t=>t.L};\n//# sourceMappingURL=lit-element.js.map\n\n\n/***/ }),\n/* 7 */\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __nested_webpack_require_35623__) => {\n\n\"use strict\";\n__nested_webpack_require_35623__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_35623__.d(__webpack_exports__, {\n/* harmony export */   \"customElement\": () => (/* reexport safe */ _lit_reactive_element_decorators_custom_element_js__WEBPACK_IMPORTED_MODULE_0__.customElement),\n/* harmony export */   \"property\": () => (/* reexport safe */ _lit_reactive_element_decorators_property_js__WEBPACK_IMPORTED_MODULE_1__.property),\n/* harmony export */   \"state\": () => (/* reexport safe */ _lit_reactive_element_decorators_state_js__WEBPACK_IMPORTED_MODULE_2__.state),\n/* harmony export */   \"eventOptions\": () => (/* reexport safe */ _lit_reactive_element_decorators_event_options_js__WEBPACK_IMPORTED_MODULE_3__.eventOptions),\n/* harmony export */   \"query\": () => (/* reexport safe */ _lit_reactive_element_decorators_query_js__WEBPACK_IMPORTED_MODULE_4__.query),\n/* harmony export */   \"queryAll\": () => (/* reexport safe */ _lit_reactive_element_decorators_query_all_js__WEBPACK_IMPORTED_MODULE_5__.queryAll),\n/* harmony export */   \"queryAsync\": () => (/* reexport safe */ _lit_reactive_element_decorators_query_async_js__WEBPACK_IMPORTED_MODULE_6__.queryAsync),\n/* harmony export */   \"queryAssignedNodes\": () => (/* reexport safe */ _lit_reactive_element_decorators_query_assigned_nodes_js__WEBPACK_IMPORTED_MODULE_7__.queryAssignedNodes)\n/* harmony export */ });\n/* harmony import */ var _lit_reactive_element_decorators_custom_element_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_35623__(8);\n/* harmony import */ var _lit_reactive_element_decorators_property_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_35623__(9);\n/* harmony import */ var _lit_reactive_element_decorators_state_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_35623__(10);\n/* harmony import */ var _lit_reactive_element_decorators_event_options_js__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_35623__(11);\n/* harmony import */ var _lit_reactive_element_decorators_query_js__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_35623__(13);\n/* harmony import */ var _lit_reactive_element_decorators_query_all_js__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_35623__(14);\n/* harmony import */ var _lit_reactive_element_decorators_query_async_js__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_35623__(15);\n/* harmony import */ var _lit_reactive_element_decorators_query_assigned_nodes_js__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_35623__(16);\n\n//# sourceMappingURL=decorators.js.map\n\n\n/***/ }),\n/* 8 */\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __nested_webpack_require_38178__) => {\n\n\"use strict\";\n__nested_webpack_require_38178__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_38178__.d(__webpack_exports__, {\n/* harmony export */   \"customElement\": () => (/* binding */ n)\n/* harmony export */ });\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nconst n=n=>e=>\"function\"==typeof e?((n,e)=>(window.customElements.define(n,e),e))(n,e):((n,e)=>{const{kind:t,elements:i}=e;return{kind:t,elements:i,finisher(e){window.customElements.define(n,e)}}})(n,e);\n//# sourceMappingURL=custom-element.js.map\n\n\n/***/ }),\n/* 9 */\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __nested_webpack_require_38841__) => {\n\n\"use strict\";\n__nested_webpack_require_38841__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_38841__.d(__webpack_exports__, {\n/* harmony export */   \"property\": () => (/* binding */ e)\n/* harmony export */ });\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nconst i=(i,e)=>\"method\"===e.kind&&e.descriptor&&!(\"value\"in e.descriptor)?{...e,finisher(n){n.createProperty(e.key,i)}}:{kind:\"field\",key:Symbol(),placement:\"own\",descriptor:{},originalKey:e.key,initializer(){\"function\"==typeof e.initializer&&(this[e.key]=e.initializer.call(this))},finisher(n){n.createProperty(e.key,i)}};function e(e){return(n,t)=>void 0!==t?((i,e,n)=>{e.constructor.createProperty(n,i)})(e,n,t):i(e,n)}\n//# sourceMappingURL=property.js.map\n\n\n/***/ }),\n/* 10 */\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __nested_webpack_require_39713__) => {\n\n\"use strict\";\n__nested_webpack_require_39713__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_39713__.d(__webpack_exports__, {\n/* harmony export */   \"state\": () => (/* binding */ r)\n/* harmony export */ });\n/* harmony import */ var _property_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_39713__(9);\n\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */function r(r){return (0,_property_js__WEBPACK_IMPORTED_MODULE_0__.property)({...r,state:!0,attribute:!1})}\n//# sourceMappingURL=state.js.map\n\n\n/***/ }),\n/* 11 */\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __nested_webpack_require_40356__) => {\n\n\"use strict\";\n__nested_webpack_require_40356__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_40356__.d(__webpack_exports__, {\n/* harmony export */   \"eventOptions\": () => (/* binding */ e)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_40356__(12);\n\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */function e(e){return (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.decorateProperty)({finisher:(r,t)=>{Object.assign(r.prototype[t],e)}})}\n//# sourceMappingURL=event-options.js.map\n\n\n/***/ }),\n/* 12 */\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __nested_webpack_require_41038__) => {\n\n\"use strict\";\n__nested_webpack_require_41038__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_41038__.d(__webpack_exports__, {\n/* harmony export */   \"decorateProperty\": () => (/* binding */ o),\n/* harmony export */   \"legacyPrototypeMethod\": () => (/* binding */ e),\n/* harmony export */   \"standardPrototypeMethod\": () => (/* binding */ t)\n/* harmony export */ });\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nconst e=(e,t,o)=>{Object.defineProperty(t,o,e)},t=(e,t)=>({kind:\"method\",placement:\"prototype\",key:t.key,descriptor:e}),o=({finisher:e,descriptor:t})=>(o,n)=>{var r;if(void 0===n){const n=null!==(r=o.originalKey)&&void 0!==r?r:o.key,i=null!=t?{kind:\"method\",placement:\"prototype\",key:n,descriptor:t(o.key)}:{...o,key:n};return null!=e&&(i.finisher=function(t){e(t,n)}),i}{const r=o.constructor;void 0!==t&&Object.defineProperty(o,n,t(n)),null==e||e(r,n)}};\n//# sourceMappingURL=base.js.map\n\n\n/***/ }),\n/* 13 */\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __nested_webpack_require_42096__) => {\n\n\"use strict\";\n__nested_webpack_require_42096__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_42096__.d(__webpack_exports__, {\n/* harmony export */   \"query\": () => (/* binding */ o)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_42096__(12);\n\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */function o(o,r){return (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.decorateProperty)({descriptor:t=>{const i={get(){var t;return null===(t=this.renderRoot)||void 0===t?void 0:t.querySelector(o)},enumerable:!0,configurable:!0};if(r){const r=\"symbol\"==typeof t?Symbol():\"__\"+t;i.get=function(){var t;return void 0===this[r]&&(this[r]=null===(t=this.renderRoot)||void 0===t?void 0:t.querySelector(o)),this[r]}}return i}})}\n//# sourceMappingURL=query.js.map\n\n\n/***/ }),\n/* 14 */\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __nested_webpack_require_43046__) => {\n\n\"use strict\";\n__nested_webpack_require_43046__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_43046__.d(__webpack_exports__, {\n/* harmony export */   \"queryAll\": () => (/* binding */ e)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_43046__(12);\n\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */function e(e){return (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.decorateProperty)({descriptor:r=>({get(){var r;return null===(r=this.renderRoot)||void 0===r?void 0:r.querySelectorAll(e)},enumerable:!0,configurable:!0})})}\n//# sourceMappingURL=query-all.js.map\n\n\n/***/ }),\n/* 15 */\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __nested_webpack_require_43806__) => {\n\n\"use strict\";\n__nested_webpack_require_43806__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_43806__.d(__webpack_exports__, {\n/* harmony export */   \"queryAsync\": () => (/* binding */ e)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_43806__(12);\n\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nfunction e(e){return (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.decorateProperty)({descriptor:r=>({async get(){var r;return await this.updateComplete,null===(r=this.renderRoot)||void 0===r?void 0:r.querySelector(e)},enumerable:!0,configurable:!0})})}\n//# sourceMappingURL=query-async.js.map\n\n\n/***/ }),\n/* 16 */\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __nested_webpack_require_44600__) => {\n\n\"use strict\";\n__nested_webpack_require_44600__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_44600__.d(__webpack_exports__, {\n/* harmony export */   \"queryAssignedNodes\": () => (/* binding */ o)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_44600__(12);\n\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nconst t=Element.prototype,n=t.msMatchesSelector||t.webkitMatchesSelector;function o(t=\"\",o=!1,r=\"\"){return (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.decorateProperty)({descriptor:e=>({get(){var e,l;const i=\"slot\"+(t?`[name=${t}]`:\":not([name])\");let a=null===(l=null===(e=this.renderRoot)||void 0===e?void 0:e.querySelector(i))||void 0===l?void 0:l.assignedNodes({flatten:o});return a&&r&&(a=a.filter((e=>e.nodeType===Node.ELEMENT_NODE&&(e.matches?e.matches(r):n.call(e,r))))),a},enumerable:!0,configurable:!0})})}\n//# sourceMappingURL=query-assigned-nodes.js.map\n\n\n/***/ }),\n/* 17 */\n/***/ ((module) => {\n\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(self, function() {\nreturn /******/ (() => { // webpackBootstrap\n/******/ \tvar __webpack_modules__ = ([\n/* 0 */,\n/* 1 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_519__) => {\n\n\"use strict\";\n__nested_webpack_require_519__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_519__.d(__webpack_exports__, {\n/* harmony export */   \"GridImageGenerator\": () => (/* binding */ GridImageGenerator)\n/* harmony export */ });\nclass GridImageGenerator {\n    constructor() {\n        this._width = 0;\n        this._height = 0;\n        this._changed = false;\n        this._color = '#000000';\n    }\n    get changed() {\n        return this._changed;\n    }\n    get gridColor() {\n        return this._color;\n    }\n    get width() {\n        return this._width;\n    }\n    get height() {\n        return this._height;\n    }\n    set gridColor(color) {\n        this._changed = this._color !== color;\n        this._color = color;\n    }\n    setGridSize(width, height) {\n        this._changed = (this._width !== width) || (this._height !== height);\n        this._width = width;\n        this._height = height;\n    }\n    generateDottedPart() {\n        const { canvas, context } = this.createCanvas();\n        context.fillRect(this._width - 1, this._height - 1, 1, 1);\n        return canvas;\n    }\n    generateLinePart() {\n        const { canvas, context } = this.createCanvas();\n        context.fillRect(0, this._height - 1, this._width, 1);\n        context.fillRect(this._width - 1, 0, 1, this._height);\n        return canvas;\n    }\n    createCanvas() {\n        const canvas = document.createElement('canvas');\n        const context = canvas.getContext('2d');\n        if (!context) {\n            throw new Error();\n        }\n        canvas.width = this._width;\n        canvas.height = this._height;\n        context.fillStyle = this._color;\n        return {\n            canvas,\n            context\n        };\n    }\n}\n\n\n/***/ }),\n/* 2 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_2327__) => {\n\n\"use strict\";\n__nested_webpack_require_2327__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_2327__.d(__webpack_exports__, {\n/* harmony export */   \"CallbackItem\": () => (/* binding */ CallbackItem)\n/* harmony export */ });\nclass CallbackItem {\n    constructor(_proc, _id = -1) {\n        this._proc = _proc;\n        this._id = _id;\n        this._caller = null;\n    }\n    get id() {\n        return this._id;\n    }\n    call() {\n        if (!this._proc)\n            new Error('Callback function is not set');\n        this._proc.call(this._caller);\n    }\n}\n\n\n/***/ }),\n/* 3 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_2980__) => {\n\n\"use strict\";\n__nested_webpack_require_2980__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_2980__.d(__webpack_exports__, {\n/* harmony export */   \"MapCanvas\": () => (/* binding */ MapCanvas)\n/* harmony export */ });\n/* harmony import */ var _piyoppi_pico2map_tiled__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_2980__(4);\n/* harmony import */ var _piyoppi_pico2map_tiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_2980__.n(_piyoppi_pico2map_tiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Brushes_Pen__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_2980__(5);\n/* harmony import */ var _Brushes_Brushes__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_2980__(6);\n/* harmony import */ var _Brushes_Arrangements_Arrangements__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_2980__(8);\n/* harmony import */ var _Brushes_Arrangements_Arrangement__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_2980__(14);\n/* harmony import */ var _Brushes_Arrangements_DefaultArrangement__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_2980__(9);\n/* harmony import */ var _MapChipPicker__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_2980__(15);\n/* harmony import */ var _CursorPositionConverter__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_2980__(16);\n\n\n\n\n\n\n\n\nclass MapCanvas {\n    constructor() {\n        this._secondaryCanvasCtx = null;\n        this._isMouseDown = false;\n        this._brush = new _Brushes_Pen__WEBPACK_IMPORTED_MODULE_1__.Pen();\n        this._arrangement = new _Brushes_Arrangements_DefaultArrangement__WEBPACK_IMPORTED_MODULE_5__.DefaultArrangement();\n        this._lastMapChipPosition = { x: -1, y: -1 };\n        this._canvasContexts = [];\n        this.secondaryCanvas = null;\n        this._project = null;\n        this._renderer = null;\n        this._selectedAutoTile = null;\n        this._selectedMapChipFragments = [];\n        this._activeLayerIndex = 0;\n        this._mapChipPickerEnabled = true;\n        this._mapChipPicker = null;\n        this._isPickFromActiveLayer = false;\n        this._pickedCallback = null;\n        this._renderAllCallbackItem = null;\n    }\n    get selectedAutoTile() {\n        return this._selectedAutoTile;\n    }\n    get selectedMapChipFragments() {\n        return this._selectedMapChipFragments;\n    }\n    get project() {\n        if (!this._project)\n            throw new Error('Project is not set');\n        return this._project;\n    }\n    get hasProject() {\n        return !!this._project;\n    }\n    get renderer() {\n        if (!this._renderer)\n            throw new Error('Renderer is not set');\n        return this._renderer;\n    }\n    get activeLayer() {\n        return this._activeLayerIndex;\n    }\n    get isMouseDown() {\n        return this._isMouseDown;\n    }\n    get renderable() {\n        return this._canvasContexts.length > 0 && !!this._renderer;\n    }\n    get mapChipPickerEnabled() {\n        return this._mapChipPickerEnabled;\n    }\n    get isPickFromActiveLayer() {\n        return this._isPickFromActiveLayer;\n    }\n    set isPickFromActiveLayer(value) {\n        this._isPickFromActiveLayer = value;\n    }\n    get isSubscribedProjectEvent() {\n        return !!this._renderAllCallbackItem;\n    }\n    hasActiveAutoTile() {\n        return !!this._selectedAutoTile;\n    }\n    setProject(project) {\n        if (this._project === project)\n            throw new Error('This project has already been set.');\n        this._project = project;\n        this._renderer = new _piyoppi_pico2map_tiled__WEBPACK_IMPORTED_MODULE_0__.MapRenderer(this._project.tiledMap);\n        this._mapChipPicker = new _MapChipPicker__WEBPACK_IMPORTED_MODULE_6__.MapChipPicker(this._project.tiledMap);\n        this._setupBrush();\n    }\n    subscribeProjectEvent() {\n        if (this._renderAllCallbackItem)\n            throw new Error('Project Event is already subscribed');\n        if (!this._project)\n            throw new Error('Project is not set');\n        this._renderAllCallbackItem = this._project.setCallback('renderAll', () => this.renderAll());\n    }\n    unsubscribeProjectEvent() {\n        if (this._project && this._renderAllCallbackItem)\n            this._project.removeCallback('renderAll', this._renderAllCallbackItem);\n        this._renderAllCallbackItem = null;\n    }\n    async firstRenderAll() {\n        if (!this._project)\n            return;\n        await this._project.tiledMap.mapChipsCollection.waitWhileLoading();\n        if (this.renderable) {\n            this.renderAll();\n        }\n    }\n    renderAll() {\n        if (!this.renderable)\n            return;\n        const renderer = this.renderer;\n        this._canvasContexts.forEach((ctx, index) => (this.project.tiledMap.datas.length > index) && renderer.renderLayer(index, ctx));\n    }\n    setCanvases(canvases, secondaryCanvas) {\n        this._canvasContexts = canvases.map(canvas => canvas.getContext('2d'));\n        this.secondaryCanvas = secondaryCanvas;\n        this._secondaryCanvasCtx = this.secondaryCanvas.getContext('2d');\n        if (this.renderable) {\n            this.renderAll();\n        }\n    }\n    addCanvas(canvas) {\n        this._canvasContexts.push(canvas.getContext('2d'));\n    }\n    setAutoTile(value) {\n        this._selectedAutoTile = value;\n    }\n    setMapChipFragments(value) {\n        this._selectedMapChipFragments = value;\n    }\n    setPickedCallback(callbackFn) {\n        this._pickedCallback = callbackFn;\n    }\n    setBrushFromName(brushName) {\n        const registeredBrush = _Brushes_Brushes__WEBPACK_IMPORTED_MODULE_2__.Brushes.find(registeredBrush => registeredBrush.name === brushName);\n        if (!registeredBrush) {\n            this.setBrush(new _Brushes_Pen__WEBPACK_IMPORTED_MODULE_1__.Pen());\n        }\n        else {\n            this.setBrush(registeredBrush.create());\n        }\n    }\n    setArrangementFromName(arrangementName) {\n        const registeredArrangement = _Brushes_Arrangements_Arrangements__WEBPACK_IMPORTED_MODULE_3__.Arrangements.find(registered => registered.name === arrangementName);\n        if (!registeredArrangement) {\n            this.setArrangement(new _Brushes_Arrangements_DefaultArrangement__WEBPACK_IMPORTED_MODULE_5__.DefaultArrangement());\n        }\n        else {\n            this.setArrangement(registeredArrangement.create());\n        }\n    }\n    setActiveLayer(index) {\n        if (!this._project)\n            return;\n        if (index < 0 || index >= this._project.tiledMap.datas.length) {\n            throw new Error('The layer index is out of range.');\n        }\n        this._activeLayerIndex = index;\n        this._setupBrush();\n    }\n    setMapChipPickerEnabled(value) {\n        this._mapChipPickerEnabled = value;\n    }\n    _setupBrush() {\n        if (!this._project || !this._arrangement)\n            return;\n        this._brush.setArrangement(this._arrangement);\n        if ((0,_Brushes_Arrangements_Arrangement__WEBPACK_IMPORTED_MODULE_4__.isTiledMapDataRequired)(this._arrangement)) {\n            this._arrangement.setTiledMapData(this._project.tiledMap.datas[this._activeLayerIndex]);\n        }\n    }\n    setArrangement(arrangement) {\n        this._arrangement = arrangement;\n        this._setupBrush();\n    }\n    setBrush(brush) {\n        this._brush = brush;\n        this._setupBrush();\n    }\n    mouseDown(x, y, isSubButton = false) {\n        const chipPosition = this.convertFromCursorPositionToChipPosition(x, y);\n        if (isSubButton && this._mapChipPickerEnabled) {\n            this.pick(chipPosition.x, chipPosition.y);\n            return;\n        }\n        if ((0,_Brushes_Arrangements_Arrangement__WEBPACK_IMPORTED_MODULE_4__.isMapChipFragmentRequired)(this._arrangement) && !(0,_Brushes_Arrangements_Arrangement__WEBPACK_IMPORTED_MODULE_4__.isAutoTileRequired)(this._arrangement) && this._selectedMapChipFragments.length < 1)\n            return;\n        if ((0,_Brushes_Arrangements_Arrangement__WEBPACK_IMPORTED_MODULE_4__.isAutoTileRequired)(this._arrangement) && !this.selectedAutoTile)\n            return;\n        this._isMouseDown = true;\n        if ((0,_Brushes_Arrangements_Arrangement__WEBPACK_IMPORTED_MODULE_4__.isMapChipFragmentRequired)(this._arrangement)) {\n            this._arrangement.setMapChips(this._selectedMapChipFragments);\n        }\n        if ((0,_Brushes_Arrangements_Arrangement__WEBPACK_IMPORTED_MODULE_4__.isAutoTileRequired)(this._arrangement) && this._selectedAutoTile) {\n            this._arrangement.setAutoTile(this._selectedAutoTile);\n        }\n        if ((0,_Brushes_Arrangements_Arrangement__WEBPACK_IMPORTED_MODULE_4__.isAutoTilesRequired)(this._arrangement)) {\n            this._arrangement.setAutoTiles(this.project.tiledMap.autoTiles);\n        }\n        this._brush.mouseDown(chipPosition.x, chipPosition.y);\n        this._lastMapChipPosition = chipPosition;\n        this._paint(chipPosition);\n    }\n    mouseMove(x, y) {\n        const chipPosition = this.convertFromCursorPositionToChipPosition(x, y);\n        if (!this._isMouseDown)\n            return chipPosition;\n        if (chipPosition.x === this._lastMapChipPosition.x && chipPosition.y === this._lastMapChipPosition.y)\n            return chipPosition;\n        this._paint(chipPosition);\n        this._lastMapChipPosition = chipPosition;\n        return chipPosition;\n    }\n    mouseUp(x, y) {\n        if (!this._isMouseDown)\n            return;\n        this._isMouseDown = false;\n        const chipPosition = this.convertFromCursorPositionToChipPosition(x, y);\n        this._brush.mouseUp(chipPosition.x, chipPosition.y).forEach(paint => {\n            const chip = paint.item;\n            this.putChip(chip, paint.x, paint.y);\n        });\n        this.clearSecondaryCanvas();\n        this._brush.cleanUp();\n        this._lastMapChipPosition = { x: -1, y: -1 };\n    }\n    putChip(mapChip, chipX, chipY) {\n        this.project.tiledMap.put(mapChip, chipX, chipY, this._activeLayerIndex);\n        this.renderer.putOrClearChipToCanvas(this._canvasContexts[this._activeLayerIndex], mapChip, chipX, chipY);\n    }\n    _paint(chipPosition) {\n        this.clearSecondaryCanvas();\n        this._brush.mouseMove(chipPosition.x, chipPosition.y).forEach(paint => {\n            if (!this._secondaryCanvasCtx)\n                return;\n            const chip = paint.item;\n            this.renderer.putOrClearChipToCanvas(this._secondaryCanvasCtx, chip, paint.x, paint.y, true);\n        });\n    }\n    clearSecondaryCanvas() {\n        if (!this.secondaryCanvas || !this._secondaryCanvasCtx)\n            return;\n        this._secondaryCanvasCtx.clearRect(0, 0, this.secondaryCanvas.width, this.secondaryCanvas.height);\n    }\n    convertFromCursorPositionToChipPosition(x, y) {\n        return (0,_CursorPositionConverter__WEBPACK_IMPORTED_MODULE_7__.convertFromCursorPositionToChipPosition)(x, y, this.project.tiledMap.chipWidth, this.project.tiledMap.chipHeight, this.project.tiledMap.chipCountX, this.project.tiledMap.chipCountY);\n    }\n    pick(x, y) {\n        var _a, _b;\n        if (!this._mapChipPicker)\n            return;\n        const picked = this._isPickFromActiveLayer ? (_a = this._mapChipPicker) === null || _a === void 0 ? void 0 : _a.pick(x, y, this._activeLayerIndex) : (_b = this._mapChipPicker) === null || _b === void 0 ? void 0 : _b.pick(x, y);\n        if ((0,_piyoppi_pico2map_tiled__WEBPACK_IMPORTED_MODULE_0__.isAutoTileMapChip)(picked)) {\n            const autoTile = this.project.tiledMap.autoTiles.fromId(picked.autoTileId);\n            if (autoTile)\n                this.setAutoTile(autoTile);\n        }\n        else if (picked) {\n            this.setMapChipFragments(picked.items);\n        }\n        if (this._pickedCallback)\n            this._pickedCallback(picked);\n    }\n}\n\n\n/***/ }),\n/* 4 */\n/***/ ((module) => {\n\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(self, function() {\nreturn /******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ([\n/* 0 */,\n/* 1 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_541__) => {\n\n__nested_webpack_require_541__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_541__.d(__webpack_exports__, {\n/* harmony export */   \"TiledMap\": () => (/* binding */ TiledMap)\n/* harmony export */ });\n/* harmony import */ var _MapChipsCollection__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_541__(2);\n/* harmony import */ var _AutoTile_AutoTiles__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_541__(4);\n/* harmony import */ var _MapData_TiledMapData__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_541__(7);\n/* harmony import */ var _MapData_ColiderMap__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_541__(11);\n\n\n\n\nclass TiledMap {\n    constructor(_chipCountX, _chipCountY, _chipWidth, _chipHeight) {\n        this._chipCountX = _chipCountX;\n        this._chipCountY = _chipCountY;\n        this._chipWidth = _chipWidth;\n        this._chipHeight = _chipHeight;\n        this._mapChipImages = new _MapChipsCollection__WEBPACK_IMPORTED_MODULE_0__.MapChipsCollection();\n        this._autoTiles = new _AutoTile_AutoTiles__WEBPACK_IMPORTED_MODULE_1__.AutoTiles();\n        this._datas = [];\n        this._coliders = new _MapData_ColiderMap__WEBPACK_IMPORTED_MODULE_3__.ColiderMap(this._chipCountX, this._chipCountY);\n        this.addLayer();\n    }\n    get chipWidth() {\n        return this._chipWidth;\n    }\n    get chipHeight() {\n        return this._chipHeight;\n    }\n    get chipCountX() {\n        return this._chipCountX;\n    }\n    get chipCountY() {\n        return this._chipCountY;\n    }\n    get mapChipsCollection() {\n        return this._mapChipImages;\n    }\n    get autoTiles() {\n        return this._autoTiles;\n    }\n    get datas() {\n        return this._datas;\n    }\n    get coliders() {\n        return this._coliders;\n    }\n    convertChipPositionToPixel(chipX, chipY) {\n        return {\n            x: chipX * this.chipWidth,\n            y: chipY * this.chipHeight\n        };\n    }\n    put(mapChip, chipX, chipY, index) {\n        this._datas[index].put(mapChip, chipX, chipY);\n    }\n    toObject() {\n        return {\n            chipCountX: this._chipCountX,\n            chipCountY: this._chipCountY,\n            chipWidth: this._chipWidth,\n            chipHeight: this._chipHeight,\n            mapChipImages: this._mapChipImages.toObject(),\n            autoTiles: this._autoTiles.toObject(),\n            tiledMapDatas: this._datas.map(data => data.toObject()),\n            coliders: this._coliders.toObject()\n        };\n    }\n    addLayer() {\n        this._datas.push(new _MapData_TiledMapData__WEBPACK_IMPORTED_MODULE_2__.TiledMapData(this._chipCountX, this._chipCountY));\n    }\n    convertMapNumberToPosition(num) {\n        return {\n            x: num % this._chipCountX,\n            y: Math.floor(num / this._chipCountX)\n        };\n    }\n    resize(chipCountX, chipCountY) {\n        this._chipCountX = chipCountX;\n        this._chipCountY = chipCountY;\n        this._datas.forEach(item => item.resize(chipCountX, chipCountY, null));\n        this._coliders.resize(chipCountX, chipCountY, 0);\n    }\n    setSerializedProperties(val) {\n        this._mapChipImages.fromObject(val.mapChipImages);\n        this._autoTiles.fromObject(val.autoTiles);\n        this._datas = val.tiledMapDatas.map(tiledMapData => _MapData_TiledMapData__WEBPACK_IMPORTED_MODULE_2__.TiledMapData.fromObject(tiledMapData));\n        this._coliders = _MapData_ColiderMap__WEBPACK_IMPORTED_MODULE_3__.ColiderMap.fromObject(val.coliders);\n    }\n    static fromObject(val) {\n        const tiledMap = new TiledMap(val.chipCountX, val.chipCountY, val.chipWidth, val.chipHeight);\n        tiledMap.setSerializedProperties({ mapChipImages: val.mapChipImages, autoTiles: val.autoTiles, tiledMapDatas: val.tiledMapDatas, coliders: val.coliders });\n        return tiledMap;\n    }\n}\n\n\n/***/ }),\n/* 2 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_4382__) => {\n\n__nested_webpack_require_4382__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_4382__.d(__webpack_exports__, {\n/* harmony export */   \"MapChipsCollection\": () => (/* binding */ MapChipsCollection)\n/* harmony export */ });\n/* harmony import */ var _MapChipImage__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_4382__(3);\n\nclass MapChipsCollection {\n    constructor() {\n        this._items = new Map();\n    }\n    push(item) {\n        this._items.set(item.id, item);\n    }\n    remove(item) {\n        this._items.delete(item.id);\n    }\n    replace(replacement) {\n        const target = this.findById(replacement.id);\n        if (!target)\n            throw new Error('Target MapChipImage cannot be found.');\n        this.remove(target);\n        this.push(replacement);\n    }\n    findById(chipId) {\n        return this._items.get(chipId) || null;\n    }\n    getItems() {\n        return Array.from(this._items.values());\n    }\n    async waitWhileLoading() {\n        await Promise.all(Array.from(this._items.values()).map(item => item.waitWhileLoading()));\n    }\n    toObject() {\n        const objectedMapChipImage = [];\n        const valuesItr = this._items.values();\n        for (const val of valuesItr) {\n            objectedMapChipImage.push(val.toObject());\n        }\n        return {\n            items: objectedMapChipImage\n        };\n    }\n    fromObject(val) {\n        this._items.clear();\n        val.items.forEach(objectedVal => {\n            this.push(_MapChipImage__WEBPACK_IMPORTED_MODULE_0__.MapChipImage.fromObject(objectedVal));\n        });\n    }\n}\n\n\n/***/ }),\n/* 3 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_6034__) => {\n\n__nested_webpack_require_6034__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_6034__.d(__webpack_exports__, {\n/* harmony export */   \"MapChipImage\": () => (/* binding */ MapChipImage)\n/* harmony export */ });\nclass MapChipImage {\n    constructor(_src, _id) {\n        this._src = _src;\n        this._id = _id;\n        this._image = new Image();\n        this._hasImage = false;\n        this._hasError = false;\n        this.loadImage();\n    }\n    get id() {\n        return this._id;\n    }\n    get src() {\n        return this._src;\n    }\n    get hasImage() {\n        return this._hasImage;\n    }\n    get hasError() {\n        return this._hasError;\n    }\n    get image() {\n        return this._image;\n    }\n    getChipCount(chipWidth, chipHeight) {\n        if (!this._hasImage)\n            throw new Error('Image loading is not complete.');\n        return {\n            width: Math.floor(this._image.width / chipWidth),\n            height: Math.floor(this._image.height / chipHeight)\n        };\n    }\n    _loadImageHandler() {\n        this._hasImage = true;\n    }\n    _errorImaegHandler() {\n        this._hasError = true;\n    }\n    loadImage() {\n        this._hasImage = false;\n        this._hasError = false;\n        this._image.onload = () => this._loadImageHandler();\n        this._image.onerror = () => this._errorImaegHandler();\n        this._image.src = this._src;\n    }\n    waitWhileLoading() {\n        const loadingPromise = new Promise((resolve, reject) => {\n            this._image.onload = () => {\n                this._loadImageHandler();\n                resolve();\n            };\n            this._image.onerror = () => {\n                this._errorImaegHandler();\n                reject(new Error('Failed to load the image.'));\n            };\n        });\n        if (this._hasImage)\n            return Promise.resolve();\n        if (this._hasError)\n            return Promise.reject(new Error('Failed to load the image.'));\n        return loadingPromise;\n    }\n    toObject() {\n        return {\n            id: this._id,\n            src: this._src\n        };\n    }\n    static fromObject(val) {\n        return new MapChipImage(val.src, val.id);\n    }\n}\n\n\n/***/ }),\n/* 4 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_8296__) => {\n\n__nested_webpack_require_8296__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_8296__.d(__webpack_exports__, {\n/* harmony export */   \"AutoTiles\": () => (/* binding */ AutoTiles)\n/* harmony export */ });\n/* harmony import */ var _AutoTile__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_8296__(5);\n\nclass AutoTiles {\n    constructor() {\n        this._autoTiles = new Map();\n        this._maxId = 0;\n    }\n    get length() {\n        return this._autoTiles.size;\n    }\n    push(item) {\n        this._autoTiles.set(item.id, item);\n        this._maxId = Math.max(this._maxId, item.id);\n    }\n    remove(item) {\n        this._autoTiles.delete(item.id);\n    }\n    findByImage(image) {\n        const valuesItr = this._autoTiles.values();\n        return Array.from(valuesItr).filter(autoTile => autoTile.mapChipFragments.some(fragment => fragment.chipId === image.id));\n    }\n    fromId(id) {\n        return this._autoTiles.get(id) || null;\n    }\n    values() {\n        return this._autoTiles.values();\n    }\n    import(strategy) {\n        const mapChipFragmentGroups = strategy.getMapChipFragments();\n        return mapChipFragmentGroups.map(group => {\n            const autoTile = new _AutoTile__WEBPACK_IMPORTED_MODULE_0__.AutoTile(group, ++this._maxId);\n            this.push(autoTile);\n            return autoTile;\n        });\n    }\n    toObject() {\n        const objectedAutoTiles = [];\n        const valuesItr = this._autoTiles.values();\n        for (const val of valuesItr) {\n            objectedAutoTiles.push(val.toObject());\n        }\n        return {\n            autoTiles: objectedAutoTiles\n        };\n    }\n    fromObject(val) {\n        this._autoTiles.clear();\n        val.autoTiles.forEach(objectedAutoTile => {\n            const autoTile = _AutoTile__WEBPACK_IMPORTED_MODULE_0__.AutoTile.fromObject(objectedAutoTile);\n            this.push(autoTile);\n            this._maxId = Math.max(this._maxId, autoTile.id);\n        });\n    }\n}\n\n\n/***/ }),\n/* 5 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_10334__) => {\n\n__nested_webpack_require_10334__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_10334__.d(__webpack_exports__, {\n/* harmony export */   \"AutoTile\": () => (/* binding */ AutoTile)\n/* harmony export */ });\n/* harmony import */ var _MapChip__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_10334__(6);\n\nclass AutoTile {\n    constructor(_mapChipFragments, _id) {\n        this._mapChipFragments = _mapChipFragments;\n        this._id = _id;\n    }\n    get id() {\n        return this._id;\n    }\n    get mapChipFragments() {\n        return this._mapChipFragments;\n    }\n    getMapChipImageIds() {\n        const chipIds = new Set();\n        this._mapChipFragments.forEach(fragment => chipIds.add(fragment.chipId));\n        return Array.from(chipIds.values());\n    }\n    toObject() {\n        return {\n            id: this._id,\n            mapChipFragments: this._mapChipFragments.map(fragment => fragment.toObject())\n        };\n    }\n    static fromObject(val) {\n        return new AutoTile(val.mapChipFragments.map(fragment => _MapChip__WEBPACK_IMPORTED_MODULE_0__.MapChipFragment.fromObject(fragment)), val.id);\n    }\n}\n\n\n/***/ }),\n/* 6 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_11537__) => {\n\n__nested_webpack_require_11537__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_11537__.d(__webpack_exports__, {\n/* harmony export */   \"MapChipFragment\": () => (/* binding */ MapChipFragment),\n/* harmony export */   \"MapChip\": () => (/* binding */ MapChip),\n/* harmony export */   \"isAutoTileMapChipProperties\": () => (/* binding */ isAutoTileMapChipProperties),\n/* harmony export */   \"AutoTileMapChip\": () => (/* binding */ AutoTileMapChip),\n/* harmony export */   \"isAutoTileMapChip\": () => (/* binding */ isAutoTileMapChip)\n/* harmony export */ });\nclass MapChipFragment {\n    constructor(_x, _y, _chipId, \n    /**\n     *  _renderingArea indicates the area where this map-chip is to be drawn.\n     *  It is represented by a OR of the following area-numbers.\n     *\n     * |<- 1chip ->|\n     * *-----*-----* ---\n     * |  1  |  2  |  ↑\n     * *-----*-----* 1chip\n     * |  4  |  8  |  ↓\n     * *-----*-----* ---\n     */\n    _renderingArea = 15) {\n        this._x = _x;\n        this._y = _y;\n        this._chipId = _chipId;\n        this._renderingArea = _renderingArea;\n        this._identifyKey = '';\n        this._identifyKey = `${_x},${_y},${_chipId}`;\n    }\n    get x() {\n        return this._x;\n    }\n    get y() {\n        return this._y;\n    }\n    get chipId() {\n        return this._chipId;\n    }\n    get identifyKey() {\n        return this._identifyKey;\n    }\n    get renderingArea() {\n        return this._renderingArea;\n    }\n    withParameter(parameters) {\n        if (parameters.x)\n            this._x = parameters.x;\n        if (parameters.y)\n            this._y = parameters.y;\n        if (parameters.renderingArea)\n            this._renderingArea = parameters.renderingArea;\n        return this;\n    }\n    clone() {\n        return new MapChipFragment(this._x, this._y, this._chipId);\n    }\n    compare(others) {\n        return this.identifyKey === others.identifyKey;\n    }\n    toObject() {\n        return {\n            x: this._x,\n            y: this._y,\n            chipId: this._chipId,\n            renderingArea: this._renderingArea\n        };\n    }\n    static fromObject(val) {\n        return new MapChipFragment(val.x, val.y, val.chipId, val.renderingArea);\n    }\n}\nclass MapChip {\n    constructor(_items = [], _arrangementName = '') {\n        this._items = _items;\n        this._arrangementName = _arrangementName;\n        this._identifyKey = '';\n        this._buildIdentifyKey();\n    }\n    get items() {\n        return this._items;\n    }\n    get identifyKey() {\n        return this._identifyKey;\n    }\n    get length() {\n        return this._items.length;\n    }\n    get arrangementName() {\n        return this._arrangementName;\n    }\n    _buildIdentifyKey() {\n        this._identifyKey = this._items.map(item => item.identifyKey).join('|');\n    }\n    setArrangementName(name) {\n        this._arrangementName = name;\n    }\n    push(mapChip) {\n        this._items.push(mapChip);\n        this._buildIdentifyKey();\n    }\n    clear() {\n        this._items.length = 0;\n        this._buildIdentifyKey();\n    }\n    clone() {\n        const cloned = new MapChip();\n        cloned._items = this._items.map(mapChip => mapChip.clone());\n        return cloned;\n    }\n    compare(others) {\n        return this.identifyKey === others.identifyKey;\n    }\n    toObject() {\n        return {\n            items: this._items.map(item => item.toObject()),\n            arrangementName: this._arrangementName\n        };\n    }\n    static fromObject(val) {\n        return new MapChip(val.items.map(item => MapChipFragment.fromObject(item)), val.arrangementName);\n    }\n}\nfunction isAutoTileMapChipProperties(obj) {\n    return obj &&\n        typeof obj.autoTileId === 'number' &&\n        obj.boundary !== undefined &&\n        obj.cross !== undefined;\n}\nclass AutoTileMapChip extends MapChip {\n    constructor(_autoTileId, items = [], _arrangementName = '', _boundary = {\n        top: false,\n        bottom: false,\n        left: false,\n        right: false\n    }, _cross = {\n        topLeft: false,\n        topRight: false,\n        bottomLeft: false,\n        bottomRight: false\n    }) {\n        super(items, _arrangementName);\n        this._autoTileId = _autoTileId;\n        this._boundary = _boundary;\n        this._cross = _cross;\n    }\n    get boundary() {\n        return this._boundary;\n    }\n    get cross() {\n        return this._cross;\n    }\n    get autoTileId() {\n        return this._autoTileId;\n    }\n    setBoundary(boundary) {\n        this._boundary = boundary;\n    }\n    setCross(cross) {\n        this._cross = cross;\n    }\n    toObject() {\n        return {\n            ...super.toObject(),\n            boundary: this._boundary,\n            cross: this._cross,\n            autoTileId: this._autoTileId\n        };\n    }\n    static fromObject(val) {\n        return new AutoTileMapChip(val.autoTileId, val.items.map(item => MapChipFragment.fromObject(item)), val.arrangementName, val.boundary, val.cross);\n    }\n}\nfunction isAutoTileMapChip(obj) {\n    return obj &&\n        typeof obj.boundary === 'object' &&\n        typeof obj.cross === 'object';\n}\n\n\n/***/ }),\n/* 7 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_16692__) => {\n\n__nested_webpack_require_16692__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_16692__.d(__webpack_exports__, {\n/* harmony export */   \"TiledMapData\": () => (/* binding */ TiledMapData)\n/* harmony export */ });\n/* harmony import */ var _MapChip__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_16692__(6);\n/* harmony import */ var _MapPaletteMatrix__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_16692__(8);\n\n\nclass TiledMapData extends _MapPaletteMatrix__WEBPACK_IMPORTED_MODULE_1__.MapPaletteMatrix {\n    filter(needles) {\n        const filtered = this.items.map(chip => needles.some(needle => !!chip && needle.compare(chip)) ? chip : null);\n        return new TiledMapData(this.width, this.height, filtered);\n    }\n    findByImage(image) {\n        const registeredChips = new Set();\n        return this.items.filter(chip => {\n            if (!chip)\n                return false;\n            const found = chip.items.find(fragment => fragment.chipId === image.id) && !registeredChips.has(chip.identifyKey);\n            if (found) {\n                registeredChips.add(chip.identifyKey);\n            }\n            return found;\n        });\n    }\n    toObject() {\n        return {\n            chipCountX: this.width,\n            chipCountY: this.height,\n            values: this.values.items,\n            palette: this.palette.map(data => data ? data.toObject() : null)\n        };\n    }\n    static fromObject(val) {\n        const palette = val.palette.map(data => {\n            if (!data)\n                return null;\n            if ((0,_MapChip__WEBPACK_IMPORTED_MODULE_0__.isAutoTileMapChipProperties)(data)) {\n                return _MapChip__WEBPACK_IMPORTED_MODULE_0__.AutoTileMapChip.fromObject(data);\n            }\n            return _MapChip__WEBPACK_IMPORTED_MODULE_0__.MapChip.fromObject(data);\n        });\n        const tiledMapData = new TiledMapData(val.chipCountX, val.chipCountY, []);\n        tiledMapData.setValuePalette(val.values, palette);\n        return tiledMapData;\n    }\n}\n\n\n/***/ }),\n/* 8 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_18777__) => {\n\n__nested_webpack_require_18777__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_18777__.d(__webpack_exports__, {\n/* harmony export */   \"MapPaletteMatrix\": () => (/* binding */ MapPaletteMatrix)\n/* harmony export */ });\n/* harmony import */ var _TransferEach__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_18777__(9);\n/* harmony import */ var _MapMatrix__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_18777__(10);\n\n\nclass MapPaletteMatrix {\n    constructor(chipCountX, chipCountY, items = []) {\n        this._paletteIndexes = new Map();\n        this._values = new _MapMatrix__WEBPACK_IMPORTED_MODULE_1__.MapMatrix(0, 0, []);\n        this._palette = [];\n        this._values = new _MapMatrix__WEBPACK_IMPORTED_MODULE_1__.MapMatrix(chipCountX, chipCountY, new Array(chipCountY * chipCountX).fill(-1));\n        if (items.length > 0) {\n            this.set(items);\n        }\n    }\n    get size() {\n        return this._values.size;\n    }\n    get width() {\n        return this._values.width;\n    }\n    get height() {\n        return this._values.height;\n    }\n    get items() {\n        return this._values.items.map(value => value >= 0 ? this._palette[value] : null);\n    }\n    get palette() {\n        return this._palette;\n    }\n    get values() {\n        return this._values;\n    }\n    set(items) {\n        if (items.length !== this._values.items.length)\n            throw new Error();\n        this._values.set(items.map(value => this._getOrGeneratePaletteIndex(value)));\n    }\n    setValuePalette(values, palette) {\n        if (values.length !== this._values.items.length)\n            throw new Error();\n        this._values.set([...values]);\n        this._palette = [...palette];\n        this._paletteIndexes.clear();\n        for (const [index, paletteItem] of this._palette.entries()) {\n            if (!paletteItem)\n                continue;\n            if (this._paletteIndexes.has(paletteItem.identifyKey)) {\n                this.rebuild();\n                break;\n            }\n            this._paletteIndexes.set(paletteItem.identifyKey, index);\n        }\n    }\n    transferFromTiledMapData(src, srcX, srcY, width, height, destX, destY) {\n        (0,_TransferEach__WEBPACK_IMPORTED_MODULE_0__.transferEach)(srcX, srcY, width, height, destX, destY, src.width, src.height, this.width, this.height, (pickupX, pickupY, putX, putY) => {\n            const item = src.getFromChipPosition(pickupX, pickupY);\n            this._values.put(this._getOrGeneratePaletteIndex(item), putX, putY);\n        });\n    }\n    resize(chipCountX, chipCountY, emptyValue) {\n        this._values.resize(chipCountX, chipCountY, this._getOrGeneratePaletteIndex(emptyValue));\n    }\n    getFromChipPosition(x, y) {\n        const paletteIndex = this._values.getFromChipPosition(x, y);\n        return paletteIndex >= 0 ? this._palette[paletteIndex] : null;\n    }\n    put(item, x, y) {\n        this._values.put(this._getOrGeneratePaletteIndex(item), x, y);\n    }\n    clone() {\n        const cloned = new MapPaletteMatrix(this.width, this.height);\n        cloned.setValuePalette(this._values.items, this._palette);\n        return cloned;\n    }\n    rebuild() {\n        const items = this.items;\n        this._palette = [];\n        this._paletteIndexes.clear();\n        this.set(items);\n    }\n    remove(target) {\n        if (!target)\n            return false;\n        const removePaletteId = this.palette.findIndex(item => (item === null || item === void 0 ? void 0 : item.identifyKey) === target.identifyKey);\n        if (removePaletteId < 0)\n            return false;\n        this.palette.splice(removePaletteId, 1);\n        this.values.items.forEach((paletteIndex, valueIndex) => {\n            if (paletteIndex === removePaletteId)\n                this.values.items[valueIndex] = -1;\n            if (paletteIndex > removePaletteId)\n                this.values.items[valueIndex] = this.values.items[valueIndex] - 1;\n        });\n        for (const [k, v] of this._paletteIndexes.entries()) {\n            if (v > removePaletteId)\n                this._paletteIndexes.set(k, v - 1);\n        }\n        this._paletteIndexes.delete(target.identifyKey);\n        return true;\n    }\n    getPaletteIndex(value) {\n        if (value === null)\n            return -1;\n        return this._paletteIndexes.get(value.identifyKey);\n    }\n    _getOrGeneratePaletteIndex(value) {\n        if (value === null)\n            return -1;\n        const index = this.getPaletteIndex(value);\n        if (index !== undefined)\n            return index;\n        this._palette.push(value);\n        const addedIndex = this._palette.length - 1;\n        this._paletteIndexes.set(value.identifyKey, addedIndex);\n        return addedIndex;\n    }\n}\n\n\n/***/ }),\n/* 9 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_23546__) => {\n\n__nested_webpack_require_23546__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_23546__.d(__webpack_exports__, {\n/* harmony export */   \"transferEach\": () => (/* binding */ transferEach)\n/* harmony export */ });\nfunction transferEach(srcX, srcY, width, height, destX, destY, srcWidth, srcHeight, destWidth, destHeight, callback) {\n    for (let x = 0; x < width; x++) {\n        const putX = destX + x;\n        const pickupX = srcX + x;\n        if (putX < 0 || putX >= destWidth)\n            continue;\n        if (pickupX < 0 || pickupX >= srcWidth)\n            continue;\n        for (let y = 0; y < height; y++) {\n            const putY = destY + y;\n            const pickupY = srcY + y;\n            if (putY < 0 || putY >= destHeight)\n                continue;\n            if (pickupY < 0 || pickupY >= srcHeight)\n                continue;\n            callback(pickupX, pickupY, putX, putY);\n        }\n    }\n}\n\n\n/***/ }),\n/* 10 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_24555__) => {\n\n__nested_webpack_require_24555__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_24555__.d(__webpack_exports__, {\n/* harmony export */   \"MapMatrix\": () => (/* binding */ MapMatrix)\n/* harmony export */ });\n/* harmony import */ var _TransferEach__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_24555__(9);\n\nclass MapMatrix {\n    constructor(_chipCountX, _chipCountY, items = []) {\n        this._chipCountX = _chipCountX;\n        this._chipCountY = _chipCountY;\n        this._items = [];\n        if (items.length > 0 && this.size !== items.length) {\n            throw new Error();\n        }\n        if (items.length === 0) {\n            this.allocate();\n        }\n        else {\n            this._items = items;\n        }\n    }\n    get size() {\n        return this._chipCountX * this._chipCountY;\n    }\n    get width() {\n        return this._chipCountX;\n    }\n    get height() {\n        return this._chipCountY;\n    }\n    get items() {\n        return this._items;\n    }\n    set(items) {\n        if (items.length !== this._items.length)\n            throw new Error();\n        this._items = items;\n    }\n    transferFromTiledMapData(src, srcX, srcY, width, height, destX, destY) {\n        (0,_TransferEach__WEBPACK_IMPORTED_MODULE_0__.transferEach)(srcX, srcY, width, height, destX, destY, src.width, src.height, this.width, this.height, (pickupX, pickupY, putX, putY) => {\n            const item = src.getFromChipPosition(pickupX, pickupY);\n            this.put(item, putX, putY);\n        });\n    }\n    resize(chipCountX, chipCountY, emptyValue) {\n        const src = this.clone();\n        this._chipCountX = chipCountX;\n        this._chipCountY = chipCountY;\n        this.allocate(emptyValue);\n        this.transferFromTiledMapData(src, 0, 0, src.width, src.height, 0, 0);\n    }\n    getFromChipPosition(x, y) {\n        if (this.isOutOfRange(x, y))\n            throw new Error('The position is out of range.');\n        const mapNumber = this.convertPositionToMapNumber(x, y);\n        return this._items[mapNumber];\n    }\n    put(item, x, y) {\n        const mapNumber = this.convertPositionToMapNumber(x, y);\n        this._items[mapNumber] = item;\n    }\n    clone() {\n        return new MapMatrix(this._chipCountX, this._chipCountY, this._items);\n    }\n    convertPositionToMapNumber(x, y) {\n        return y * this._chipCountX + x;\n    }\n    isOutOfRange(x, y) {\n        return (x < 0) || (y < 0) || (x >= this._chipCountX) || (y >= this._chipCountY);\n    }\n    allocate(defaultValue = null) {\n        this._items = new Array(this._chipCountY * this._chipCountX).fill(defaultValue);\n    }\n}\n\n\n/***/ }),\n/* 11 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_27237__) => {\n\n__nested_webpack_require_27237__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_27237__.d(__webpack_exports__, {\n/* harmony export */   \"ColiderMap\": () => (/* binding */ ColiderMap)\n/* harmony export */ });\n/* harmony import */ var _MapMatrix__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_27237__(10);\n\nclass ColiderMap extends _MapMatrix__WEBPACK_IMPORTED_MODULE_0__.MapMatrix {\n    toObject() {\n        return {\n            chipCountX: this._chipCountX,\n            chipCountY: this._chipCountY,\n            coliders: this._items\n        };\n    }\n    static fromObject(val) {\n        return new ColiderMap(val.chipCountX, val.chipCountY, val.coliders);\n    }\n    allocate() {\n        super.allocate(0);\n    }\n}\n\n\n/***/ }),\n/* 12 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_28047__) => {\n\n__nested_webpack_require_28047__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_28047__.d(__webpack_exports__, {\n/* harmony export */   \"DefaultAutoTileImportStrategy\": () => (/* binding */ DefaultAutoTileImportStrategy)\n/* harmony export */ });\n/* harmony import */ var _MapChip__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_28047__(6);\n\nclass DefaultAutoTileImportStrategy {\n    constructor(_mapChipImage, _chipWidth, _chipHeight) {\n        this._mapChipImage = _mapChipImage;\n        this._chipWidth = _chipWidth;\n        this._chipHeight = _chipHeight;\n    }\n    getMapChipFragments() {\n        const heightChipCountPerUnit = 5;\n        const countX = Math.floor(this._mapChipImage.image.width / this._chipWidth);\n        const countY = Math.floor(Math.floor(this._mapChipImage.image.height / this._chipHeight) / heightChipCountPerUnit);\n        const mapChipFragmentGroups = [];\n        for (let cy = 0; cy < countY; cy++) {\n            const y = cy * heightChipCountPerUnit;\n            for (let x = 0; x < countX; x++) {\n                const mapChipFragments = [];\n                mapChipFragments.push(new _MapChip__WEBPACK_IMPORTED_MODULE_0__.MapChipFragment(x, y, this._mapChipImage.id));\n                mapChipFragments.push(new _MapChip__WEBPACK_IMPORTED_MODULE_0__.MapChipFragment(x, y + 1, this._mapChipImage.id));\n                mapChipFragments.push(new _MapChip__WEBPACK_IMPORTED_MODULE_0__.MapChipFragment(x, y + 2, this._mapChipImage.id));\n                mapChipFragments.push(new _MapChip__WEBPACK_IMPORTED_MODULE_0__.MapChipFragment(x, y + 3, this._mapChipImage.id));\n                mapChipFragments.push(new _MapChip__WEBPACK_IMPORTED_MODULE_0__.MapChipFragment(x, y + 4, this._mapChipImage.id));\n                mapChipFragmentGroups.push(mapChipFragments);\n            }\n        }\n        return mapChipFragmentGroups;\n    }\n}\n\n\n/***/ }),\n/* 13 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_29999__) => {\n\n__nested_webpack_require_29999__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_29999__.d(__webpack_exports__, {\n/* harmony export */   \"MapRenderer\": () => (/* binding */ MapRenderer)\n/* harmony export */ });\nclass MapRenderer {\n    constructor(_tiledMap) {\n        this._tiledMap = _tiledMap;\n        this._backgroundRgba = { r: 255, g: 255, b: 255, a: 1.0 };\n    }\n    setTiledMap(tiledMap) {\n        this._tiledMap = tiledMap;\n    }\n    renderAll(ctx) {\n        this._tiledMap.datas.forEach(data => this.render(data, ctx));\n    }\n    renderLayer(index, ctx) {\n        this.render(this._tiledMap.datas[index], ctx);\n    }\n    render(data, ctx) {\n        data.items.forEach((value, index) => {\n            const position = this._tiledMap.convertMapNumberToPosition(index);\n            this.putOrClearChipToCanvas(ctx, value, position.x, position.y);\n        });\n    }\n    putOrClearChipToCanvas(ctx, mapChip, chipX, chipY, isTemporaryRendering = false) {\n        if (!mapChip) {\n            this._clearChipToCanvas(ctx, chipX, chipY, isTemporaryRendering);\n        }\n        else {\n            mapChip.items.forEach(item => {\n                this._putChipToCanvas(ctx, item, chipX, chipY);\n            });\n        }\n    }\n    _clearChipToCanvas(ctx, chipX, chipY, isTemporaryRendering) {\n        const position = this._tiledMap.convertChipPositionToPixel(chipX, chipY);\n        ctx.clearRect(position.x, position.y, this._tiledMap.chipWidth, this._tiledMap.chipHeight);\n        if (isTemporaryRendering) {\n            ctx.fillStyle = `rgba(${this._backgroundRgba.r},${this._backgroundRgba.g},${this._backgroundRgba.b},${this._backgroundRgba.a})`;\n            ctx.fillRect(position.x, position.y, this._tiledMap.chipWidth, this._tiledMap.chipHeight);\n        }\n    }\n    _putChipToCanvas(ctx, mapChip, chipX, chipY) {\n        const mapChips = this._tiledMap.mapChipsCollection.findById(mapChip.chipId);\n        const image = mapChips === null || mapChips === void 0 ? void 0 : mapChips.image;\n        if (!image)\n            return;\n        const renderingArea = this._getRenderingArea(mapChip);\n        const position = this._tiledMap.convertChipPositionToPixel(chipX, chipY);\n        position.x += renderingArea.destOffsetX;\n        position.y += renderingArea.destOffsetY;\n        ctx.clearRect(position.x, position.y, renderingArea.width, renderingArea.height);\n        ctx.drawImage(image, renderingArea.x, renderingArea.y, renderingArea.width, renderingArea.height, position.x, position.y, renderingArea.width, renderingArea.height);\n    }\n    _getRenderingArea(mapChip) {\n        const width = this._tiledMap.chipWidth;\n        const height = this._tiledMap.chipHeight;\n        const x = mapChip.x * width;\n        const y = mapChip.y * height;\n        if (mapChip.renderingArea === 15) {\n            return { x, y, width, height, destOffsetX: 0, destOffsetY: 0 };\n        }\n        const halfWidth = Math.round(width / 2);\n        const halfHeight = Math.round(height / 2);\n        switch (mapChip.renderingArea) {\n            case 1:\n                return { x, y, width: halfWidth, height: halfHeight, destOffsetX: 0, destOffsetY: 0 };\n            case 2:\n                return { x: x + halfWidth, y, width: halfWidth, height: halfHeight, destOffsetX: halfWidth, destOffsetY: 0 };\n            case 3:\n                return { x, y, width, height: halfHeight, destOffsetX: 0, destOffsetY: 0 };\n            case 4:\n                return { x, y: y + halfHeight, width: halfWidth, height: halfHeight, destOffsetX: 0, destOffsetY: halfHeight };\n            case 5:\n                return { x, y, width: halfWidth, height, destOffsetX: 0, destOffsetY: 0 };\n            case 8:\n                return { x: x + halfWidth, y: y + halfHeight, width: halfWidth, height: halfHeight, destOffsetX: halfWidth, destOffsetY: halfHeight };\n            case 10:\n                return { x: x + halfWidth, y, width: halfWidth, height, destOffsetX: halfWidth, destOffsetY: 0 };\n            case 12:\n                return { x, y: y + halfHeight, width, height: halfHeight, destOffsetX: 0, destOffsetY: halfHeight };\n        }\n    }\n}\n\n\n/***/ })\n/******/ \t]);\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_34379__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_34379__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/define property getters */\n/******/ \t(() => {\n/******/ \t\t// define getter functions for harmony exports\n/******/ \t\t__nested_webpack_require_34379__.d = (exports, definition) => {\n/******/ \t\t\tfor(var key in definition) {\n/******/ \t\t\t\tif(__nested_webpack_require_34379__.o(definition, key) && !__nested_webpack_require_34379__.o(exports, key)) {\n/******/ \t\t\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n/******/ \t\t\t\t}\n/******/ \t\t\t}\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/hasOwnProperty shorthand */\n/******/ \t(() => {\n/******/ \t\t__nested_webpack_require_34379__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/make namespace object */\n/******/ \t(() => {\n/******/ \t\t// define __esModule on exports\n/******/ \t\t__nested_webpack_require_34379__.r = (exports) => {\n/******/ \t\t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t\t}\n/******/ \t\t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/************************************************************************/\nvar __webpack_exports__ = {};\n// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.\n(() => {\n__nested_webpack_require_34379__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_34379__.d(__webpack_exports__, {\n/* harmony export */   \"TiledMap\": () => (/* reexport safe */ _TiledMap__WEBPACK_IMPORTED_MODULE_0__.TiledMap),\n/* harmony export */   \"TiledMapData\": () => (/* reexport safe */ _MapData_TiledMapData__WEBPACK_IMPORTED_MODULE_1__.TiledMapData),\n/* harmony export */   \"MapChipImage\": () => (/* reexport safe */ _MapChipImage__WEBPACK_IMPORTED_MODULE_2__.MapChipImage),\n/* harmony export */   \"MapChipsCollection\": () => (/* reexport safe */ _MapChipsCollection__WEBPACK_IMPORTED_MODULE_3__.MapChipsCollection),\n/* harmony export */   \"MapChipFragment\": () => (/* reexport safe */ _MapChip__WEBPACK_IMPORTED_MODULE_4__.MapChipFragment),\n/* harmony export */   \"MapChip\": () => (/* reexport safe */ _MapChip__WEBPACK_IMPORTED_MODULE_4__.MapChip),\n/* harmony export */   \"AutoTileMapChip\": () => (/* reexport safe */ _MapChip__WEBPACK_IMPORTED_MODULE_4__.AutoTileMapChip),\n/* harmony export */   \"isAutoTileMapChip\": () => (/* reexport safe */ _MapChip__WEBPACK_IMPORTED_MODULE_4__.isAutoTileMapChip),\n/* harmony export */   \"AutoTiles\": () => (/* reexport safe */ _AutoTile_AutoTiles__WEBPACK_IMPORTED_MODULE_5__.AutoTiles),\n/* harmony export */   \"AutoTile\": () => (/* reexport safe */ _AutoTile_AutoTile__WEBPACK_IMPORTED_MODULE_6__.AutoTile),\n/* harmony export */   \"DefaultAutoTileImportStrategy\": () => (/* reexport safe */ _AutoTile_DefaultAutoTileImportStrategy__WEBPACK_IMPORTED_MODULE_7__.DefaultAutoTileImportStrategy),\n/* harmony export */   \"ColiderMap\": () => (/* reexport safe */ _MapData_ColiderMap__WEBPACK_IMPORTED_MODULE_8__.ColiderMap),\n/* harmony export */   \"MapRenderer\": () => (/* reexport safe */ _MapRenderer__WEBPACK_IMPORTED_MODULE_9__.MapRenderer)\n/* harmony export */ });\n/* harmony import */ var _TiledMap__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_34379__(1);\n/* harmony import */ var _MapData_TiledMapData__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_34379__(7);\n/* harmony import */ var _MapChipImage__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_34379__(3);\n/* harmony import */ var _MapChipsCollection__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_34379__(2);\n/* harmony import */ var _MapChip__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_34379__(6);\n/* harmony import */ var _AutoTile_AutoTiles__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_34379__(4);\n/* harmony import */ var _AutoTile_AutoTile__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_34379__(5);\n/* harmony import */ var _AutoTile_DefaultAutoTileImportStrategy__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_34379__(12);\n/* harmony import */ var _MapData_ColiderMap__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_34379__(11);\n/* harmony import */ var _MapRenderer__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_34379__(13);\n\n\n\n\n\n\n\n\n\n\n\n})();\n\n/******/ \treturn __webpack_exports__;\n/******/ })()\n;\n});\n//# sourceMappingURL=main.js.map\n\n/***/ }),\n/* 5 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_54878__) => {\n\n\"use strict\";\n__nested_webpack_require_54878__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_54878__.d(__webpack_exports__, {\n/* harmony export */   \"PenDescription\": () => (/* binding */ PenDescription),\n/* harmony export */   \"Pen\": () => (/* binding */ Pen)\n/* harmony export */ });\nconst PenDescription = {\n    name: 'Pen',\n    create: () => new Pen()\n};\nclass Pen {\n    constructor() {\n        this._isMouseDown = false;\n        this.painting = [];\n        this._beforeCursorPosition = { x: -1, y: -1 };\n        this._arrangement = null;\n    }\n    setArrangement(arrangement) {\n        this._arrangement = arrangement;\n    }\n    mouseDown(chipX, chipY) {\n        this._isMouseDown = true;\n        this.painting = [];\n    }\n    mouseMove(chipX, chipY) {\n        if (!this._arrangement)\n            throw new Error('Arrangement is not set.');\n        if (!this._isMouseDown)\n            return [];\n        const paint = {\n            x: chipX,\n            y: chipY,\n            item: null\n        };\n        if (paint.x !== this._beforeCursorPosition.x || paint.y !== this._beforeCursorPosition.y) {\n            this.painting.push(paint);\n            this._beforeCursorPosition = paint;\n        }\n        return this._arrangement.apply(this.painting);\n    }\n    mouseUp(chipX, chipY) {\n        if (!this._arrangement)\n            throw new Error('Arrangement is not set.');\n        this._isMouseDown = false;\n        return this._arrangement.apply(this.painting);\n    }\n    cleanUp() {\n        this.painting.length = 0;\n        this._beforeCursorPosition = { x: -1, y: -1 };\n    }\n}\n\n\n/***/ }),\n/* 6 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_56563__) => {\n\n\"use strict\";\n__nested_webpack_require_56563__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_56563__.d(__webpack_exports__, {\n/* harmony export */   \"Brushes\": () => (/* binding */ Brushes)\n/* harmony export */ });\n/* harmony import */ var _Pen__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_56563__(5);\n/* harmony import */ var _RectangleBrush__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_56563__(7);\n\n\nconst registeredBrushDescriptions = [\n    _Pen__WEBPACK_IMPORTED_MODULE_0__.PenDescription,\n    _RectangleBrush__WEBPACK_IMPORTED_MODULE_1__.RectangleBrushDescription\n];\nconst Brushes = registeredBrushDescriptions.map(description => ({\n    name: description.name,\n    create: () => description.create()\n}));\n\n\n/***/ }),\n/* 7 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_57368__) => {\n\n\"use strict\";\n__nested_webpack_require_57368__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_57368__.d(__webpack_exports__, {\n/* harmony export */   \"RectangleBrushDescription\": () => (/* binding */ RectangleBrushDescription),\n/* harmony export */   \"RectangleBrush\": () => (/* binding */ RectangleBrush)\n/* harmony export */ });\nconst RectangleBrushDescription = {\n    name: 'RectangleBrush',\n    create: () => new RectangleBrush()\n};\nclass RectangleBrush {\n    constructor() {\n        this._isMouseDown = false;\n        this._startPosition = { x: 0, y: 0 };\n        this._arrangement = null;\n    }\n    setArrangement(arrangement) {\n        this._arrangement = arrangement;\n    }\n    mouseDown(chipX, chipY) {\n        this._isMouseDown = true;\n        this._startPosition = { x: chipX, y: chipY };\n    }\n    mouseMove(chipX, chipY) {\n        if (!this._isMouseDown)\n            return [];\n        return this._build(chipX, chipY);\n    }\n    mouseUp(chipX, chipY) {\n        this._isMouseDown = false;\n        return this._build(chipX, chipY);\n    }\n    _build(chipX, chipY) {\n        if (!this._arrangement)\n            throw new Error('Arrangement is not set.');\n        const paints = [];\n        const startX = Math.min(this._startPosition.x, chipX);\n        const startY = Math.min(this._startPosition.y, chipY);\n        const endX = Math.max(this._startPosition.x, chipX);\n        const endY = Math.max(this._startPosition.y, chipY);\n        for (let x = startX; x <= endX; x++) {\n            for (let y = startY; y <= endY; y++) {\n                paints.push({ x, y });\n            }\n        }\n        return this._arrangement.apply(paints);\n    }\n    cleanUp() {\n    }\n}\n\n\n/***/ }),\n/* 8 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_59145__) => {\n\n\"use strict\";\n__nested_webpack_require_59145__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_59145__.d(__webpack_exports__, {\n/* harmony export */   \"Arrangements\": () => (/* binding */ Arrangements)\n/* harmony export */ });\n/* harmony import */ var _DefaultArrangement__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_59145__(9);\n/* harmony import */ var _AutoTileArrangement__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_59145__(10);\n/* harmony import */ var _DefaultEraseArrangement__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_59145__(11);\n\n\n\nconst registeredArrangementDescriptions = [\n    _DefaultArrangement__WEBPACK_IMPORTED_MODULE_0__.DefaultArrangementDescription,\n    _AutoTileArrangement__WEBPACK_IMPORTED_MODULE_1__.AutoTileArrangementDescription,\n    _DefaultEraseArrangement__WEBPACK_IMPORTED_MODULE_2__.DefaultEraseArrangementDescription\n];\nconst Arrangements = registeredArrangementDescriptions.map(description => ({\n    name: description.name,\n    create: () => description.create()\n}));\n\n\n/***/ }),\n/* 9 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_60239__) => {\n\n\"use strict\";\n__nested_webpack_require_60239__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_60239__.d(__webpack_exports__, {\n/* harmony export */   \"DefaultArrangementDescription\": () => (/* binding */ DefaultArrangementDescription),\n/* harmony export */   \"DefaultArrangement\": () => (/* binding */ DefaultArrangement)\n/* harmony export */ });\n/* harmony import */ var _piyoppi_pico2map_tiled__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_60239__(4);\n/* harmony import */ var _piyoppi_pico2map_tiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_60239__.n(_piyoppi_pico2map_tiled__WEBPACK_IMPORTED_MODULE_0__);\n\nconst DefaultArrangementDescription = {\n    name: 'DefaultArrangement',\n    create: () => new DefaultArrangement()\n};\nclass DefaultArrangement {\n    constructor() {\n        this._mapChips = [];\n    }\n    setMapChips(mapChips) {\n        if (mapChips.length < 1)\n            throw new Error('Invalid count of map chips. DefaultArrangement requires a map chip.');\n        this._mapChips = mapChips;\n    }\n    apply(paints) {\n        if (this._mapChips.length < 1)\n            throw new Error('Invalid count of map chips. DefaultArrangement requires a map chip.');\n        const basePosition = { x: this._mapChips[0].x, y: this._mapChips[0].y };\n        return paints.map(paint => {\n            return this._mapChips.map(mapChip => ({\n                x: paint.x + mapChip.x - basePosition.x,\n                y: paint.y + mapChip.y - basePosition.y,\n                item: new _piyoppi_pico2map_tiled__WEBPACK_IMPORTED_MODULE_0__.MapChip([mapChip])\n            }));\n        }).flat(1);\n    }\n}\n\n\n/***/ }),\n/* 10 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_61956__) => {\n\n\"use strict\";\n__nested_webpack_require_61956__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_61956__.d(__webpack_exports__, {\n/* harmony export */   \"AutoTileArrangementDescription\": () => (/* binding */ AutoTileArrangementDescription),\n/* harmony export */   \"AutoTileArrangement\": () => (/* binding */ AutoTileArrangement)\n/* harmony export */ });\n/* harmony import */ var _piyoppi_pico2map_tiled__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_61956__(4);\n/* harmony import */ var _piyoppi_pico2map_tiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_61956__.n(_piyoppi_pico2map_tiled__WEBPACK_IMPORTED_MODULE_0__);\n\nconst AutoTileArrangementDescription = {\n    name: 'AutoTileArrangement',\n    create: () => new AutoTileArrangement()\n};\n/**\n * AutoTileArrangement\n *\n * Supported auto tile format is shown below.\n *\n * |<---------- 1chip ----------->|\n * ┏━┿┿┿┿┿┿┿┿┓---\n * ┠isolated                   ┠↑\n * ┣┿┿┿┿┿┿┿┿┿┫ |\n * ┠straight road (lengthwise) ┠ |\n * ┣┿┿┿┿┿┿┿┿┿┫ |\n * ┠straight road (sideways)   ┠5chips\n * ┣┿┿┿┿┿┿┿┿┿┫ |\n * ┠cross road                 ┠ |\n * ┣┿┿┿┿┿┿┿┿┿┫ |\n * ┠square                     ┠↓\n * ┗┷┿┿┿┿┿┿┿┿┛---\n */\nclass AutoTileArrangement {\n    constructor() {\n        this._autoTile = null;\n        this._tiledMapData = null;\n        this.temporaryChip = new _piyoppi_pico2map_tiled__WEBPACK_IMPORTED_MODULE_0__.AutoTileMapChip(-1, [new _piyoppi_pico2map_tiled__WEBPACK_IMPORTED_MODULE_0__.MapChipFragment(-1, -1, -1)]);\n    }\n    get tiledMapData() {\n        return this._tiledMapData;\n    }\n    setMapChips(mapChips) {\n    }\n    setAutoTile(autoTile) {\n        if (autoTile.mapChipFragments.length !== 5)\n            throw new Error('Too few map chips. AutoTileArrangement requires 5 map chips.');\n        this._autoTile = autoTile;\n    }\n    setTiledMapData(tiledMapData) {\n        this._tiledMapData = tiledMapData;\n    }\n    apply(paints) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;\n        if (!this._tiledMapData)\n            throw new Error('MapData is not set.');\n        const result = [];\n        const x1 = paints.reduce((acc, val) => Math.min(acc, val.x), this._tiledMapData.width);\n        const y1 = paints.reduce((acc, val) => Math.min(acc, val.y), this._tiledMapData.height);\n        const x2 = paints.reduce((acc, val) => Math.max(acc, val.x), 0);\n        const y2 = paints.reduce((acc, val) => Math.max(acc, val.y), 0);\n        const size = {\n            width: x2 - x1 + 1,\n            height: y2 - y1 + 1\n        };\n        const sizeWithPatch = {\n            width: size.width + 2,\n            height: size.height + 2\n        };\n        const tiledBuffer = new _piyoppi_pico2map_tiled__WEBPACK_IMPORTED_MODULE_0__.TiledMapData(sizeWithPatch.width, sizeWithPatch.height);\n        const offsetX1 = 1;\n        const offsetY1 = 1;\n        const offsetX2 = 1;\n        const offsetY2 = 1;\n        tiledBuffer.transferFromTiledMapData(this._tiledMapData, x1 - offsetX1, y1 - offsetY1, sizeWithPatch.width + offsetX2, sizeWithPatch.height + offsetY2, 0, 0);\n        paints.forEach(paint => {\n            const x = paint.x - x1 + offsetX1;\n            const y = paint.y - y1 + offsetY1;\n            tiledBuffer.put(this.temporaryChip, x, y);\n        });\n        for (let y = offsetY1; y < size.height + offsetY2; y++) {\n            for (let x = offsetX1; x < size.width + offsetX2; x++) {\n                const cursor = tiledBuffer.getFromChipPosition(x, y);\n                const targetChip = tiledBuffer.getFromChipPosition(x, y);\n                const isTemporaryChip = targetChip ? this.temporaryChip.compare(targetChip) : false;\n                if (!cursor)\n                    continue;\n                if (!isTemporaryChip)\n                    continue;\n                /**\n                 * adjacent\n                 *\n                 *  x      : processing point\n                 *  others : patch number\n                 * *-----*-----*-----*\n                 * | 16  |  1  | 32  |\n                 * *-----*-----*-----*\n                 * |  2  |  x  |  4  |\n                 * *-----*-----*-----*\n                 * | 64  |  8  | 128 |\n                 * *-----*-----*-----*\n                 */\n                let adjacent = 0;\n                const aroundChips = [\n                    tiledBuffer.getFromChipPosition(x, y - 1),\n                    tiledBuffer.getFromChipPosition(x - 1, y),\n                    tiledBuffer.getFromChipPosition(x + 1, y),\n                    tiledBuffer.getFromChipPosition(x, y + 1),\n                    tiledBuffer.getFromChipPosition(x - 1, y - 1),\n                    tiledBuffer.getFromChipPosition(x + 1, y - 1),\n                    tiledBuffer.getFromChipPosition(x - 1, y + 1),\n                    tiledBuffer.getFromChipPosition(x + 1, y + 1)\n                ].map(mapChip => (0,_piyoppi_pico2map_tiled__WEBPACK_IMPORTED_MODULE_0__.isAutoTileMapChip)(mapChip) ? mapChip : null);\n                if (!((_a = aroundChips[0]) === null || _a === void 0 ? void 0 : _a.boundary.bottom))\n                    adjacent += this._isAdjacent(aroundChips[0]) ? 1 : 0;\n                if (!((_b = aroundChips[1]) === null || _b === void 0 ? void 0 : _b.boundary.right))\n                    adjacent += this._isAdjacent(aroundChips[1]) ? 2 : 0;\n                if (!((_c = aroundChips[2]) === null || _c === void 0 ? void 0 : _c.boundary.left))\n                    adjacent += this._isAdjacent(aroundChips[2]) ? 4 : 0;\n                if (!((_d = aroundChips[3]) === null || _d === void 0 ? void 0 : _d.boundary.top))\n                    adjacent += this._isAdjacent(aroundChips[3]) ? 8 : 0;\n                if (!((_e = aroundChips[4]) === null || _e === void 0 ? void 0 : _e.boundary.bottom) && !((_f = aroundChips[4]) === null || _f === void 0 ? void 0 : _f.boundary.right) && !((_g = aroundChips[4]) === null || _g === void 0 ? void 0 : _g.cross.bottomRight))\n                    adjacent += this._isAdjacent(aroundChips[4]) ? 16 : 0;\n                if (!((_h = aroundChips[5]) === null || _h === void 0 ? void 0 : _h.boundary.bottom) && !((_j = aroundChips[5]) === null || _j === void 0 ? void 0 : _j.boundary.left) && !((_k = aroundChips[5]) === null || _k === void 0 ? void 0 : _k.cross.bottomLeft))\n                    adjacent += this._isAdjacent(aroundChips[5]) ? 32 : 0;\n                if (!((_l = aroundChips[6]) === null || _l === void 0 ? void 0 : _l.boundary.top) && !((_m = aroundChips[6]) === null || _m === void 0 ? void 0 : _m.boundary.right) && !((_o = aroundChips[6]) === null || _o === void 0 ? void 0 : _o.cross.topRight))\n                    adjacent += this._isAdjacent(aroundChips[6]) ? 64 : 0;\n                if (!((_p = aroundChips[7]) === null || _p === void 0 ? void 0 : _p.boundary.top) && !((_q = aroundChips[7]) === null || _q === void 0 ? void 0 : _q.boundary.left) && !((_r = aroundChips[7]) === null || _r === void 0 ? void 0 : _r.cross.topLeft))\n                    adjacent += this._isAdjacent(aroundChips[7]) ? 128 : 0;\n                const item = this.getTiledPattern(adjacent, aroundChips);\n                if (item) {\n                    tiledBuffer.put(item, x, y);\n                    result.push({ x: x + x1 - offsetX1, y: y + y1 - offsetY1, item });\n                }\n            }\n        }\n        return result;\n    }\n    getTiledPattern(adjacent, aroundChips) {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        if (!this._autoTile)\n            return null;\n        const mapChip = new _piyoppi_pico2map_tiled__WEBPACK_IMPORTED_MODULE_0__.AutoTileMapChip(this._autoTile.id, [], 'AutoTileArrangement');\n        const mapChips = this._autoTile.mapChipFragments;\n        const boundary = {\n            top: false,\n            bottom: false,\n            left: false,\n            right: false\n        };\n        const cross = {\n            topLeft: false,\n            topRight: false,\n            bottomLeft: false,\n            bottomRight: false\n        };\n        if ((adjacent & 19) === 19 && !((_a = aroundChips[0]) === null || _a === void 0 ? void 0 : _a.cross.bottomLeft) && !((_b = aroundChips[1]) === null || _b === void 0 ? void 0 : _b.cross.topRight)) {\n            /* Square */\n            mapChip.push(mapChips[4].clone().withParameter({ renderingArea: 1 }));\n            boundary.top = false;\n            boundary.left = false;\n        }\n        else if ((adjacent & 3) === 2) {\n            /* Straight(sideways) */\n            mapChip.push(mapChips[2].clone().withParameter({ renderingArea: 1 }));\n            boundary.top = true;\n            boundary.left = false;\n        }\n        else if ((adjacent & 3) === 1) {\n            /* Straight(lengthwise) */\n            mapChip.push(mapChips[1].clone().withParameter({ renderingArea: 1 }));\n            boundary.top = false;\n            boundary.left = true;\n        }\n        else if ((adjacent & 3) === 0) {\n            /* Corner */\n            mapChip.push(mapChips[0].clone().withParameter({ renderingArea: 1 }));\n            boundary.top = true;\n            boundary.left = true;\n        }\n        else if ((adjacent & 19) === 3) {\n            /* Cross */\n            mapChip.push(mapChips[3].clone().withParameter({ renderingArea: 1 }));\n            boundary.top = false;\n            boundary.left = false;\n            cross.topLeft = true;\n        }\n        if ((adjacent & 37) === 37 && !((_c = aroundChips[0]) === null || _c === void 0 ? void 0 : _c.cross.bottomRight) && !((_d = aroundChips[2]) === null || _d === void 0 ? void 0 : _d.cross.topLeft)) {\n            mapChip.push(mapChips[4].clone().withParameter({ renderingArea: 2 }));\n        }\n        else if ((adjacent & 5) === 4) {\n            mapChip.push(mapChips[2].clone().withParameter({ renderingArea: 2 }));\n        }\n        else if ((adjacent & 5) === 1) {\n            mapChip.push(mapChips[1].clone().withParameter({ renderingArea: 2 }));\n        }\n        else if ((adjacent & 5) === 0) {\n            mapChip.push(mapChips[0].clone().withParameter({ renderingArea: 2 }));\n        }\n        else if ((adjacent & 37) === 5) {\n            mapChip.push(mapChips[3].clone().withParameter({ renderingArea: 2 }));\n            cross.topRight = true;\n        }\n        if ((adjacent & 74) === 74 && !((_e = aroundChips[1]) === null || _e === void 0 ? void 0 : _e.cross.bottomRight) && !((_f = aroundChips[3]) === null || _f === void 0 ? void 0 : _f.cross.topRight)) {\n            mapChip.push(mapChips[4].clone().withParameter({ renderingArea: 4 }));\n        }\n        else if ((adjacent & 10) === 2) {\n            mapChip.push(mapChips[2].clone().withParameter({ renderingArea: 4 }));\n        }\n        else if ((adjacent & 10) === 8) {\n            mapChip.push(mapChips[1].clone().withParameter({ renderingArea: 4 }));\n        }\n        else if ((adjacent & 10) === 0) {\n            mapChip.push(mapChips[0].clone().withParameter({ renderingArea: 4 }));\n        }\n        else if ((adjacent & 74) === 10) {\n            mapChip.push(mapChips[3].clone().withParameter({ renderingArea: 4 }));\n            cross.bottomLeft = true;\n        }\n        if ((adjacent & 140) === 140 && !((_g = aroundChips[2]) === null || _g === void 0 ? void 0 : _g.cross.bottomLeft) && !((_h = aroundChips[3]) === null || _h === void 0 ? void 0 : _h.cross.topRight)) {\n            mapChip.push(mapChips[4].clone().withParameter({ renderingArea: 8 }));\n            boundary.bottom = false;\n            boundary.right = false;\n        }\n        else if ((adjacent & 12) === 4) {\n            mapChip.push(mapChips[2].clone().withParameter({ renderingArea: 8 }));\n            boundary.bottom = true;\n            boundary.right = false;\n        }\n        else if ((adjacent & 12) === 8) {\n            mapChip.push(mapChips[1].clone().withParameter({ renderingArea: 8 }));\n            boundary.bottom = false;\n            boundary.right = true;\n        }\n        else if ((adjacent & 12) === 0) {\n            mapChip.push(mapChips[0].clone().withParameter({ renderingArea: 8 }));\n            boundary.bottom = true;\n            boundary.right = true;\n        }\n        else if ((adjacent & 140) === 12) {\n            mapChip.push(mapChips[3].clone().withParameter({ renderingArea: 8 }));\n            boundary.bottom = false;\n            boundary.right = false;\n            cross.bottomRight = true;\n        }\n        if (mapChip.length !== 4)\n            return null;\n        mapChip.setBoundary(boundary);\n        mapChip.setCross(cross);\n        return mapChip;\n    }\n    _isAdjacent(chip) {\n        if (chip === null)\n            return false;\n        const isTemporaryChip = this.temporaryChip.compare(chip);\n        const isAutoTileChip = this._isAutoTileChip(chip);\n        return isAutoTileChip || isTemporaryChip;\n    }\n    _isAutoTileChip(chip) {\n        if (!this._autoTile)\n            return false;\n        if (!chip)\n            return false;\n        return this._autoTile.id === chip.autoTileId;\n    }\n}\n\n\n/***/ }),\n/* 11 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_74956__) => {\n\n\"use strict\";\n__nested_webpack_require_74956__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_74956__.d(__webpack_exports__, {\n/* harmony export */   \"DefaultEraseArrangementDescription\": () => (/* binding */ DefaultEraseArrangementDescription),\n/* harmony export */   \"DefaultEraseArrangement\": () => (/* binding */ DefaultEraseArrangement)\n/* harmony export */ });\n/* harmony import */ var _EraseArrangement__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_74956__(12);\n/* harmony import */ var _AutoTileEraseArrangement__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_74956__(13);\n\n\nconst DefaultEraseArrangementDescription = {\n    name: 'DefaultEraseArrangement',\n    create: () => new DefaultEraseArrangement()\n};\nclass DefaultEraseArrangement {\n    constructor() {\n        this.defaultEraser = new _EraseArrangement__WEBPACK_IMPORTED_MODULE_0__.EraseArrangement();\n        this.autoTileEraser = new _AutoTileEraseArrangement__WEBPACK_IMPORTED_MODULE_1__.AutoTileEraseArrangement();\n        this._tiledMapData = null;\n    }\n    setTiledMapData(tiledMapData) {\n        this._tiledMapData = tiledMapData;\n        this.autoTileEraser.setTiledMapData(tiledMapData);\n    }\n    setAutoTiles(autoTiles) {\n        this.autoTileEraser.setAutoTiles(autoTiles);\n    }\n    apply(paints) {\n        const autoTilePaints = [];\n        const otherPaints = [];\n        paints.forEach(paint => {\n            if (!this._tiledMapData)\n                throw new Error('MapData is not set.');\n            const chip = this._tiledMapData.getFromChipPosition(paint.x, paint.y);\n            if ((chip === null || chip === void 0 ? void 0 : chip.arrangementName) === 'AutoTileArrangement') {\n                autoTilePaints.push(paint);\n            }\n            else {\n                otherPaints.push(paint);\n            }\n        });\n        return [...this.autoTileEraser.apply(autoTilePaints), ...this.defaultEraser.apply(otherPaints)];\n    }\n}\n\n\n/***/ }),\n/* 12 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_76972__) => {\n\n\"use strict\";\n__nested_webpack_require_76972__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_76972__.d(__webpack_exports__, {\n/* harmony export */   \"EraseArrangementDescription\": () => (/* binding */ EraseArrangementDescription),\n/* harmony export */   \"EraseArrangement\": () => (/* binding */ EraseArrangement)\n/* harmony export */ });\nconst EraseArrangementDescription = {\n    name: 'EraseArrangement',\n    create: () => new EraseArrangement()\n};\nclass EraseArrangement {\n    apply(paints) {\n        return paints.map(paint => ({ ...paint, item: null }));\n    }\n}\n\n\n/***/ }),\n/* 13 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_77639__) => {\n\n\"use strict\";\n__nested_webpack_require_77639__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_77639__.d(__webpack_exports__, {\n/* harmony export */   \"AutoTileEraseArrangementDescription\": () => (/* binding */ AutoTileEraseArrangementDescription),\n/* harmony export */   \"AutoTileEraseArrangement\": () => (/* binding */ AutoTileEraseArrangement)\n/* harmony export */ });\n/* harmony import */ var _AutoTileArrangement__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_77639__(10);\n/* harmony import */ var _piyoppi_pico2map_tiled__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_77639__(4);\n/* harmony import */ var _piyoppi_pico2map_tiled__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__nested_webpack_require_77639__.n(_piyoppi_pico2map_tiled__WEBPACK_IMPORTED_MODULE_1__);\n\n\nconst AutoTileEraseArrangementDescription = {\n    name: 'AutoTileEraseArrangement',\n    create: () => new AutoTileEraseArrangement()\n};\nclass AutoTileEraseArrangement {\n    constructor() {\n        this._autoTileArrangement = new _AutoTileArrangement__WEBPACK_IMPORTED_MODULE_0__.AutoTileArrangement();\n        this._tiledMapData = null;\n        this._autoTiles = null;\n    }\n    setTiledMapData(tiledMapData) {\n        this._tiledMapData = tiledMapData;\n    }\n    setAutoTiles(autoTiles) {\n        this._autoTiles = autoTiles;\n    }\n    apply(paints) {\n        if (paints.length === 0)\n            return [];\n        return this.erase(paints);\n    }\n    erase(paints) {\n        if (!this._tiledMapData)\n            throw new Error('MapData is not set.');\n        if (!this._autoTiles)\n            throw new Error('AutoTiles is not set');\n        const resultPaints = [];\n        const paintX1 = paints.reduce((acc, val) => Math.min(acc, val.x), this._tiledMapData.width);\n        const paintY1 = paints.reduce((acc, val) => Math.min(acc, val.y), this._tiledMapData.height);\n        const paintX2 = paints.reduce((acc, val) => Math.max(acc, val.x), 0);\n        const paintY2 = paints.reduce((acc, val) => Math.max(acc, val.y), 0);\n        const x1 = Math.max(paintX1 - 1, 0);\n        const y1 = Math.max(paintY1 - 1, 0);\n        const x2 = Math.min(paintX2 + 1, this._tiledMapData.width);\n        const y2 = Math.min(paintY2 + 1, this._tiledMapData.height);\n        const bufferWidth = x2 - x1 + 1;\n        const bufferHeight = y2 - y1 + 1;\n        const tiledBuffer = new _piyoppi_pico2map_tiled__WEBPACK_IMPORTED_MODULE_1__.TiledMapData(bufferWidth + 2, bufferHeight + 2);\n        const bufferOffsetX = x1 - 1;\n        const bufferOffsetY = y1 - 1;\n        tiledBuffer.transferFromTiledMapData(this._tiledMapData, bufferOffsetX, bufferOffsetY, tiledBuffer.width, tiledBuffer.height, 0, 0);\n        paints.forEach(paint => {\n            var _a;\n            const paintPositionAtBuffer = { x: paint.x - bufferOffsetX, y: paint.y - bufferOffsetY };\n            tiledBuffer.put(null, paintPositionAtBuffer.x, paintPositionAtBuffer.y);\n            resultPaints.push({ x: paint.x, y: paint.y, item: null });\n            this._autoTileArrangement.setTiledMapData(tiledBuffer);\n            for (let y = paintPositionAtBuffer.y - 1; y <= paintPositionAtBuffer.y + 1; y++) {\n                for (let x = paintPositionAtBuffer.x - 1; x <= paintPositionAtBuffer.x + 1; x++) {\n                    if (x === paintPositionAtBuffer.x && y === paintPositionAtBuffer.y)\n                        continue;\n                    const item = tiledBuffer.getFromChipPosition(x, y);\n                    if (item && (0,_piyoppi_pico2map_tiled__WEBPACK_IMPORTED_MODULE_1__.isAutoTileMapChip)(item)) {\n                        const autoTile = (_a = this._autoTiles) === null || _a === void 0 ? void 0 : _a.fromId(item.autoTileId);\n                        if (!autoTile)\n                            continue;\n                        this._autoTileArrangement.setAutoTile(autoTile);\n                        const appliedPaints = this._autoTileArrangement.apply([{ x, y }]);\n                        if (appliedPaints.length === 0)\n                            continue;\n                        resultPaints.push({ x: appliedPaints[0].x + bufferOffsetX, y: appliedPaints[0].y + bufferOffsetY, item: appliedPaints[0].item });\n                    }\n                }\n            }\n        });\n        return resultPaints;\n    }\n}\n\n\n/***/ }),\n/* 14 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_81991__) => {\n\n\"use strict\";\n__nested_webpack_require_81991__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_81991__.d(__webpack_exports__, {\n/* harmony export */   \"isMapChipFragmentRequired\": () => (/* binding */ isMapChipFragmentRequired),\n/* harmony export */   \"isTiledMapDataRequired\": () => (/* binding */ isTiledMapDataRequired),\n/* harmony export */   \"isAutoTileRequired\": () => (/* binding */ isAutoTileRequired),\n/* harmony export */   \"isAutoTilesRequired\": () => (/* binding */ isAutoTilesRequired),\n/* harmony export */   \"isColiderTypesRequired\": () => (/* binding */ isColiderTypesRequired)\n/* harmony export */ });\nfunction isMapChipFragmentRequired(obj) {\n    return typeof obj.setMapChips === 'function';\n}\nfunction isTiledMapDataRequired(obj) {\n    return typeof obj.setTiledMapData === 'function';\n}\nfunction isAutoTileRequired(obj) {\n    return typeof obj.setAutoTile === 'function';\n}\nfunction isAutoTilesRequired(obj) {\n    return typeof obj.setAutoTiles === 'function';\n}\nfunction isColiderTypesRequired(obj) {\n    return typeof obj.setColiderTypes === 'function';\n}\n\n\n/***/ }),\n/* 15 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_83168__) => {\n\n\"use strict\";\n__nested_webpack_require_83168__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_83168__.d(__webpack_exports__, {\n/* harmony export */   \"MapChipPicker\": () => (/* binding */ MapChipPicker)\n/* harmony export */ });\nclass MapChipPicker {\n    constructor(_tiledMap) {\n        this._tiledMap = _tiledMap;\n    }\n    pick(x, y, layerIndex) {\n        if (layerIndex !== undefined) {\n            return this._tiledMap.datas[layerIndex].getFromChipPosition(x, y);\n        }\n        return this._tiledMap.datas.reduce((acc, data) => {\n            const chip = data.getFromChipPosition(x, y);\n            if (chip)\n                return chip;\n            return acc;\n        }, null);\n    }\n}\n\n\n/***/ }),\n/* 16 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_83964__) => {\n\n\"use strict\";\n__nested_webpack_require_83964__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_83964__.d(__webpack_exports__, {\n/* harmony export */   \"convertFromCursorPositionToChipPosition\": () => (/* binding */ convertFromCursorPositionToChipPosition)\n/* harmony export */ });\nfunction convertFromCursorPositionToChipPosition(x, y, chipWidth, chipHeight, chipCountX, chipCountY) {\n    return {\n        x: Math.max(0, Math.min(Math.floor(x / chipWidth), chipCountX - 1)),\n        y: Math.max(0, Math.min(Math.floor(y / chipHeight), chipCountY - 1))\n    };\n}\n\n\n/***/ }),\n/* 17 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_84623__) => {\n\n\"use strict\";\n__nested_webpack_require_84623__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_84623__.d(__webpack_exports__, {\n/* harmony export */   \"Project\": () => (/* binding */ Project),\n/* harmony export */   \"Projects\": () => (/* binding */ Projects)\n/* harmony export */ });\n/* harmony import */ var _CallbackCallers__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_84623__(18);\n/* harmony import */ var _Injector__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_84623__(20);\n\n\nclass Project {\n    constructor(_tiledMap, _projectId) {\n        this._tiledMap = _tiledMap;\n        this._projectId = _projectId;\n        this._callbacks = new _CallbackCallers__WEBPACK_IMPORTED_MODULE_0__.CallbackCallers();\n        const injector = new _Injector__WEBPACK_IMPORTED_MODULE_1__.Injector();\n        injector.inject(_tiledMap, _tiledMap.addLayer, () => this._beforeAddLayerHandler(), null);\n        injector.inject(_tiledMap, _tiledMap.resize, null, () => this._afterResizedMapHandler());\n        injector.inject(_tiledMap.autoTiles, _tiledMap.autoTiles.push, null, () => this._afterAddAutoTileHandler());\n        injector.inject(_tiledMap.autoTiles, _tiledMap.autoTiles.remove, null, () => this._afterRemoveAutoTileHandler());\n        injector.inject(_tiledMap.mapChipsCollection, _tiledMap.mapChipsCollection.replace, null, () => this._afterReplacedMapChipImageHandler());\n    }\n    get projectId() {\n        return this._projectId;\n    }\n    get tiledMap() {\n        return this._tiledMap;\n    }\n    requestRenderAll() {\n        this._callbacks.call('renderAll');\n    }\n    setCallback(key, callback) {\n        return this._callbacks.add(key, callback);\n    }\n    removeCallback(key, callbackItem) {\n        this._callbacks.remove(key, callbackItem);\n    }\n    _beforeAddLayerHandler() {\n        this._callbacks.call('beforeAddLayer');\n    }\n    _afterAddAutoTileHandler() {\n        this._callbacks.call('afterAddAutoTile');\n    }\n    _afterRemoveAutoTileHandler() {\n        this._callbacks.call('afterRemoveAutoTile');\n    }\n    _afterReplacedMapChipImageHandler() {\n        this._callbacks.call('afterReplacedMapChipImage');\n    }\n    _afterResizedMapHandler() {\n        this._callbacks.call('afterResizedMap');\n    }\n}\nclass Projects {\n    static setProjectAddCallbackFunction(fn) {\n        this._projectAddCallbackFunctions.push(fn);\n    }\n    static get items() {\n        return Projects._items;\n    }\n    static add(tiledMap, projectId = -1) {\n        const id = projectId > 0 ? projectId : Projects.createId();\n        const project = new Project(tiledMap, id);\n        Projects._items.push(project);\n        this._projectAddCallbackFunctions.forEach(fn => fn());\n        return project;\n    }\n    static clear() {\n        this._items.length = 0;\n    }\n    static fromProjectId(projectId) {\n        return this._items.find(item => item.projectId === projectId) || null;\n    }\n    static createId() {\n        return ++Projects._idCounter;\n    }\n}\nProjects._idCounter = 0;\nProjects._items = [];\nProjects._projectAddCallbackFunctions = [];\n\n\n/***/ }),\n/* 18 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_87757__) => {\n\n\"use strict\";\n__nested_webpack_require_87757__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_87757__.d(__webpack_exports__, {\n/* harmony export */   \"CallbackCallers\": () => (/* binding */ CallbackCallers)\n/* harmony export */ });\n/* harmony import */ var _CallbackCaller__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_87757__(19);\n\nclass CallbackCallers {\n    constructor() {\n        this._callers = new Map();\n    }\n    has(key, callbackItem) {\n        var _a;\n        return !!((_a = this._callers.get(key)) === null || _a === void 0 ? void 0 : _a.has(callbackItem));\n    }\n    add(key, callback) {\n        let caller = this._callers.get(key);\n        if (!caller) {\n            caller = new _CallbackCaller__WEBPACK_IMPORTED_MODULE_0__.CallbackCaller();\n            this._callers.set(key, caller);\n        }\n        return caller.add(callback);\n    }\n    call(key) {\n        var _a;\n        (_a = this._callers.get(key)) === null || _a === void 0 ? void 0 : _a.call();\n    }\n    remove(key, callbackItem) {\n        var _a;\n        (_a = this._callers.get(key)) === null || _a === void 0 ? void 0 : _a.remove(callbackItem);\n    }\n}\n\n\n/***/ }),\n/* 19 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_88988__) => {\n\n\"use strict\";\n__nested_webpack_require_88988__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_88988__.d(__webpack_exports__, {\n/* harmony export */   \"CallbackCaller\": () => (/* binding */ CallbackCaller)\n/* harmony export */ });\n/* harmony import */ var _CallbackItem__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_88988__(2);\n\nclass CallbackCaller {\n    constructor() {\n        this._items = [];\n        this._maxId = 1;\n    }\n    has(callbackItem) {\n        return !!this._items.find(item => item === callbackItem);\n    }\n    add(proc) {\n        const callbackItem = new _CallbackItem__WEBPACK_IMPORTED_MODULE_0__.CallbackItem(proc, this._maxId++);\n        this._items.push(callbackItem);\n        return callbackItem;\n    }\n    call() {\n        this._items.forEach(item => item.call());\n    }\n    remove(removedCallbackItem) {\n        const index = this._items.findIndex(item => item === removedCallbackItem);\n        if (index < 0)\n            throw Error('CallbackCaller is not found');\n        this._items.splice(index, 1);\n    }\n}\n\n\n/***/ }),\n/* 20 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_90121__) => {\n\n\"use strict\";\n__nested_webpack_require_90121__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_90121__.d(__webpack_exports__, {\n/* harmony export */   \"Injector\": () => (/* binding */ Injector)\n/* harmony export */ });\nclass Injector {\n    inject(calledObject, method, before, after) {\n        const original = calledObject[method.name];\n        calledObject[method.name] = (...args) => {\n            if (before)\n                before();\n            const result = original.apply(calledObject, args);\n            if (after)\n                after();\n            return result;\n        };\n    }\n}\n\n\n/***/ }),\n/* 21 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_90815__) => {\n\n\"use strict\";\n__nested_webpack_require_90815__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_90815__.d(__webpack_exports__, {\n/* harmony export */   \"ColiderCanvas\": () => (/* binding */ ColiderCanvas)\n/* harmony export */ });\n/* harmony import */ var _ColiderRenderer__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_90815__(22);\n/* harmony import */ var _Brushes_Pen__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_90815__(5);\n/* harmony import */ var _Brushes_Brushes__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_90815__(6);\n/* harmony import */ var _Brushes_Arrangements_Arrangement__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_90815__(14);\n/* harmony import */ var _Brushes_Arrangements_ColiderArrangement__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_90815__(23);\n\n\n\n\n\nclass ColiderCanvas {\n    constructor() {\n        this._coliderCtx = null;\n        this._secondaryCanvasCtx = null;\n        this._secondaryCanvas = null;\n        this._project = null;\n        this._coliderRenderer = null;\n        this._arrangement = new _Brushes_Arrangements_ColiderArrangement__WEBPACK_IMPORTED_MODULE_4__.ColiderArrangement();\n        this._isMouseDown = false;\n        this._lastMapChipPosition = { x: -1, y: -1 };\n        this._selectedColiderType = 0;\n        this._selectedSubColiderType = 0;\n        this._renderAllCallbackItem = null;\n        this._brush = new _Brushes_Pen__WEBPACK_IMPORTED_MODULE_1__.Pen();\n        this._setupBrush();\n    }\n    get selectedColiderType() {\n        return this._selectedColiderType;\n    }\n    get selectedSubColiderType() {\n        return this._selectedSubColiderType;\n    }\n    get project() {\n        if (!this._project)\n            throw new Error('The project is not set');\n        return this._project;\n    }\n    get hasProject() {\n        return !!this._project;\n    }\n    get coliderCtx() {\n        if (!this._coliderCtx)\n            throw new Error('A canvas is not set');\n        return this._coliderCtx;\n    }\n    get secondaryCanvasCtx() {\n        if (!this._secondaryCanvasCtx)\n            throw new Error('A canvas is not set');\n        return this._secondaryCanvasCtx;\n    }\n    get coliderRenderer() {\n        if (!this._coliderRenderer)\n            throw new Error('The project is not set');\n        return this._coliderRenderer;\n    }\n    get secondaryCanvas() {\n        if (!this._secondaryCanvas)\n            throw new Error('A canvas is not set');\n        return this._secondaryCanvas;\n    }\n    get isMouseDown() {\n        return this._isMouseDown;\n    }\n    get renderable() {\n        return !!this._coliderCtx && !!this._coliderRenderer;\n    }\n    get isSubscribedProjectEvent() {\n        return !!this._renderAllCallbackItem;\n    }\n    setProject(project) {\n        this._project = project;\n        this._coliderRenderer = new _ColiderRenderer__WEBPACK_IMPORTED_MODULE_0__.ColiderRenderer(this._project.tiledMap);\n        if (this.renderable && this._coliderCtx) {\n            this.coliderRenderer.renderAll(this._coliderCtx);\n        }\n    }\n    subscribeProjectEvent() {\n        if (this._renderAllCallbackItem)\n            throw new Error('Project Event is already subscribed');\n        if (!this._project)\n            throw new Error('Project is not set');\n        this._renderAllCallbackItem = this._project.setCallback('renderAll', () => {\n            if (!this.renderable || !this._coliderCtx)\n                return;\n            this.coliderRenderer.renderAll(this._coliderCtx);\n        });\n    }\n    unsubscribeProjectEvent() {\n        if (this._project && this._renderAllCallbackItem)\n            this._project.removeCallback('renderAll', this._renderAllCallbackItem);\n        this._renderAllCallbackItem = null;\n    }\n    setCanvas(canvas, secondaryCanvas) {\n        this._coliderCtx = canvas.getContext('2d');\n        this._secondaryCanvasCtx = secondaryCanvas.getContext('2d');\n        this._secondaryCanvas = secondaryCanvas;\n        if (this.renderable) {\n            this.coliderRenderer.renderAll(this._coliderCtx);\n        }\n    }\n    setBrush(brush) {\n        this._brush = brush;\n        this._setupBrush();\n    }\n    setArrangement(value) {\n        this._arrangement = value;\n    }\n    setBrushFromName(brushName) {\n        const registeredBrush = _Brushes_Brushes__WEBPACK_IMPORTED_MODULE_2__.Brushes.find(registeredBrush => registeredBrush.name === brushName);\n        if (!registeredBrush) {\n            this.setBrush(new _Brushes_Pen__WEBPACK_IMPORTED_MODULE_1__.Pen());\n        }\n        else {\n            this.setBrush(registeredBrush.create());\n        }\n    }\n    setColiderType(value) {\n        this._selectedColiderType = value;\n    }\n    setSubColiderType(value) {\n        this._selectedSubColiderType = value;\n    }\n    _setupBrush(isSubButton = false) {\n        this._brush.setArrangement(this._arrangement);\n        if ((0,_Brushes_Arrangements_Arrangement__WEBPACK_IMPORTED_MODULE_3__.isColiderTypesRequired)(this._arrangement)) {\n            this._arrangement.setColiderTypes(isSubButton ? this._selectedSubColiderType : this._selectedColiderType);\n        }\n    }\n    mouseDown(x, y, isSubButton = false) {\n        this._isMouseDown = true;\n        this._setupBrush(isSubButton);\n        const chipPosition = this.convertFromCursorPositionToChipPosition(x, y);\n        this._brush.mouseDown(chipPosition.x, chipPosition.y);\n        this._paint(chipPosition);\n        this._lastMapChipPosition = chipPosition;\n    }\n    mouseMove(x, y) {\n        const chipPosition = this.convertFromCursorPositionToChipPosition(x, y);\n        if (!this._isMouseDown)\n            return chipPosition;\n        if (chipPosition.x === this._lastMapChipPosition.x && chipPosition.y === this._lastMapChipPosition.y)\n            return chipPosition;\n        this._paint(chipPosition);\n        this._lastMapChipPosition = chipPosition;\n        return chipPosition;\n    }\n    mouseUp(x, y) {\n        this._isMouseDown = false;\n        const chipPosition = this.convertFromCursorPositionToChipPosition(x, y);\n        this._brush.mouseUp(chipPosition.x, chipPosition.y).forEach(paint => {\n            const chip = paint.item;\n            this.putChip(chip, paint.x, paint.y);\n        });\n        this.clearSecondaryCanvas();\n        this._brush.cleanUp();\n        this._lastMapChipPosition = { x: -1, y: -1 };\n    }\n    _paint(chipPosition) {\n        this.clearSecondaryCanvas();\n        this._brush.mouseMove(chipPosition.x, chipPosition.y).forEach(paint => {\n            const chip = paint.item;\n            this.coliderRenderer.putOrClearChipToCanvas(this.secondaryCanvasCtx, chip, paint.x, paint.y, true);\n        });\n    }\n    putChip(coliderType, chipX, chipY) {\n        this.project.tiledMap.coliders.put(coliderType, chipX, chipY);\n        this.coliderRenderer.putOrClearChipToCanvas(this.coliderCtx, coliderType, chipX, chipY);\n    }\n    clearSecondaryCanvas() {\n        this.secondaryCanvasCtx.clearRect(0, 0, this.secondaryCanvas.width, this.secondaryCanvas.height);\n    }\n    convertFromCursorPositionToChipPosition(x, y) {\n        return {\n            x: Math.max(0, Math.min(Math.floor(x / this.project.tiledMap.chipWidth), this.project.tiledMap.chipCountX - 1)),\n            y: Math.max(0, Math.min(Math.floor(y / this.project.tiledMap.chipHeight), this.project.tiledMap.chipCountY - 1))\n        };\n    }\n}\n\n\n/***/ }),\n/* 22 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_98189__) => {\n\n\"use strict\";\n__nested_webpack_require_98189__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_98189__.d(__webpack_exports__, {\n/* harmony export */   \"ColiderRenderer\": () => (/* binding */ ColiderRenderer)\n/* harmony export */ });\nclass ColiderRenderer {\n    constructor(_tiledMap) {\n        this._tiledMap = _tiledMap;\n        this._backgroundRgba = { r: 255, g: 255, b: 255, a: 1.0 };\n    }\n    renderAll(ctx) {\n        this._tiledMap.coliders.items.forEach((value, index) => {\n            const position = this._tiledMap.convertMapNumberToPosition(index);\n            this.putOrClearChipToCanvas(ctx, value, position.x, position.y);\n        });\n    }\n    putOrClearChipToCanvas(ctx, coliderType, chipX, chipY, isTemporaryRendering = false) {\n        if (coliderType === 1) {\n            this._putToCanvas(ctx, chipX, chipY);\n        }\n        else {\n            this._clearChipToCanvas(ctx, chipX, chipY, isTemporaryRendering);\n        }\n    }\n    _clearChipToCanvas(ctx, chipX, chipY, isTemporaryRendering) {\n        const position = this._tiledMap.convertChipPositionToPixel(chipX, chipY);\n        ctx.clearRect(position.x, position.y, this._tiledMap.chipWidth, this._tiledMap.chipHeight);\n        if (isTemporaryRendering) {\n            ctx.fillStyle = `rgba(${this._backgroundRgba.r},${this._backgroundRgba.g},${this._backgroundRgba.b},${this._backgroundRgba.a})`;\n            ctx.fillRect(position.x, position.y, this._tiledMap.chipWidth, this._tiledMap.chipHeight);\n        }\n    }\n    _putToCanvas(ctx, chipX, chipY) {\n        const position = this._tiledMap.convertChipPositionToPixel(chipX, chipY);\n        ctx.clearRect(position.x, position.y, this._tiledMap.chipWidth, this._tiledMap.chipHeight);\n        ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';\n        ctx.fillRect(position.x, position.y, this._tiledMap.chipWidth, this._tiledMap.chipHeight);\n    }\n}\n\n\n/***/ }),\n/* 23 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_100155__) => {\n\n\"use strict\";\n__nested_webpack_require_100155__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_100155__.d(__webpack_exports__, {\n/* harmony export */   \"ColiderArrangementDescription\": () => (/* binding */ ColiderArrangementDescription),\n/* harmony export */   \"ColiderArrangement\": () => (/* binding */ ColiderArrangement)\n/* harmony export */ });\nconst ColiderArrangementDescription = {\n    name: 'ColiderArrangement',\n    create: () => new ColiderArrangement()\n};\nclass ColiderArrangement {\n    constructor() {\n        this._coliderType = 0;\n    }\n    setColiderTypes(coliderType) {\n        this._coliderType = coliderType;\n    }\n    apply(paints) {\n        return paints.map(paint => ({ ...paint, item: this._coliderType }));\n    }\n}\n\n\n/***/ }),\n/* 24 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_100990__) => {\n\n\"use strict\";\n__nested_webpack_require_100990__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_100990__.d(__webpack_exports__, {\n/* harmony export */   \"AutoTileSelector\": () => (/* binding */ AutoTileSelector)\n/* harmony export */ });\nclass AutoTileSelector {\n    constructor(_canvasWidth, _chipWidth, _chipHeight, _autoTiles, _mapChipsCollection) {\n        this._canvasWidth = _canvasWidth;\n        this._chipWidth = _chipWidth;\n        this._chipHeight = _chipHeight;\n        this._autoTiles = _autoTiles;\n        this._mapChipsCollection = _mapChipsCollection;\n        this._indexImageWidth = 0;\n        this._indexImageHeight = 0;\n        this._autoTilesMap = new Map();\n    }\n    get canvasWidth() {\n        return this._canvasWidth;\n    }\n    set canvasWidth(value) {\n        this._canvasWidth = value;\n    }\n    getAutoTileFragmentFromIndexImagePosition(cursorX, cursorY) {\n        const x = Math.floor(cursorX / this._chipWidth);\n        const y = Math.floor(cursorY / this._chipHeight);\n        return this._autoTilesMap.get(`${x},${y}`) || null;\n    }\n    convertFromIndexImageToChipPosition(cursorX, cursorY) {\n        const chipCount = {\n            width: this._indexImageWidth / this._chipWidth,\n            height: this._indexImageHeight / this._chipHeight\n        };\n        return {\n            x: Math.max(0, Math.min(Math.floor(cursorX / this._chipWidth), chipCount.width - 1)),\n            y: Math.max(0, Math.min(Math.floor(cursorY / this._chipHeight), chipCount.height - 1))\n        };\n    }\n    getSizeOfIndexImage() {\n        return {\n            width: this._canvasWidth,\n            height: Math.ceil(this._autoTiles.length / Math.floor(this._canvasWidth / this._chipWidth)) * this._chipHeight\n        };\n    }\n    generateIndexImage(canvas) {\n        const indexImageContext = canvas.getContext('2d');\n        if (!indexImageContext)\n            return;\n        indexImageContext.clearRect(0, 0, canvas.width, canvas.height);\n        this._autoTilesMap.clear();\n        const xCount = Math.floor(this._canvasWidth / this._chipWidth);\n        const values = this._autoTiles.values();\n        let currentAutoTile = undefined;\n        let x = 0, y = 0;\n        while (currentAutoTile = values.next().value) {\n            const fragment = currentAutoTile.mapChipFragments[0];\n            const chipImage = this._mapChipsCollection.findById(fragment.chipId);\n            if (!chipImage)\n                continue;\n            indexImageContext.drawImage(chipImage.image, fragment.x * this._chipWidth, fragment.y * this._chipHeight, this._chipWidth, this._chipHeight, x * this._chipWidth, y * this._chipHeight, this._chipWidth, this._chipHeight);\n            this._autoTilesMap.set(`${x},${y}`, currentAutoTile);\n            x++;\n            if (x >= xCount) {\n                x = 0;\n                y++;\n            }\n        }\n        this._indexImageWidth = xCount * this._chipWidth;\n        this._indexImageHeight = (y + 1) * this._chipHeight;\n    }\n}\n\n\n/***/ }),\n/* 25 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_104064__) => {\n\n\"use strict\";\n__nested_webpack_require_104064__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_104064__.d(__webpack_exports__, {\n/* harmony export */   \"MapChipSelector\": () => (/* binding */ MapChipSelector)\n/* harmony export */ });\n/* harmony import */ var _piyoppi_pico2map_tiled__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_104064__(4);\n/* harmony import */ var _piyoppi_pico2map_tiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_104064__.n(_piyoppi_pico2map_tiled__WEBPACK_IMPORTED_MODULE_0__);\n\nclass MapChipSelector {\n    constructor(_tiledMap, _chipImage) {\n        this._tiledMap = _tiledMap;\n        this._chipImage = _chipImage;\n        this._selectedChips = [];\n        this._selecting = false;\n        this._startChipPosition = { x: -1, y: -1 };\n        this._endChipPosition = { x: -1, y: -1 };\n    }\n    get chipImage() {\n        return this._chipImage;\n    }\n    get selectedChips() {\n        return this._selectedChips;\n    }\n    get selecting() {\n        return this._selecting;\n    }\n    get startChipPosition() {\n        return {\n            x: Math.min(this._startChipPosition.x, this._endChipPosition.x),\n            y: Math.min(this._startChipPosition.y, this._endChipPosition.y)\n        };\n    }\n    get startPosition() {\n        const startChipPosition = this.startChipPosition;\n        return {\n            x: startChipPosition.x * this._tiledMap.chipWidth,\n            y: startChipPosition.y * this._tiledMap.chipHeight\n        };\n    }\n    get selectedChipSize() {\n        return {\n            width: (Math.abs(this._endChipPosition.x - this._startChipPosition.x) + 1),\n            height: (Math.abs(this._endChipPosition.y - this._startChipPosition.y) + 1)\n        };\n    }\n    get selectedSize() {\n        const selectedChipSize = this.selectedChipSize;\n        return {\n            width: selectedChipSize.width * this._tiledMap.chipWidth,\n            height: selectedChipSize.height * this._tiledMap.chipHeight\n        };\n    }\n    clear() {\n        this._selectedChips.length = 0;\n    }\n    _selectAtMouseCursor() {\n        this.clear();\n        const chipPosition = {\n            x: Math.min(this._startChipPosition.x, this._endChipPosition.x),\n            y: Math.min(this._startChipPosition.y, this._endChipPosition.y)\n        };\n        const maximumChipCount = this._chipImage.getChipCount(this._tiledMap.chipWidth, this._tiledMap.chipHeight);\n        const { width, height } = this.selectedChipSize;\n        if (chipPosition.x + width > maximumChipCount.width) {\n            chipPosition.x = maximumChipCount.width - width;\n        }\n        if (chipPosition.y + height > maximumChipCount.height) {\n            chipPosition.y = maximumChipCount.height - height;\n        }\n        if (chipPosition.x < 0 || chipPosition.y < 0) {\n            throw new Error('MapChipImage is not enough size.');\n        }\n        for (let x = 0; x < width; x++) {\n            for (let y = 0; y < height; y++) {\n                this._selectedChips.push(new _piyoppi_pico2map_tiled__WEBPACK_IMPORTED_MODULE_0__.MapChipFragment(chipPosition.x + x, chipPosition.y + y, this._chipImage.id));\n            }\n        }\n    }\n    mouseDown(x, y) {\n        const chipPosition = this.convertFromImagePositionToChipPosition(x, y);\n        this._startChipPosition = { ...chipPosition };\n        this._endChipPosition = { ...chipPosition };\n        this._selecting = true;\n    }\n    mouseMove(x, y) {\n        if (!this._selecting)\n            return;\n        const chipPosition = this.convertFromImagePositionToChipPosition(x, y);\n        this._endChipPosition = { ...chipPosition };\n    }\n    mouseUp(x, y) {\n        if (!this._selecting)\n            return;\n        const chipPosition = this.convertFromImagePositionToChipPosition(x, y);\n        this._endChipPosition = { ...chipPosition };\n        this._selectAtMouseCursor();\n        this._selecting = false;\n    }\n    convertFromImagePositionToChipPosition(x, y) {\n        const chipCount = this._chipImage.getChipCount(this._tiledMap.chipWidth, this._tiledMap.chipHeight);\n        return {\n            x: Math.max(0, Math.min(Math.floor(x / this._tiledMap.chipWidth), chipCount.width - 1)),\n            y: Math.max(0, Math.min(Math.floor(y / this._tiledMap.chipHeight), chipCount.height - 1))\n        };\n    }\n}\n\n\n/***/ })\n/******/ \t]);\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_108606__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_108606__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/compat get default export */\n/******/ \t(() => {\n/******/ \t\t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t\t__nested_webpack_require_108606__.n = (module) => {\n/******/ \t\t\tvar getter = module && module.__esModule ?\n/******/ \t\t\t\t() => (module['default']) :\n/******/ \t\t\t\t() => (module);\n/******/ \t\t\t__nested_webpack_require_108606__.d(getter, { a: getter });\n/******/ \t\t\treturn getter;\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/define property getters */\n/******/ \t(() => {\n/******/ \t\t// define getter functions for harmony exports\n/******/ \t\t__nested_webpack_require_108606__.d = (exports, definition) => {\n/******/ \t\t\tfor(var key in definition) {\n/******/ \t\t\t\tif(__nested_webpack_require_108606__.o(definition, key) && !__nested_webpack_require_108606__.o(exports, key)) {\n/******/ \t\t\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n/******/ \t\t\t\t}\n/******/ \t\t\t}\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/hasOwnProperty shorthand */\n/******/ \t(() => {\n/******/ \t\t__nested_webpack_require_108606__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/make namespace object */\n/******/ \t(() => {\n/******/ \t\t// define __esModule on exports\n/******/ \t\t__nested_webpack_require_108606__.r = (exports) => {\n/******/ \t\t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t\t}\n/******/ \t\t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/************************************************************************/\nvar __webpack_exports__ = {};\n// This entry need to be wrapped in an IIFE because it need to be in strict mode.\n(() => {\n\"use strict\";\n__nested_webpack_require_108606__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_108606__.d(__webpack_exports__, {\n/* harmony export */   \"GridImageGenerator\": () => (/* reexport safe */ _GridImageGenerator__WEBPACK_IMPORTED_MODULE_0__.GridImageGenerator),\n/* harmony export */   \"CallbackItem\": () => (/* reexport safe */ _CallbackItem__WEBPACK_IMPORTED_MODULE_1__.CallbackItem),\n/* harmony export */   \"MapCanvas\": () => (/* reexport safe */ _MapCanvas__WEBPACK_IMPORTED_MODULE_2__.MapCanvas),\n/* harmony export */   \"Projects\": () => (/* reexport safe */ _Projects__WEBPACK_IMPORTED_MODULE_3__.Projects),\n/* harmony export */   \"Project\": () => (/* reexport safe */ _Projects__WEBPACK_IMPORTED_MODULE_3__.Project),\n/* harmony export */   \"ColiderCanvas\": () => (/* reexport safe */ _ColiderCanvas__WEBPACK_IMPORTED_MODULE_4__.ColiderCanvas),\n/* harmony export */   \"AutoTileSelector\": () => (/* reexport safe */ _AutoTileSelector__WEBPACK_IMPORTED_MODULE_5__.AutoTileSelector),\n/* harmony export */   \"MapChipSelector\": () => (/* reexport safe */ _MapChipSelector__WEBPACK_IMPORTED_MODULE_6__.MapChipSelector),\n/* harmony export */   \"convertFromCursorPositionToChipPosition\": () => (/* reexport safe */ _CursorPositionConverter__WEBPACK_IMPORTED_MODULE_7__.convertFromCursorPositionToChipPosition)\n/* harmony export */ });\n/* harmony import */ var _GridImageGenerator__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_108606__(1);\n/* harmony import */ var _CallbackItem__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_108606__(2);\n/* harmony import */ var _MapCanvas__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_108606__(3);\n/* harmony import */ var _Projects__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_108606__(17);\n/* harmony import */ var _ColiderCanvas__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_108606__(21);\n/* harmony import */ var _AutoTileSelector__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_108606__(24);\n/* harmony import */ var _MapChipSelector__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_108606__(25);\n/* harmony import */ var _CursorPositionConverter__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_108606__(16);\n\n\n\n\n\n\n\n\n\n})();\n\n/******/ \treturn __webpack_exports__;\n/******/ })()\n;\n});\n\n/***/ }),\n/* 18 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_160523__) => {\n\n\"use strict\";\n__nested_webpack_require_160523__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_160523__.d(__webpack_exports__, {\n/* harmony export */   \"CursorPositionCalculator\": () => (/* binding */ CursorPositionCalculator)\n/* harmony export */ });\nclass CursorPositionCalculator {\n    constructor() {\n        this._element = null;\n    }\n    setElement(element) {\n        this._element = element;\n    }\n    getMouseCursorPosition(pageX, pageY) {\n        if (!this._element)\n            return { x: 0, y: 0 };\n        const rect = this._element.getBoundingClientRect();\n        return {\n            x: (pageX - window.scrollX - rect.x),\n            y: (pageY - window.scrollY - rect.y)\n        };\n    }\n}\n\n\n/***/ }),\n/* 19 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_161327__) => {\n\n\"use strict\";\n__nested_webpack_require_161327__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_161327__.d(__webpack_exports__, {\n/* harmony export */   \"MapCanvasComponent\": () => (/* binding */ MapCanvasComponent)\n/* harmony export */ });\n/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_161327__(2);\n/* harmony import */ var lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_161327__(7);\n/* harmony import */ var _Helpers_CursorPositionCalculator__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_161327__(18);\n/* harmony import */ var _piyoppi_pico2map_editor__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_161327__(17);\n/* harmony import */ var _piyoppi_pico2map_editor__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__nested_webpack_require_161327__.n(_piyoppi_pico2map_editor__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _piyoppi_pico2map_tiled__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_161327__(20);\n/* harmony import */ var _piyoppi_pico2map_tiled__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__nested_webpack_require_161327__.n(_piyoppi_pico2map_tiled__WEBPACK_IMPORTED_MODULE_4__);\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\n\nclass MapCanvasComponent extends lit__WEBPACK_IMPORTED_MODULE_0__.LitElement {\n    constructor() {\n        super();\n        this.cursorPositionCalculator = new _Helpers_CursorPositionCalculator__WEBPACK_IMPORTED_MODULE_2__.CursorPositionCalculator();\n        this._mapCanvas = new _piyoppi_pico2map_editor__WEBPACK_IMPORTED_MODULE_3__.MapCanvas();\n        this._project = null;\n        this._secondaryCanvasElement = null;\n        this._canvasesOuterElement = null;\n        this._autoTileIdAttributeValue = -1;\n        this._inactiveLayerOpacity = 1.0;\n        this._appendedLayerCanvases = [];\n        this._canvasMaxIds = 1;\n        this._documentMouseMoveEventCallee = null;\n        this._documentMouseUpEventCallee = null;\n        this.gridCursorHidden = false;\n        this.preventDefaultContextMenu = true;\n        this.gridColor = '#000';\n        this._projectId = -1;\n        this._brushName = '';\n        this._arrangementName = '';\n        _piyoppi_pico2map_editor__WEBPACK_IMPORTED_MODULE_3__.Projects.setProjectAddCallbackFunction(() => this.setupProject());\n        this._mapCanvas.setPickedCallback((picked => {\n            this.dispatchEvent(new CustomEvent('mapchip-picked', {\n                detail: { picked },\n                bubbles: true,\n                composed: true\n            }));\n        }));\n    }\n    get inactiveLayerOpacity() {\n        return this._inactiveLayerOpacity;\n    }\n    set inactiveLayerOpacity(value) {\n        const oldValue = this._inactiveLayerOpacity;\n        this._inactiveLayerOpacity = value;\n        this.setInactiveCanvasStyle();\n        this.requestUpdate('inactiveLayerOpacity', oldValue);\n    }\n    get projectId() {\n        return this._projectId;\n    }\n    set projectId(value) {\n        const oldValue = this._projectId;\n        this._projectId = value;\n        this.setupProject();\n        this.requestUpdate('projectId', oldValue);\n    }\n    get brush() {\n        return this._brushName;\n    }\n    set brush(value) {\n        const oldValue = this._brushName;\n        this._brushName = value;\n        this._mapCanvas.setBrushFromName(this._brushName);\n        this.requestUpdate('brush', oldValue);\n    }\n    get arrangement() {\n        return this._arrangementName;\n    }\n    set arrangement(value) {\n        const oldValue = this._arrangementName;\n        this._arrangementName = value;\n        this._mapCanvas.setArrangementFromName(this._arrangementName);\n        this.requestUpdate('arrangement', oldValue);\n    }\n    get autoTileId() {\n        var _a;\n        return ((_a = this._mapCanvas.selectedAutoTile) === null || _a === void 0 ? void 0 : _a.id) || -1;\n    }\n    set autoTileId(value) {\n        var _a;\n        const oldValue = value;\n        const autoTile = (_a = this._project) === null || _a === void 0 ? void 0 : _a.tiledMap.autoTiles.fromId(value);\n        this._autoTileIdAttributeValue = value;\n        this.setActiveAutoTile(true);\n        this.requestUpdate('autoTileId', oldValue);\n    }\n    get mapChipFragmentProperties() {\n        var _a;\n        return ((_a = this._mapCanvas.selectedMapChipFragments) === null || _a === void 0 ? void 0 : _a.map(mapChipFragment => mapChipFragment.toObject())) || null;\n    }\n    set mapChipFragmentProperties(values) {\n        const oldValue = values;\n        this.requestUpdate('mapChipFragmentProperties', oldValue);\n        if (!values)\n            return;\n        const mapChipFragments = values.map(value => _piyoppi_pico2map_tiled__WEBPACK_IMPORTED_MODULE_4__.MapChipFragment.fromObject(value));\n        this._mapCanvas.setMapChipFragments(mapChipFragments);\n    }\n    get activeLayer() {\n        return this._mapCanvas.activeLayer;\n    }\n    set activeLayer(value) {\n        this._mapCanvas.setActiveLayer(value);\n        this.setInactiveCanvasStyle();\n    }\n    get pickFromActiveLayer() {\n        return this._mapCanvas.isPickFromActiveLayer;\n    }\n    set pickFromActiveLayer(value) {\n        this._mapCanvas.isPickFromActiveLayer = value;\n    }\n    get width() {\n        return this.xCount * this.gridWidth;\n    }\n    get height() {\n        return this.yCount * this.gridHeight;\n    }\n    get xCount() {\n        var _a;\n        return ((_a = this._project) === null || _a === void 0 ? void 0 : _a.tiledMap.chipCountX) || 0;\n    }\n    get yCount() {\n        var _a;\n        return ((_a = this._project) === null || _a === void 0 ? void 0 : _a.tiledMap.chipCountY) || 0;\n    }\n    get gridWidth() {\n        var _a;\n        return ((_a = this._project) === null || _a === void 0 ? void 0 : _a.tiledMap.chipWidth) || 0;\n    }\n    get gridHeight() {\n        var _a;\n        return ((_a = this._project) === null || _a === void 0 ? void 0 : _a.tiledMap.chipHeight) || 0;\n    }\n    get mapCanvas() {\n        return this._mapCanvas;\n    }\n    set mapCanvas(value) {\n        this._mapCanvas = value;\n    }\n    setupProject() {\n        if (!this._project || this._project.projectId !== this._projectId) {\n            this._project = _piyoppi_pico2map_editor__WEBPACK_IMPORTED_MODULE_3__.Projects.fromProjectId(this._projectId);\n            if (!this._project)\n                return;\n            this._mapCanvas.setProject(this._project);\n            if (!this._mapCanvas.isSubscribedProjectEvent)\n                this._mapCanvas.subscribeProjectEvent();\n            this._mapCanvas.firstRenderAll();\n            this.setupMapCanvas();\n            this.setActiveAutoTile();\n            this.requestUpdate();\n            this._project.setCallback('beforeAddLayer', () => this._mapCanvas.addCanvas(this.addCanvasToDOMTree()));\n            this._project.setCallback('afterResizedMap', () => {\n                this.requestUpdate();\n                this._appendedLayerCanvases.forEach(canvas => {\n                    canvas.width = this.width;\n                    canvas.height = this.height;\n                });\n                this._mapCanvas.renderAll();\n            });\n        }\n    }\n    createCanvas() {\n        const canvas = document.createElement('canvas');\n        this.setupCanvas(canvas);\n        canvas.width = this.width;\n        canvas.height = this.height;\n        return canvas;\n    }\n    setupCanvas(canvas) {\n        canvas.width = this.width;\n        canvas.height = this.height;\n        const ctx = canvas.getContext('2d');\n        ctx === null || ctx === void 0 ? void 0 : ctx.clearRect(0, 0, this.width, this.height);\n    }\n    addCanvasToDOMTree() {\n        if (!this._canvasesOuterElement)\n            throw new Error();\n        const canvas = this.createCanvas();\n        canvas.id = `layer_canvas_${this._canvasMaxIds++}`;\n        this._canvasesOuterElement.appendChild(canvas);\n        this._appendedLayerCanvases.push(canvas);\n        return canvas;\n    }\n    removeCanvasToDOMTree(index) {\n        if (!this._canvasesOuterElement)\n            throw new Error();\n        const canvas = this._appendedLayerCanvases[index];\n        this._canvasesOuterElement.removeChild(canvas);\n        this._appendedLayerCanvases.splice(index, 1);\n    }\n    setActiveAutoTile(forced = false) {\n        if (!this._project || this._autoTileIdAttributeValue < 0)\n            return;\n        if (!this._mapCanvas.hasActiveAutoTile() || forced) {\n            const autoTile = this._project.tiledMap.autoTiles.fromId(this._autoTileIdAttributeValue);\n            if (!autoTile)\n                throw new Error(`AutoTile (id: ${this._autoTileIdAttributeValue}) is not found.`);\n            this._mapCanvas.setAutoTile(autoTile);\n        }\n    }\n    setupMapCanvas() {\n        if (!this._project || !this._secondaryCanvasElement || !this._canvasesOuterElement)\n            return;\n        const diffCanvasCount = this._project.tiledMap.datas.length - this._appendedLayerCanvases.length;\n        this._appendedLayerCanvases.forEach(canvas => this.setupCanvas(canvas));\n        if (diffCanvasCount > 0) {\n            for (let i = 0; i < diffCanvasCount; i++) {\n                this.addCanvasToDOMTree();\n            }\n        }\n        else if (diffCanvasCount < 0) {\n            const layerCanvasesLength = this._appendedLayerCanvases.length;\n            for (let i = layerCanvasesLength - 1; i >= layerCanvasesLength + diffCanvasCount; i--) {\n                this.removeCanvasToDOMTree(i);\n            }\n        }\n        this._mapCanvas.setCanvases(this._appendedLayerCanvases, this._secondaryCanvasElement);\n    }\n    setInactiveCanvasStyle() {\n        if (!this._canvasesOuterElement)\n            return;\n        this._canvasesOuterElement.childNodes.forEach((node, index) => {\n            const element = node;\n            if (this.activeLayer === index) {\n                element.style.opacity = '1.0';\n            }\n            else {\n                element.style.opacity = this._inactiveLayerOpacity.toString();\n            }\n        });\n    }\n    firstUpdated() {\n        var _a, _b, _c;\n        const element = (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.getElementById('boundary');\n        if (element)\n            this.cursorPositionCalculator.setElement(element);\n        this._secondaryCanvasElement = (_b = this.shadowRoot) === null || _b === void 0 ? void 0 : _b.getElementById('secondary-canvas');\n        this._canvasesOuterElement = (_c = this.shadowRoot) === null || _c === void 0 ? void 0 : _c.getElementById('canvases');\n        this.setupMapCanvas();\n    }\n    mouseMove(e) {\n        const mouseCursorPosition = this.cursorPositionCalculator.getMouseCursorPosition(e.pageX, e.pageY);\n        this._mapCanvas.mouseMove(mouseCursorPosition.x, mouseCursorPosition.y);\n    }\n    mouseDown(e) {\n        const mouseCursorPosition = this.cursorPositionCalculator.getMouseCursorPosition(e.pageX, e.pageY);\n        this._mapCanvas.mouseDown(mouseCursorPosition.x, mouseCursorPosition.y, e.button === 2);\n        this._documentMouseMoveEventCallee = e => this.mouseMove(e);\n        this._documentMouseUpEventCallee = e => this.mouseUp(e);\n        document.addEventListener('mousemove', this._documentMouseMoveEventCallee);\n        document.addEventListener('mouseup', this._documentMouseUpEventCallee);\n    }\n    mouseUp(e) {\n        const mouseCursorPosition = this.cursorPositionCalculator.getMouseCursorPosition(e.pageX, e.pageY);\n        this._mapCanvas.mouseUp(mouseCursorPosition.x, mouseCursorPosition.y);\n        if (this._documentMouseMoveEventCallee)\n            document.removeEventListener('mousemove', this._documentMouseMoveEventCallee);\n        if (this._documentMouseUpEventCallee)\n            document.removeEventListener('mouseup', this._documentMouseUpEventCallee);\n        this._documentMouseMoveEventCallee = null;\n        this._documentMouseUpEventCallee = null;\n    }\n    render() {\n        return lit__WEBPACK_IMPORTED_MODULE_0__.html `\n      <style>\n        #boundary {\n          width: ${this.width + 1}px;\n          height: ${this.height + 1}px;\n        }\n      </style>\n\n      <div id=\"boundary\"\n        @mousedown=\"${(e) => this.mouseDown(e)}\"\n        @mousemove=\"${(e) => !this._mapCanvas.isMouseDown ? this.mouseMove(e) : null}\"\n        @contextmenu=\"${(e) => this.preventDefaultContextMenu && e.preventDefault()}\"\n      >\n        <div id=\"canvases\"></div>\n        <canvas\n          id=\"secondary-canvas\"\n          width=\"${this.width}\"\n          height=\"${this.height}\"\n        ></canvas>\n        ${this.gridCursorHidden ? null : lit__WEBPACK_IMPORTED_MODULE_0__.html `\n          <map-grid-component\n            gridWidth=\"${this.gridWidth}\"\n            gridHeight=\"${this.gridHeight}\"\n            chipCountX=\"${this.xCount}\"\n            chipCountY=\"${this.yCount}\"\n            gridColor=\"${this.gridColor}\"\n          ></map-grid-component>`}\n      </div>\n    `;\n    }\n    static get styles() {\n        return lit__WEBPACK_IMPORTED_MODULE_0__.css `\n      #canvases {\n        position: relative;\n      }\n\n      #canvases > canvas {\n        position: absolute;\n        top: 0;\n        left: 0;\n      }\n\n      #boundary {\n        position: relative;\n      }\n\n      #secondary-canvas {\n        pointer-events: none;\n        position: absolute;\n        top: 0;\n        left: 0;\n      }\n    `;\n    }\n    disconnectedCallback() {\n        super.disconnectedCallback();\n        this._mapCanvas.unsubscribeProjectEvent();\n    }\n    connectedCallback() {\n        super.connectedCallback();\n        if (this._mapCanvas.hasProject && !this._mapCanvas.isSubscribedProjectEvent)\n            this._mapCanvas.subscribeProjectEvent();\n    }\n}\n__decorate([\n    (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({ type: Boolean })\n], MapCanvasComponent.prototype, \"gridCursorHidden\", void 0);\n__decorate([\n    (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({ type: Boolean })\n], MapCanvasComponent.prototype, \"preventDefaultContextMenu\", void 0);\n__decorate([\n    (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({ type: String })\n], MapCanvasComponent.prototype, \"gridColor\", void 0);\n__decorate([\n    (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({ type: Number })\n], MapCanvasComponent.prototype, \"inactiveLayerOpacity\", null);\n__decorate([\n    (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({ type: Number })\n], MapCanvasComponent.prototype, \"projectId\", null);\n__decorate([\n    (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({ type: String })\n], MapCanvasComponent.prototype, \"brush\", null);\n__decorate([\n    (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({ type: String })\n], MapCanvasComponent.prototype, \"arrangement\", null);\n__decorate([\n    (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({ type: Number })\n], MapCanvasComponent.prototype, \"autoTileId\", null);\n__decorate([\n    (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({ type: Object })\n], MapCanvasComponent.prototype, \"mapChipFragmentProperties\", null);\n__decorate([\n    (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({ type: Number })\n], MapCanvasComponent.prototype, \"activeLayer\", null);\n__decorate([\n    (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({ type: Boolean })\n], MapCanvasComponent.prototype, \"pickFromActiveLayer\", null);\n\n\n/***/ }),\n/* 20 */\n/***/ ((module) => {\n\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(self, function() {\nreturn /******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ([\n/* 0 */,\n/* 1 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_541__) => {\n\n__nested_webpack_require_541__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_541__.d(__webpack_exports__, {\n/* harmony export */   \"TiledMap\": () => (/* binding */ TiledMap)\n/* harmony export */ });\n/* harmony import */ var _MapChipsCollection__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_541__(2);\n/* harmony import */ var _AutoTile_AutoTiles__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_541__(4);\n/* harmony import */ var _MapData_TiledMapData__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_541__(7);\n/* harmony import */ var _MapData_ColiderMap__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_541__(11);\n\n\n\n\nclass TiledMap {\n    constructor(_chipCountX, _chipCountY, _chipWidth, _chipHeight) {\n        this._chipCountX = _chipCountX;\n        this._chipCountY = _chipCountY;\n        this._chipWidth = _chipWidth;\n        this._chipHeight = _chipHeight;\n        this._mapChipImages = new _MapChipsCollection__WEBPACK_IMPORTED_MODULE_0__.MapChipsCollection();\n        this._autoTiles = new _AutoTile_AutoTiles__WEBPACK_IMPORTED_MODULE_1__.AutoTiles();\n        this._datas = [];\n        this._coliders = new _MapData_ColiderMap__WEBPACK_IMPORTED_MODULE_3__.ColiderMap(this._chipCountX, this._chipCountY);\n        this.addLayer();\n    }\n    get chipWidth() {\n        return this._chipWidth;\n    }\n    get chipHeight() {\n        return this._chipHeight;\n    }\n    get chipCountX() {\n        return this._chipCountX;\n    }\n    get chipCountY() {\n        return this._chipCountY;\n    }\n    get mapChipsCollection() {\n        return this._mapChipImages;\n    }\n    get autoTiles() {\n        return this._autoTiles;\n    }\n    get datas() {\n        return this._datas;\n    }\n    get coliders() {\n        return this._coliders;\n    }\n    convertChipPositionToPixel(chipX, chipY) {\n        return {\n            x: chipX * this.chipWidth,\n            y: chipY * this.chipHeight\n        };\n    }\n    put(mapChip, chipX, chipY, index) {\n        this._datas[index].put(mapChip, chipX, chipY);\n    }\n    toObject() {\n        return {\n            chipCountX: this._chipCountX,\n            chipCountY: this._chipCountY,\n            chipWidth: this._chipWidth,\n            chipHeight: this._chipHeight,\n            mapChipImages: this._mapChipImages.toObject(),\n            autoTiles: this._autoTiles.toObject(),\n            tiledMapDatas: this._datas.map(data => data.toObject()),\n            coliders: this._coliders.toObject()\n        };\n    }\n    addLayer() {\n        this._datas.push(new _MapData_TiledMapData__WEBPACK_IMPORTED_MODULE_2__.TiledMapData(this._chipCountX, this._chipCountY));\n    }\n    convertMapNumberToPosition(num) {\n        return {\n            x: num % this._chipCountX,\n            y: Math.floor(num / this._chipCountX)\n        };\n    }\n    resize(chipCountX, chipCountY) {\n        this._chipCountX = chipCountX;\n        this._chipCountY = chipCountY;\n        this._datas.forEach(item => item.resize(chipCountX, chipCountY, null));\n        this._coliders.resize(chipCountX, chipCountY, 0);\n    }\n    setSerializedProperties(val) {\n        this._mapChipImages.fromObject(val.mapChipImages);\n        this._autoTiles.fromObject(val.autoTiles);\n        this._datas = val.tiledMapDatas.map(tiledMapData => _MapData_TiledMapData__WEBPACK_IMPORTED_MODULE_2__.TiledMapData.fromObject(tiledMapData));\n        this._coliders = _MapData_ColiderMap__WEBPACK_IMPORTED_MODULE_3__.ColiderMap.fromObject(val.coliders);\n    }\n    static fromObject(val) {\n        const tiledMap = new TiledMap(val.chipCountX, val.chipCountY, val.chipWidth, val.chipHeight);\n        tiledMap.setSerializedProperties({ mapChipImages: val.mapChipImages, autoTiles: val.autoTiles, tiledMapDatas: val.tiledMapDatas, coliders: val.coliders });\n        return tiledMap;\n    }\n}\n\n\n/***/ }),\n/* 2 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_4382__) => {\n\n__nested_webpack_require_4382__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_4382__.d(__webpack_exports__, {\n/* harmony export */   \"MapChipsCollection\": () => (/* binding */ MapChipsCollection)\n/* harmony export */ });\n/* harmony import */ var _MapChipImage__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_4382__(3);\n\nclass MapChipsCollection {\n    constructor() {\n        this._items = new Map();\n    }\n    push(item) {\n        this._items.set(item.id, item);\n    }\n    remove(item) {\n        this._items.delete(item.id);\n    }\n    replace(replacement) {\n        const target = this.findById(replacement.id);\n        if (!target)\n            throw new Error('Target MapChipImage cannot be found.');\n        this.remove(target);\n        this.push(replacement);\n    }\n    findById(chipId) {\n        return this._items.get(chipId) || null;\n    }\n    getItems() {\n        return Array.from(this._items.values());\n    }\n    async waitWhileLoading() {\n        await Promise.all(Array.from(this._items.values()).map(item => item.waitWhileLoading()));\n    }\n    toObject() {\n        const objectedMapChipImage = [];\n        const valuesItr = this._items.values();\n        for (const val of valuesItr) {\n            objectedMapChipImage.push(val.toObject());\n        }\n        return {\n            items: objectedMapChipImage\n        };\n    }\n    fromObject(val) {\n        this._items.clear();\n        val.items.forEach(objectedVal => {\n            this.push(_MapChipImage__WEBPACK_IMPORTED_MODULE_0__.MapChipImage.fromObject(objectedVal));\n        });\n    }\n}\n\n\n/***/ }),\n/* 3 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_6034__) => {\n\n__nested_webpack_require_6034__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_6034__.d(__webpack_exports__, {\n/* harmony export */   \"MapChipImage\": () => (/* binding */ MapChipImage)\n/* harmony export */ });\nclass MapChipImage {\n    constructor(_src, _id) {\n        this._src = _src;\n        this._id = _id;\n        this._image = new Image();\n        this._hasImage = false;\n        this._hasError = false;\n        this.loadImage();\n    }\n    get id() {\n        return this._id;\n    }\n    get src() {\n        return this._src;\n    }\n    get hasImage() {\n        return this._hasImage;\n    }\n    get hasError() {\n        return this._hasError;\n    }\n    get image() {\n        return this._image;\n    }\n    getChipCount(chipWidth, chipHeight) {\n        if (!this._hasImage)\n            throw new Error('Image loading is not complete.');\n        return {\n            width: Math.floor(this._image.width / chipWidth),\n            height: Math.floor(this._image.height / chipHeight)\n        };\n    }\n    _loadImageHandler() {\n        this._hasImage = true;\n    }\n    _errorImaegHandler() {\n        this._hasError = true;\n    }\n    loadImage() {\n        this._hasImage = false;\n        this._hasError = false;\n        this._image.onload = () => this._loadImageHandler();\n        this._image.onerror = () => this._errorImaegHandler();\n        this._image.src = this._src;\n    }\n    waitWhileLoading() {\n        const loadingPromise = new Promise((resolve, reject) => {\n            this._image.onload = () => {\n                this._loadImageHandler();\n                resolve();\n            };\n            this._image.onerror = () => {\n                this._errorImaegHandler();\n                reject(new Error('Failed to load the image.'));\n            };\n        });\n        if (this._hasImage)\n            return Promise.resolve();\n        if (this._hasError)\n            return Promise.reject(new Error('Failed to load the image.'));\n        return loadingPromise;\n    }\n    toObject() {\n        return {\n            id: this._id,\n            src: this._src\n        };\n    }\n    static fromObject(val) {\n        return new MapChipImage(val.src, val.id);\n    }\n}\n\n\n/***/ }),\n/* 4 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_8296__) => {\n\n__nested_webpack_require_8296__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_8296__.d(__webpack_exports__, {\n/* harmony export */   \"AutoTiles\": () => (/* binding */ AutoTiles)\n/* harmony export */ });\n/* harmony import */ var _AutoTile__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_8296__(5);\n\nclass AutoTiles {\n    constructor() {\n        this._autoTiles = new Map();\n        this._maxId = 0;\n    }\n    get length() {\n        return this._autoTiles.size;\n    }\n    push(item) {\n        this._autoTiles.set(item.id, item);\n        this._maxId = Math.max(this._maxId, item.id);\n    }\n    remove(item) {\n        this._autoTiles.delete(item.id);\n    }\n    findByImage(image) {\n        const valuesItr = this._autoTiles.values();\n        return Array.from(valuesItr).filter(autoTile => autoTile.mapChipFragments.some(fragment => fragment.chipId === image.id));\n    }\n    fromId(id) {\n        return this._autoTiles.get(id) || null;\n    }\n    values() {\n        return this._autoTiles.values();\n    }\n    import(strategy) {\n        const mapChipFragmentGroups = strategy.getMapChipFragments();\n        return mapChipFragmentGroups.map(group => {\n            const autoTile = new _AutoTile__WEBPACK_IMPORTED_MODULE_0__.AutoTile(group, ++this._maxId);\n            this.push(autoTile);\n            return autoTile;\n        });\n    }\n    toObject() {\n        const objectedAutoTiles = [];\n        const valuesItr = this._autoTiles.values();\n        for (const val of valuesItr) {\n            objectedAutoTiles.push(val.toObject());\n        }\n        return {\n            autoTiles: objectedAutoTiles\n        };\n    }\n    fromObject(val) {\n        this._autoTiles.clear();\n        val.autoTiles.forEach(objectedAutoTile => {\n            const autoTile = _AutoTile__WEBPACK_IMPORTED_MODULE_0__.AutoTile.fromObject(objectedAutoTile);\n            this.push(autoTile);\n            this._maxId = Math.max(this._maxId, autoTile.id);\n        });\n    }\n}\n\n\n/***/ }),\n/* 5 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_10334__) => {\n\n__nested_webpack_require_10334__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_10334__.d(__webpack_exports__, {\n/* harmony export */   \"AutoTile\": () => (/* binding */ AutoTile)\n/* harmony export */ });\n/* harmony import */ var _MapChip__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_10334__(6);\n\nclass AutoTile {\n    constructor(_mapChipFragments, _id) {\n        this._mapChipFragments = _mapChipFragments;\n        this._id = _id;\n    }\n    get id() {\n        return this._id;\n    }\n    get mapChipFragments() {\n        return this._mapChipFragments;\n    }\n    getMapChipImageIds() {\n        const chipIds = new Set();\n        this._mapChipFragments.forEach(fragment => chipIds.add(fragment.chipId));\n        return Array.from(chipIds.values());\n    }\n    toObject() {\n        return {\n            id: this._id,\n            mapChipFragments: this._mapChipFragments.map(fragment => fragment.toObject())\n        };\n    }\n    static fromObject(val) {\n        return new AutoTile(val.mapChipFragments.map(fragment => _MapChip__WEBPACK_IMPORTED_MODULE_0__.MapChipFragment.fromObject(fragment)), val.id);\n    }\n}\n\n\n/***/ }),\n/* 6 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_11537__) => {\n\n__nested_webpack_require_11537__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_11537__.d(__webpack_exports__, {\n/* harmony export */   \"MapChipFragment\": () => (/* binding */ MapChipFragment),\n/* harmony export */   \"MapChip\": () => (/* binding */ MapChip),\n/* harmony export */   \"isAutoTileMapChipProperties\": () => (/* binding */ isAutoTileMapChipProperties),\n/* harmony export */   \"AutoTileMapChip\": () => (/* binding */ AutoTileMapChip),\n/* harmony export */   \"isAutoTileMapChip\": () => (/* binding */ isAutoTileMapChip)\n/* harmony export */ });\nclass MapChipFragment {\n    constructor(_x, _y, _chipId, \n    /**\n     *  _renderingArea indicates the area where this map-chip is to be drawn.\n     *  It is represented by a OR of the following area-numbers.\n     *\n     * |<- 1chip ->|\n     * *-----*-----* ---\n     * |  1  |  2  |  ↑\n     * *-----*-----* 1chip\n     * |  4  |  8  |  ↓\n     * *-----*-----* ---\n     */\n    _renderingArea = 15) {\n        this._x = _x;\n        this._y = _y;\n        this._chipId = _chipId;\n        this._renderingArea = _renderingArea;\n        this._identifyKey = '';\n        this._identifyKey = `${_x},${_y},${_chipId}`;\n    }\n    get x() {\n        return this._x;\n    }\n    get y() {\n        return this._y;\n    }\n    get chipId() {\n        return this._chipId;\n    }\n    get identifyKey() {\n        return this._identifyKey;\n    }\n    get renderingArea() {\n        return this._renderingArea;\n    }\n    withParameter(parameters) {\n        if (parameters.x)\n            this._x = parameters.x;\n        if (parameters.y)\n            this._y = parameters.y;\n        if (parameters.renderingArea)\n            this._renderingArea = parameters.renderingArea;\n        return this;\n    }\n    clone() {\n        return new MapChipFragment(this._x, this._y, this._chipId);\n    }\n    compare(others) {\n        return this.identifyKey === others.identifyKey;\n    }\n    toObject() {\n        return {\n            x: this._x,\n            y: this._y,\n            chipId: this._chipId,\n            renderingArea: this._renderingArea\n        };\n    }\n    static fromObject(val) {\n        return new MapChipFragment(val.x, val.y, val.chipId, val.renderingArea);\n    }\n}\nclass MapChip {\n    constructor(_items = [], _arrangementName = '') {\n        this._items = _items;\n        this._arrangementName = _arrangementName;\n        this._identifyKey = '';\n        this._buildIdentifyKey();\n    }\n    get items() {\n        return this._items;\n    }\n    get identifyKey() {\n        return this._identifyKey;\n    }\n    get length() {\n        return this._items.length;\n    }\n    get arrangementName() {\n        return this._arrangementName;\n    }\n    _buildIdentifyKey() {\n        this._identifyKey = this._items.map(item => item.identifyKey).join('|');\n    }\n    setArrangementName(name) {\n        this._arrangementName = name;\n    }\n    push(mapChip) {\n        this._items.push(mapChip);\n        this._buildIdentifyKey();\n    }\n    clear() {\n        this._items.length = 0;\n        this._buildIdentifyKey();\n    }\n    clone() {\n        const cloned = new MapChip();\n        cloned._items = this._items.map(mapChip => mapChip.clone());\n        return cloned;\n    }\n    compare(others) {\n        return this.identifyKey === others.identifyKey;\n    }\n    toObject() {\n        return {\n            items: this._items.map(item => item.toObject()),\n            arrangementName: this._arrangementName\n        };\n    }\n    static fromObject(val) {\n        return new MapChip(val.items.map(item => MapChipFragment.fromObject(item)), val.arrangementName);\n    }\n}\nfunction isAutoTileMapChipProperties(obj) {\n    return obj &&\n        typeof obj.autoTileId === 'number' &&\n        obj.boundary !== undefined &&\n        obj.cross !== undefined;\n}\nclass AutoTileMapChip extends MapChip {\n    constructor(_autoTileId, items = [], _arrangementName = '', _boundary = {\n        top: false,\n        bottom: false,\n        left: false,\n        right: false\n    }, _cross = {\n        topLeft: false,\n        topRight: false,\n        bottomLeft: false,\n        bottomRight: false\n    }) {\n        super(items, _arrangementName);\n        this._autoTileId = _autoTileId;\n        this._boundary = _boundary;\n        this._cross = _cross;\n    }\n    get boundary() {\n        return this._boundary;\n    }\n    get cross() {\n        return this._cross;\n    }\n    get autoTileId() {\n        return this._autoTileId;\n    }\n    setBoundary(boundary) {\n        this._boundary = boundary;\n    }\n    setCross(cross) {\n        this._cross = cross;\n    }\n    toObject() {\n        return {\n            ...super.toObject(),\n            boundary: this._boundary,\n            cross: this._cross,\n            autoTileId: this._autoTileId\n        };\n    }\n    static fromObject(val) {\n        return new AutoTileMapChip(val.autoTileId, val.items.map(item => MapChipFragment.fromObject(item)), val.arrangementName, val.boundary, val.cross);\n    }\n}\nfunction isAutoTileMapChip(obj) {\n    return obj &&\n        typeof obj.boundary === 'object' &&\n        typeof obj.cross === 'object';\n}\n\n\n/***/ }),\n/* 7 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_16692__) => {\n\n__nested_webpack_require_16692__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_16692__.d(__webpack_exports__, {\n/* harmony export */   \"TiledMapData\": () => (/* binding */ TiledMapData)\n/* harmony export */ });\n/* harmony import */ var _MapChip__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_16692__(6);\n/* harmony import */ var _MapPaletteMatrix__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_16692__(8);\n\n\nclass TiledMapData extends _MapPaletteMatrix__WEBPACK_IMPORTED_MODULE_1__.MapPaletteMatrix {\n    filter(needles) {\n        const filtered = this.items.map(chip => needles.some(needle => !!chip && needle.compare(chip)) ? chip : null);\n        return new TiledMapData(this.width, this.height, filtered);\n    }\n    findByImage(image) {\n        const registeredChips = new Set();\n        return this.items.filter(chip => {\n            if (!chip)\n                return false;\n            const found = chip.items.find(fragment => fragment.chipId === image.id) && !registeredChips.has(chip.identifyKey);\n            if (found) {\n                registeredChips.add(chip.identifyKey);\n            }\n            return found;\n        });\n    }\n    toObject() {\n        return {\n            chipCountX: this.width,\n            chipCountY: this.height,\n            values: this.values.items,\n            palette: this.palette.map(data => data ? data.toObject() : null)\n        };\n    }\n    static fromObject(val) {\n        const palette = val.palette.map(data => {\n            if (!data)\n                return null;\n            if ((0,_MapChip__WEBPACK_IMPORTED_MODULE_0__.isAutoTileMapChipProperties)(data)) {\n                return _MapChip__WEBPACK_IMPORTED_MODULE_0__.AutoTileMapChip.fromObject(data);\n            }\n            return _MapChip__WEBPACK_IMPORTED_MODULE_0__.MapChip.fromObject(data);\n        });\n        const tiledMapData = new TiledMapData(val.chipCountX, val.chipCountY, []);\n        tiledMapData.setValuePalette(val.values, palette);\n        return tiledMapData;\n    }\n}\n\n\n/***/ }),\n/* 8 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_18777__) => {\n\n__nested_webpack_require_18777__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_18777__.d(__webpack_exports__, {\n/* harmony export */   \"MapPaletteMatrix\": () => (/* binding */ MapPaletteMatrix)\n/* harmony export */ });\n/* harmony import */ var _TransferEach__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_18777__(9);\n/* harmony import */ var _MapMatrix__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_18777__(10);\n\n\nclass MapPaletteMatrix {\n    constructor(chipCountX, chipCountY, items = []) {\n        this._paletteIndexes = new Map();\n        this._values = new _MapMatrix__WEBPACK_IMPORTED_MODULE_1__.MapMatrix(0, 0, []);\n        this._palette = [];\n        this._values = new _MapMatrix__WEBPACK_IMPORTED_MODULE_1__.MapMatrix(chipCountX, chipCountY, new Array(chipCountY * chipCountX).fill(-1));\n        if (items.length > 0) {\n            this.set(items);\n        }\n    }\n    get size() {\n        return this._values.size;\n    }\n    get width() {\n        return this._values.width;\n    }\n    get height() {\n        return this._values.height;\n    }\n    get items() {\n        return this._values.items.map(value => value >= 0 ? this._palette[value] : null);\n    }\n    get palette() {\n        return this._palette;\n    }\n    get values() {\n        return this._values;\n    }\n    set(items) {\n        if (items.length !== this._values.items.length)\n            throw new Error();\n        this._values.set(items.map(value => this._getOrGeneratePaletteIndex(value)));\n    }\n    setValuePalette(values, palette) {\n        if (values.length !== this._values.items.length)\n            throw new Error();\n        this._values.set([...values]);\n        this._palette = [...palette];\n        this._paletteIndexes.clear();\n        for (const [index, paletteItem] of this._palette.entries()) {\n            if (!paletteItem)\n                continue;\n            if (this._paletteIndexes.has(paletteItem.identifyKey)) {\n                this.rebuild();\n                break;\n            }\n            this._paletteIndexes.set(paletteItem.identifyKey, index);\n        }\n    }\n    transferFromTiledMapData(src, srcX, srcY, width, height, destX, destY) {\n        (0,_TransferEach__WEBPACK_IMPORTED_MODULE_0__.transferEach)(srcX, srcY, width, height, destX, destY, src.width, src.height, this.width, this.height, (pickupX, pickupY, putX, putY) => {\n            const item = src.getFromChipPosition(pickupX, pickupY);\n            this._values.put(this._getOrGeneratePaletteIndex(item), putX, putY);\n        });\n    }\n    resize(chipCountX, chipCountY, emptyValue) {\n        this._values.resize(chipCountX, chipCountY, this._getOrGeneratePaletteIndex(emptyValue));\n    }\n    getFromChipPosition(x, y) {\n        const paletteIndex = this._values.getFromChipPosition(x, y);\n        return paletteIndex >= 0 ? this._palette[paletteIndex] : null;\n    }\n    put(item, x, y) {\n        this._values.put(this._getOrGeneratePaletteIndex(item), x, y);\n    }\n    clone() {\n        const cloned = new MapPaletteMatrix(this.width, this.height);\n        cloned.setValuePalette(this._values.items, this._palette);\n        return cloned;\n    }\n    rebuild() {\n        const items = this.items;\n        this._palette = [];\n        this._paletteIndexes.clear();\n        this.set(items);\n    }\n    remove(target) {\n        if (!target)\n            return false;\n        const removePaletteId = this.palette.findIndex(item => (item === null || item === void 0 ? void 0 : item.identifyKey) === target.identifyKey);\n        if (removePaletteId < 0)\n            return false;\n        this.palette.splice(removePaletteId, 1);\n        this.values.items.forEach((paletteIndex, valueIndex) => {\n            if (paletteIndex === removePaletteId)\n                this.values.items[valueIndex] = -1;\n            if (paletteIndex > removePaletteId)\n                this.values.items[valueIndex] = this.values.items[valueIndex] - 1;\n        });\n        for (const [k, v] of this._paletteIndexes.entries()) {\n            if (v > removePaletteId)\n                this._paletteIndexes.set(k, v - 1);\n        }\n        this._paletteIndexes.delete(target.identifyKey);\n        return true;\n    }\n    getPaletteIndex(value) {\n        if (value === null)\n            return -1;\n        return this._paletteIndexes.get(value.identifyKey);\n    }\n    _getOrGeneratePaletteIndex(value) {\n        if (value === null)\n            return -1;\n        const index = this.getPaletteIndex(value);\n        if (index !== undefined)\n            return index;\n        this._palette.push(value);\n        const addedIndex = this._palette.length - 1;\n        this._paletteIndexes.set(value.identifyKey, addedIndex);\n        return addedIndex;\n    }\n}\n\n\n/***/ }),\n/* 9 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_23546__) => {\n\n__nested_webpack_require_23546__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_23546__.d(__webpack_exports__, {\n/* harmony export */   \"transferEach\": () => (/* binding */ transferEach)\n/* harmony export */ });\nfunction transferEach(srcX, srcY, width, height, destX, destY, srcWidth, srcHeight, destWidth, destHeight, callback) {\n    for (let x = 0; x < width; x++) {\n        const putX = destX + x;\n        const pickupX = srcX + x;\n        if (putX < 0 || putX >= destWidth)\n            continue;\n        if (pickupX < 0 || pickupX >= srcWidth)\n            continue;\n        for (let y = 0; y < height; y++) {\n            const putY = destY + y;\n            const pickupY = srcY + y;\n            if (putY < 0 || putY >= destHeight)\n                continue;\n            if (pickupY < 0 || pickupY >= srcHeight)\n                continue;\n            callback(pickupX, pickupY, putX, putY);\n        }\n    }\n}\n\n\n/***/ }),\n/* 10 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_24555__) => {\n\n__nested_webpack_require_24555__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_24555__.d(__webpack_exports__, {\n/* harmony export */   \"MapMatrix\": () => (/* binding */ MapMatrix)\n/* harmony export */ });\n/* harmony import */ var _TransferEach__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_24555__(9);\n\nclass MapMatrix {\n    constructor(_chipCountX, _chipCountY, items = []) {\n        this._chipCountX = _chipCountX;\n        this._chipCountY = _chipCountY;\n        this._items = [];\n        if (items.length > 0 && this.size !== items.length) {\n            throw new Error();\n        }\n        if (items.length === 0) {\n            this.allocate();\n        }\n        else {\n            this._items = items;\n        }\n    }\n    get size() {\n        return this._chipCountX * this._chipCountY;\n    }\n    get width() {\n        return this._chipCountX;\n    }\n    get height() {\n        return this._chipCountY;\n    }\n    get items() {\n        return this._items;\n    }\n    set(items) {\n        if (items.length !== this._items.length)\n            throw new Error();\n        this._items = items;\n    }\n    transferFromTiledMapData(src, srcX, srcY, width, height, destX, destY) {\n        (0,_TransferEach__WEBPACK_IMPORTED_MODULE_0__.transferEach)(srcX, srcY, width, height, destX, destY, src.width, src.height, this.width, this.height, (pickupX, pickupY, putX, putY) => {\n            const item = src.getFromChipPosition(pickupX, pickupY);\n            this.put(item, putX, putY);\n        });\n    }\n    resize(chipCountX, chipCountY, emptyValue) {\n        const src = this.clone();\n        this._chipCountX = chipCountX;\n        this._chipCountY = chipCountY;\n        this.allocate(emptyValue);\n        this.transferFromTiledMapData(src, 0, 0, src.width, src.height, 0, 0);\n    }\n    getFromChipPosition(x, y) {\n        if (this.isOutOfRange(x, y))\n            throw new Error('The position is out of range.');\n        const mapNumber = this.convertPositionToMapNumber(x, y);\n        return this._items[mapNumber];\n    }\n    put(item, x, y) {\n        const mapNumber = this.convertPositionToMapNumber(x, y);\n        this._items[mapNumber] = item;\n    }\n    clone() {\n        return new MapMatrix(this._chipCountX, this._chipCountY, this._items);\n    }\n    convertPositionToMapNumber(x, y) {\n        return y * this._chipCountX + x;\n    }\n    isOutOfRange(x, y) {\n        return (x < 0) || (y < 0) || (x >= this._chipCountX) || (y >= this._chipCountY);\n    }\n    allocate(defaultValue = null) {\n        this._items = new Array(this._chipCountY * this._chipCountX).fill(defaultValue);\n    }\n}\n\n\n/***/ }),\n/* 11 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_27237__) => {\n\n__nested_webpack_require_27237__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_27237__.d(__webpack_exports__, {\n/* harmony export */   \"ColiderMap\": () => (/* binding */ ColiderMap)\n/* harmony export */ });\n/* harmony import */ var _MapMatrix__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_27237__(10);\n\nclass ColiderMap extends _MapMatrix__WEBPACK_IMPORTED_MODULE_0__.MapMatrix {\n    toObject() {\n        return {\n            chipCountX: this._chipCountX,\n            chipCountY: this._chipCountY,\n            coliders: this._items\n        };\n    }\n    static fromObject(val) {\n        return new ColiderMap(val.chipCountX, val.chipCountY, val.coliders);\n    }\n    allocate() {\n        super.allocate(0);\n    }\n}\n\n\n/***/ }),\n/* 12 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_28047__) => {\n\n__nested_webpack_require_28047__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_28047__.d(__webpack_exports__, {\n/* harmony export */   \"DefaultAutoTileImportStrategy\": () => (/* binding */ DefaultAutoTileImportStrategy)\n/* harmony export */ });\n/* harmony import */ var _MapChip__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_28047__(6);\n\nclass DefaultAutoTileImportStrategy {\n    constructor(_mapChipImage, _chipWidth, _chipHeight) {\n        this._mapChipImage = _mapChipImage;\n        this._chipWidth = _chipWidth;\n        this._chipHeight = _chipHeight;\n    }\n    getMapChipFragments() {\n        const heightChipCountPerUnit = 5;\n        const countX = Math.floor(this._mapChipImage.image.width / this._chipWidth);\n        const countY = Math.floor(Math.floor(this._mapChipImage.image.height / this._chipHeight) / heightChipCountPerUnit);\n        const mapChipFragmentGroups = [];\n        for (let cy = 0; cy < countY; cy++) {\n            const y = cy * heightChipCountPerUnit;\n            for (let x = 0; x < countX; x++) {\n                const mapChipFragments = [];\n                mapChipFragments.push(new _MapChip__WEBPACK_IMPORTED_MODULE_0__.MapChipFragment(x, y, this._mapChipImage.id));\n                mapChipFragments.push(new _MapChip__WEBPACK_IMPORTED_MODULE_0__.MapChipFragment(x, y + 1, this._mapChipImage.id));\n                mapChipFragments.push(new _MapChip__WEBPACK_IMPORTED_MODULE_0__.MapChipFragment(x, y + 2, this._mapChipImage.id));\n                mapChipFragments.push(new _MapChip__WEBPACK_IMPORTED_MODULE_0__.MapChipFragment(x, y + 3, this._mapChipImage.id));\n                mapChipFragments.push(new _MapChip__WEBPACK_IMPORTED_MODULE_0__.MapChipFragment(x, y + 4, this._mapChipImage.id));\n                mapChipFragmentGroups.push(mapChipFragments);\n            }\n        }\n        return mapChipFragmentGroups;\n    }\n}\n\n\n/***/ }),\n/* 13 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_29999__) => {\n\n__nested_webpack_require_29999__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_29999__.d(__webpack_exports__, {\n/* harmony export */   \"MapRenderer\": () => (/* binding */ MapRenderer)\n/* harmony export */ });\nclass MapRenderer {\n    constructor(_tiledMap) {\n        this._tiledMap = _tiledMap;\n        this._backgroundRgba = { r: 255, g: 255, b: 255, a: 1.0 };\n    }\n    setTiledMap(tiledMap) {\n        this._tiledMap = tiledMap;\n    }\n    renderAll(ctx) {\n        this._tiledMap.datas.forEach(data => this.render(data, ctx));\n    }\n    renderLayer(index, ctx) {\n        this.render(this._tiledMap.datas[index], ctx);\n    }\n    render(data, ctx) {\n        data.items.forEach((value, index) => {\n            const position = this._tiledMap.convertMapNumberToPosition(index);\n            this.putOrClearChipToCanvas(ctx, value, position.x, position.y);\n        });\n    }\n    putOrClearChipToCanvas(ctx, mapChip, chipX, chipY, isTemporaryRendering = false) {\n        if (!mapChip) {\n            this._clearChipToCanvas(ctx, chipX, chipY, isTemporaryRendering);\n        }\n        else {\n            mapChip.items.forEach(item => {\n                this._putChipToCanvas(ctx, item, chipX, chipY);\n            });\n        }\n    }\n    _clearChipToCanvas(ctx, chipX, chipY, isTemporaryRendering) {\n        const position = this._tiledMap.convertChipPositionToPixel(chipX, chipY);\n        ctx.clearRect(position.x, position.y, this._tiledMap.chipWidth, this._tiledMap.chipHeight);\n        if (isTemporaryRendering) {\n            ctx.fillStyle = `rgba(${this._backgroundRgba.r},${this._backgroundRgba.g},${this._backgroundRgba.b},${this._backgroundRgba.a})`;\n            ctx.fillRect(position.x, position.y, this._tiledMap.chipWidth, this._tiledMap.chipHeight);\n        }\n    }\n    _putChipToCanvas(ctx, mapChip, chipX, chipY) {\n        const mapChips = this._tiledMap.mapChipsCollection.findById(mapChip.chipId);\n        const image = mapChips === null || mapChips === void 0 ? void 0 : mapChips.image;\n        if (!image)\n            return;\n        const renderingArea = this._getRenderingArea(mapChip);\n        const position = this._tiledMap.convertChipPositionToPixel(chipX, chipY);\n        position.x += renderingArea.destOffsetX;\n        position.y += renderingArea.destOffsetY;\n        ctx.clearRect(position.x, position.y, renderingArea.width, renderingArea.height);\n        ctx.drawImage(image, renderingArea.x, renderingArea.y, renderingArea.width, renderingArea.height, position.x, position.y, renderingArea.width, renderingArea.height);\n    }\n    _getRenderingArea(mapChip) {\n        const width = this._tiledMap.chipWidth;\n        const height = this._tiledMap.chipHeight;\n        const x = mapChip.x * width;\n        const y = mapChip.y * height;\n        if (mapChip.renderingArea === 15) {\n            return { x, y, width, height, destOffsetX: 0, destOffsetY: 0 };\n        }\n        const halfWidth = Math.round(width / 2);\n        const halfHeight = Math.round(height / 2);\n        switch (mapChip.renderingArea) {\n            case 1:\n                return { x, y, width: halfWidth, height: halfHeight, destOffsetX: 0, destOffsetY: 0 };\n            case 2:\n                return { x: x + halfWidth, y, width: halfWidth, height: halfHeight, destOffsetX: halfWidth, destOffsetY: 0 };\n            case 3:\n                return { x, y, width, height: halfHeight, destOffsetX: 0, destOffsetY: 0 };\n            case 4:\n                return { x, y: y + halfHeight, width: halfWidth, height: halfHeight, destOffsetX: 0, destOffsetY: halfHeight };\n            case 5:\n                return { x, y, width: halfWidth, height, destOffsetX: 0, destOffsetY: 0 };\n            case 8:\n                return { x: x + halfWidth, y: y + halfHeight, width: halfWidth, height: halfHeight, destOffsetX: halfWidth, destOffsetY: halfHeight };\n            case 10:\n                return { x: x + halfWidth, y, width: halfWidth, height, destOffsetX: halfWidth, destOffsetY: 0 };\n            case 12:\n                return { x, y: y + halfHeight, width, height: halfHeight, destOffsetX: 0, destOffsetY: halfHeight };\n        }\n    }\n}\n\n\n/***/ })\n/******/ \t]);\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_34379__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_34379__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/define property getters */\n/******/ \t(() => {\n/******/ \t\t// define getter functions for harmony exports\n/******/ \t\t__nested_webpack_require_34379__.d = (exports, definition) => {\n/******/ \t\t\tfor(var key in definition) {\n/******/ \t\t\t\tif(__nested_webpack_require_34379__.o(definition, key) && !__nested_webpack_require_34379__.o(exports, key)) {\n/******/ \t\t\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n/******/ \t\t\t\t}\n/******/ \t\t\t}\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/hasOwnProperty shorthand */\n/******/ \t(() => {\n/******/ \t\t__nested_webpack_require_34379__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/make namespace object */\n/******/ \t(() => {\n/******/ \t\t// define __esModule on exports\n/******/ \t\t__nested_webpack_require_34379__.r = (exports) => {\n/******/ \t\t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t\t}\n/******/ \t\t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/************************************************************************/\nvar __webpack_exports__ = {};\n// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.\n(() => {\n__nested_webpack_require_34379__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_34379__.d(__webpack_exports__, {\n/* harmony export */   \"TiledMap\": () => (/* reexport safe */ _TiledMap__WEBPACK_IMPORTED_MODULE_0__.TiledMap),\n/* harmony export */   \"TiledMapData\": () => (/* reexport safe */ _MapData_TiledMapData__WEBPACK_IMPORTED_MODULE_1__.TiledMapData),\n/* harmony export */   \"MapChipImage\": () => (/* reexport safe */ _MapChipImage__WEBPACK_IMPORTED_MODULE_2__.MapChipImage),\n/* harmony export */   \"MapChipsCollection\": () => (/* reexport safe */ _MapChipsCollection__WEBPACK_IMPORTED_MODULE_3__.MapChipsCollection),\n/* harmony export */   \"MapChipFragment\": () => (/* reexport safe */ _MapChip__WEBPACK_IMPORTED_MODULE_4__.MapChipFragment),\n/* harmony export */   \"MapChip\": () => (/* reexport safe */ _MapChip__WEBPACK_IMPORTED_MODULE_4__.MapChip),\n/* harmony export */   \"AutoTileMapChip\": () => (/* reexport safe */ _MapChip__WEBPACK_IMPORTED_MODULE_4__.AutoTileMapChip),\n/* harmony export */   \"isAutoTileMapChip\": () => (/* reexport safe */ _MapChip__WEBPACK_IMPORTED_MODULE_4__.isAutoTileMapChip),\n/* harmony export */   \"AutoTiles\": () => (/* reexport safe */ _AutoTile_AutoTiles__WEBPACK_IMPORTED_MODULE_5__.AutoTiles),\n/* harmony export */   \"AutoTile\": () => (/* reexport safe */ _AutoTile_AutoTile__WEBPACK_IMPORTED_MODULE_6__.AutoTile),\n/* harmony export */   \"DefaultAutoTileImportStrategy\": () => (/* reexport safe */ _AutoTile_DefaultAutoTileImportStrategy__WEBPACK_IMPORTED_MODULE_7__.DefaultAutoTileImportStrategy),\n/* harmony export */   \"ColiderMap\": () => (/* reexport safe */ _MapData_ColiderMap__WEBPACK_IMPORTED_MODULE_8__.ColiderMap),\n/* harmony export */   \"MapRenderer\": () => (/* reexport safe */ _MapRenderer__WEBPACK_IMPORTED_MODULE_9__.MapRenderer)\n/* harmony export */ });\n/* harmony import */ var _TiledMap__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_34379__(1);\n/* harmony import */ var _MapData_TiledMapData__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_34379__(7);\n/* harmony import */ var _MapChipImage__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_34379__(3);\n/* harmony import */ var _MapChipsCollection__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_34379__(2);\n/* harmony import */ var _MapChip__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_34379__(6);\n/* harmony import */ var _AutoTile_AutoTiles__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_34379__(4);\n/* harmony import */ var _AutoTile_AutoTile__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_34379__(5);\n/* harmony import */ var _AutoTile_DefaultAutoTileImportStrategy__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_34379__(12);\n/* harmony import */ var _MapData_ColiderMap__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_34379__(11);\n/* harmony import */ var _MapRenderer__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_34379__(13);\n\n\n\n\n\n\n\n\n\n\n\n})();\n\n/******/ \treturn __webpack_exports__;\n/******/ })()\n;\n});\n//# sourceMappingURL=main.js.map\n\n/***/ }),\n/* 21 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_217428__) => {\n\n\"use strict\";\n__nested_webpack_require_217428__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_217428__.d(__webpack_exports__, {\n/* harmony export */   \"AutoTileSelectorComponent\": () => (/* binding */ AutoTileSelectorComponent)\n/* harmony export */ });\n/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_217428__(2);\n/* harmony import */ var lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_217428__(7);\n/* harmony import */ var _Helpers_CursorPositionCalculator__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_217428__(18);\n/* harmony import */ var _piyoppi_pico2map_editor__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_217428__(17);\n/* harmony import */ var _piyoppi_pico2map_editor__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__nested_webpack_require_217428__.n(_piyoppi_pico2map_editor__WEBPACK_IMPORTED_MODULE_3__);\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\nclass AutoTileSelectorComponent extends lit__WEBPACK_IMPORTED_MODULE_0__.LitElement {\n    constructor() {\n        super(...arguments);\n        this._gridImageSrc = '';\n        this.gridImageGenerator = new _piyoppi_pico2map_editor__WEBPACK_IMPORTED_MODULE_3__.GridImageGenerator();\n        this.cursorPositionCalculator = new _Helpers_CursorPositionCalculator__WEBPACK_IMPORTED_MODULE_2__.CursorPositionCalculator();\n        this._indexImage = document.createElement('canvas');\n        this._project = null;\n        this._autoTileSelector = null;\n        this._afterAddAutoTileCallbackItem = null;\n        this._afterRemoveAutoTileCallbackItem = null;\n        this._afterReplacedMapChipImageCallbackItem = null;\n        this._projectId = -1;\n        this._width = 192;\n        this.cursorChipX = 0;\n        this.cursorChipY = 0;\n        this.selectedChipY = -1;\n        this.selectedChipX = -1;\n        this.indexImageSrc = '';\n    }\n    get gridColor() {\n        return this.gridImageGenerator.gridColor;\n    }\n    set gridColor(value) {\n        const oldValue = this.gridImageGenerator.gridColor;\n        this.gridImageGenerator.gridColor = value;\n        this.requestUpdate('gridColor', oldValue);\n    }\n    get projectId() {\n        return this._projectId;\n    }\n    set projectId(value) {\n        const oldValue = this._projectId;\n        this._projectId = value;\n        this._setupProject();\n        this.setupMapChipSelector();\n        this.requestUpdate('projectId', oldValue);\n    }\n    get width() {\n        return this._width;\n    }\n    set width(value) {\n        const oldValue = this._width;\n        this._width = value;\n        this.setupMapChipSelector();\n        this.requestUpdate('width', oldValue);\n    }\n    get project() {\n        return this._project;\n    }\n    get gridWidth() {\n        var _a;\n        return ((_a = this._project) === null || _a === void 0 ? void 0 : _a.tiledMap.chipWidth) || 0;\n    }\n    get gridHeight() {\n        var _a;\n        return ((_a = this._project) === null || _a === void 0 ? void 0 : _a.tiledMap.chipHeight) || 0;\n    }\n    get cursorPosition() {\n        return {\n            x: this.cursorChipX * this.gridWidth,\n            y: this.cursorChipY * this.gridHeight\n        };\n    }\n    get selectedPosition() {\n        return {\n            x: this.selectedChipX * this.gridWidth,\n            y: this.selectedChipY * this.gridHeight\n        };\n    }\n    get subscribedProjectEvent() {\n        return !!this._afterAddAutoTileCallbackItem && !!this._afterRemoveAutoTileCallbackItem && !!this._afterReplacedMapChipImageCallbackItem;\n    }\n    _setupProject() {\n        var _a;\n        if (((_a = this._project) === null || _a === void 0 ? void 0 : _a.projectId) === this._projectId)\n            return;\n        this._project = _piyoppi_pico2map_editor__WEBPACK_IMPORTED_MODULE_3__.Projects.fromProjectId(this._projectId);\n        if (!this._project) {\n            this.reset();\n            return;\n        }\n        this._subscribeProjectEvent();\n        this._autoTileSelector = new _piyoppi_pico2map_editor__WEBPACK_IMPORTED_MODULE_3__.AutoTileSelector(this.width, this._project.tiledMap.chipWidth, this._project.tiledMap.chipHeight, this._project.tiledMap.autoTiles, this._project.tiledMap.mapChipsCollection);\n        this.selectedChipX = -1;\n        this.selectedChipY = -1;\n    }\n    _subscribeProjectEvent() {\n        if (!this._project)\n            return;\n        if (!this._afterAddAutoTileCallbackItem)\n            this._afterAddAutoTileCallbackItem = this._project.setCallback('afterAddAutoTile', () => this.setupMapChipSelector());\n        if (!this._afterRemoveAutoTileCallbackItem)\n            this._afterRemoveAutoTileCallbackItem = this._project.setCallback('afterRemoveAutoTile', () => this.setupMapChipSelector());\n        if (!this._afterReplacedMapChipImageCallbackItem)\n            this._afterReplacedMapChipImageCallbackItem = this._project.setCallback('afterReplacedMapChipImage', () => this.setupMapChipSelector());\n    }\n    _unsubscribeProjectEvent() {\n        if (!this._project)\n            return;\n        if (this._afterAddAutoTileCallbackItem)\n            this._project.removeCallback('afterAddAutoTile', this._afterAddAutoTileCallbackItem);\n        if (this._afterRemoveAutoTileCallbackItem)\n            this._project.removeCallback('afterRemoveAutoTile', this._afterRemoveAutoTileCallbackItem);\n        if (this._afterReplacedMapChipImageCallbackItem)\n            this._project.removeCallback('afterReplacedMapChipImage', this._afterReplacedMapChipImageCallbackItem);\n        this._afterAddAutoTileCallbackItem = null;\n        this._afterRemoveAutoTileCallbackItem = null;\n        this._afterReplacedMapChipImageCallbackItem = null;\n    }\n    reset() {\n        this.indexImageSrc = '';\n    }\n    setupMapChipSelector() {\n        if (!this._project || !this._autoTileSelector)\n            return;\n        if (this._project.tiledMap.autoTiles.length > 0) {\n            this._autoTileSelector.canvasWidth = this.width;\n            const imageSize = this._autoTileSelector.getSizeOfIndexImage();\n            this._indexImage.width = imageSize.width;\n            this._indexImage.height = imageSize.height;\n            this._autoTileSelector.generateIndexImage(this._indexImage);\n            this.indexImageSrc = this._indexImage.toDataURL();\n        }\n        else {\n            this.reset();\n        }\n    }\n    mouseMove(e) {\n        if (!this._autoTileSelector)\n            return;\n        const mouseCursorPosition = this.cursorPositionCalculator.getMouseCursorPosition(e.pageX, e.pageY);\n        const position = this._autoTileSelector.convertFromIndexImageToChipPosition(mouseCursorPosition.x, mouseCursorPosition.y);\n        this.cursorChipX = position.x;\n        this.cursorChipY = position.y;\n    }\n    mouseDown(e) {\n        if (!this._project || !this._autoTileSelector)\n            return;\n        const mouseCursorPosition = this.cursorPositionCalculator.getMouseCursorPosition(e.pageX, e.pageY);\n        const selectedAutoTile = this._autoTileSelector.getAutoTileFragmentFromIndexImagePosition(mouseCursorPosition.x, mouseCursorPosition.y);\n        if (!selectedAutoTile)\n            return;\n        this.selectedChipX = Math.floor(mouseCursorPosition.x / this._project.tiledMap.chipWidth);\n        this.selectedChipY = Math.floor(mouseCursorPosition.y / this._project.tiledMap.chipHeight);\n        this.dispatchEvent(new CustomEvent('autotile-selected', {\n            detail: { id: selectedAutoTile.id },\n            bubbles: true,\n            composed: true\n        }));\n    }\n    firstUpdated() {\n        var _a;\n        const element = (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.getElementById('boundary');\n        if (element)\n            this.cursorPositionCalculator.setElement(element);\n    }\n    render() {\n        this.gridImageGenerator.setGridSize(this.gridWidth, this.gridHeight);\n        if (this.gridImageGenerator.changed) {\n            this._gridImageSrc = this.gridImageGenerator.generateLinePart().toDataURL();\n        }\n        const cursorWidth = this.gridWidth;\n        const cursorHeight = this.gridHeight;\n        return lit__WEBPACK_IMPORTED_MODULE_0__.html `\n      <style>\n        .grid {\n          background-image: url(\"${this._gridImageSrc}\");\n          width: ${this._indexImage.width}px;\n          height: ${this._indexImage.height}px;\n        }\n\n        .cursor {\n          width: ${cursorWidth}px;\n          height: ${cursorHeight}px;\n          left: ${this.cursorPosition.x}px;\n          top: ${this.cursorPosition.y}px;\n        }\n\n        .selected {\n          width: ${cursorWidth}px;\n          height: ${cursorHeight}px;\n          left: ${this.selectedPosition.x}px;\n          top: ${this.selectedPosition.y}px;\n        }\n      </style>\n\n      <div id=\"boundary\">\n        ${this.indexImageSrc ? lit__WEBPACK_IMPORTED_MODULE_0__.html `\n          <img id=\"chip-image\" src=\"${this.indexImageSrc}\">\n          <div\n            class=\"grid-image grid\"\n            @mousemove=\"${(e) => this.mouseMove(e)}\"\n            @mousedown=\"${(e) => this.mouseDown(e)}\"\n          ></div>\n          <div class=\"cursor\"></div>\n          ${(this.selectedChipX >= 0 && this.selectedChipY >= 0) ? lit__WEBPACK_IMPORTED_MODULE_0__.html `<div class=\"selected\"></div>` : null}\n        ` : null}\n      </div>\n    `;\n    }\n    static get styles() {\n        return lit__WEBPACK_IMPORTED_MODULE_0__.css `\n      .grid-image {\n        position: absolute;\n        top: 0;\n        left: 0;\n        background-repeat: repeat;\n      }\n\n      .cursor, .selected {\n        position: absolute;\n        border-style: solid;\n        box-sizing: border-box;\n      }\n\n      .cursor {\n        border-color: red;\n        pointer-events: none;\n      }\n\n      .selected {\n        border-color: blue;\n        pointer-events: none;\n      }\n\n      #boundary {\n        position: relative;\n      }\n\n      #chip-image {\n        display: block;\n        user-select: none;\n      }\n    `;\n    }\n    disconnectedCallback() {\n        super.disconnectedCallback();\n        this._unsubscribeProjectEvent();\n    }\n    connectedCallback() {\n        super.connectedCallback();\n        this._subscribeProjectEvent();\n    }\n}\nAutoTileSelectorComponent.Format = {\n    width: 1,\n    height: 5\n};\n__decorate([\n    (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({ type: String })\n], AutoTileSelectorComponent.prototype, \"gridColor\", null);\n__decorate([\n    (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({ type: Number })\n], AutoTileSelectorComponent.prototype, \"projectId\", null);\n__decorate([\n    (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({ type: Number })\n], AutoTileSelectorComponent.prototype, \"width\", null);\n__decorate([\n    (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({ type: Number })\n], AutoTileSelectorComponent.prototype, \"cursorChipX\", void 0);\n__decorate([\n    (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({ type: Number })\n], AutoTileSelectorComponent.prototype, \"cursorChipY\", void 0);\n__decorate([\n    (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({ type: Number })\n], AutoTileSelectorComponent.prototype, \"selectedChipY\", void 0);\n__decorate([\n    (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({ type: Number })\n], AutoTileSelectorComponent.prototype, \"selectedChipX\", void 0);\n__decorate([\n    (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({ type: String })\n], AutoTileSelectorComponent.prototype, \"indexImageSrc\", void 0);\n\n\n/***/ }),\n/* 22 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_229492__) => {\n\n\"use strict\";\n__nested_webpack_require_229492__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_229492__.d(__webpack_exports__, {\n/* harmony export */   \"ColiderMarkerComponent\": () => (/* binding */ ColiderMarkerComponent)\n/* harmony export */ });\n/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_229492__(2);\n/* harmony import */ var lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_229492__(7);\n/* harmony import */ var _Helpers_CursorPositionCalculator__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_229492__(18);\n/* harmony import */ var _piyoppi_pico2map_editor__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_229492__(17);\n/* harmony import */ var _piyoppi_pico2map_editor__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__nested_webpack_require_229492__.n(_piyoppi_pico2map_editor__WEBPACK_IMPORTED_MODULE_3__);\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\nclass ColiderMarkerComponent extends lit__WEBPACK_IMPORTED_MODULE_0__.LitElement {\n    constructor() {\n        super();\n        this._gridImageSrc = '';\n        this._gridImageGenerator = new _piyoppi_pico2map_editor__WEBPACK_IMPORTED_MODULE_3__.GridImageGenerator();\n        this._cursorPositionCalculator = new _Helpers_CursorPositionCalculator__WEBPACK_IMPORTED_MODULE_2__.CursorPositionCalculator();\n        this._coliderCanvas = new _piyoppi_pico2map_editor__WEBPACK_IMPORTED_MODULE_3__.ColiderCanvas();\n        this._project = null;\n        this._coliderCanvasElement = null;\n        this._secondaryCanvasElement = null;\n        this._documentMouseMoveEventCallee = null;\n        this._documentMouseUpEventCallee = null;\n        this.cursorChipX = 0;\n        this.cursorChipY = 0;\n        this.preventDefaultContextMenu = true;\n        this._projectId = -1;\n        this._brushName = '';\n        _piyoppi_pico2map_editor__WEBPACK_IMPORTED_MODULE_3__.Projects.setProjectAddCallbackFunction(() => this.setupProject());\n    }\n    get gridColor() {\n        return this._gridImageGenerator.gridColor;\n    }\n    set gridColor(value) {\n        const oldValue = this._gridImageGenerator.gridColor;\n        this._gridImageGenerator.gridColor = value;\n        this.requestUpdate('gridColor', oldValue);\n    }\n    get projectId() {\n        return this._projectId;\n    }\n    set projectId(value) {\n        const oldValue = this._projectId;\n        this._projectId = value;\n        this.setupProject(true);\n        this.requestUpdate('projectId', oldValue);\n    }\n    get brush() {\n        return this._brushName;\n    }\n    set brush(value) {\n        const oldValue = this._brushName;\n        this._brushName = value;\n        this.setupMapCanvas();\n        this.requestUpdate('brush', oldValue);\n    }\n    get coliderType() {\n        return this._coliderCanvas.selectedColiderType;\n    }\n    set coliderType(value) {\n        const oldValue = value;\n        this.requestUpdate('coliderType', oldValue);\n        this._coliderCanvas.setColiderType(value);\n    }\n    get subColiderType() {\n        return this._coliderCanvas.selectedSubColiderType;\n    }\n    set subColiderType(value) {\n        const oldValue = value;\n        this.requestUpdate('subColiderType', oldValue);\n        this._coliderCanvas.setSubColiderType(value);\n    }\n    get width() {\n        return this.xCount * this.gridWidth;\n    }\n    get height() {\n        return this.yCount * this.gridHeight;\n    }\n    get xCount() {\n        var _a;\n        return ((_a = this._project) === null || _a === void 0 ? void 0 : _a.tiledMap.chipCountX) || 0;\n    }\n    get yCount() {\n        var _a;\n        return ((_a = this._project) === null || _a === void 0 ? void 0 : _a.tiledMap.chipCountY) || 0;\n    }\n    get gridWidth() {\n        var _a;\n        return ((_a = this._project) === null || _a === void 0 ? void 0 : _a.tiledMap.chipWidth) || 0;\n    }\n    get gridHeight() {\n        var _a;\n        return ((_a = this._project) === null || _a === void 0 ? void 0 : _a.tiledMap.chipHeight) || 0;\n    }\n    get cursorPosition() {\n        return {\n            x: this.cursorChipX * this.gridWidth,\n            y: this.cursorChipY * this.gridHeight\n        };\n    }\n    get coliderCanvas() {\n        return this._coliderCanvas;\n    }\n    setupProject(forced = false) {\n        if (!this._project || forced) {\n            this._project = _piyoppi_pico2map_editor__WEBPACK_IMPORTED_MODULE_3__.Projects.fromProjectId(this._projectId);\n            if (!this._project)\n                return;\n            this.setupMapCanvas();\n            this.requestUpdate();\n        }\n    }\n    setupMapCanvas() {\n        if (!this._project || !this._secondaryCanvasElement || !this._coliderCanvasElement)\n            return;\n        this._coliderCanvas.setProject(this._project);\n        if (!this._coliderCanvas.isSubscribedProjectEvent)\n            this._coliderCanvas.subscribeProjectEvent();\n        this._coliderCanvas.setCanvas(this._coliderCanvasElement, this._secondaryCanvasElement);\n        this._coliderCanvas.setBrushFromName(this._brushName);\n    }\n    firstUpdated() {\n        var _a, _b, _c;\n        const element = (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.getElementById('boundary');\n        if (element)\n            this._cursorPositionCalculator.setElement(element);\n        this._coliderCanvasElement = (_b = this.shadowRoot) === null || _b === void 0 ? void 0 : _b.getElementById('colider-canvas');\n        this._secondaryCanvasElement = (_c = this.shadowRoot) === null || _c === void 0 ? void 0 : _c.getElementById('secondary-canvas');\n        this.setupMapCanvas();\n    }\n    mouseMove(e) {\n        const mouseCursorPosition = this._cursorPositionCalculator.getMouseCursorPosition(e.pageX, e.pageY);\n        const cursor = this._coliderCanvas.mouseMove(mouseCursorPosition.x, mouseCursorPosition.y);\n        this.cursorChipX = cursor.x;\n        this.cursorChipY = cursor.y;\n    }\n    mouseDown(e) {\n        const mouseCursorPosition = this._cursorPositionCalculator.getMouseCursorPosition(e.pageX, e.pageY);\n        this._coliderCanvas.mouseDown(mouseCursorPosition.x, mouseCursorPosition.y, e.button === 2);\n        this._documentMouseMoveEventCallee = e => this.mouseMove(e);\n        this._documentMouseUpEventCallee = e => this.mouseUp(e);\n        document.addEventListener('mousemove', this._documentMouseMoveEventCallee);\n        document.addEventListener('mouseup', this._documentMouseUpEventCallee);\n    }\n    mouseUp(e) {\n        const mouseCursorPosition = this._cursorPositionCalculator.getMouseCursorPosition(e.pageX, e.pageY);\n        this._coliderCanvas.mouseUp(mouseCursorPosition.x, mouseCursorPosition.y);\n        if (this._documentMouseMoveEventCallee)\n            document.removeEventListener('mousemove', this._documentMouseMoveEventCallee);\n        if (this._documentMouseUpEventCallee)\n            document.removeEventListener('mouseup', this._documentMouseUpEventCallee);\n        this._documentMouseMoveEventCallee = null;\n        this._documentMouseUpEventCallee = null;\n    }\n    render() {\n        this._gridImageGenerator.setGridSize(this.gridWidth, this.gridHeight);\n        if (this._gridImageGenerator.changed) {\n            this._gridImageSrc = this._gridImageGenerator.generateLinePart().toDataURL();\n        }\n        return lit__WEBPACK_IMPORTED_MODULE_0__.html `\n      <style>\n        .grid {\n          background-image: url(\"${this._gridImageSrc}\");\n        }\n\n        #boundary {\n          width: ${this.width + 1}px;\n          height: ${this.height + 1}px;\n        }\n\n        .cursor {\n          width: ${this.gridWidth}px;\n          height: ${this.gridHeight}px;\n          left: ${this.cursorPosition.x}px;\n          top: ${this.cursorPosition.y}px;\n        }\n\n        .grid-image {\n          background-position: 1px 1px\n        }\n      </style>\n\n      <div id=\"boundary\">\n        <canvas\n          id=\"colider-canvas\"\n          width=\"${this.width}\"\n          height=\"${this.height}\"\n        ></canvas>\n        <canvas\n          id=\"secondary-canvas\"\n          width=\"${this.width}\"\n          height=\"${this.height}\"\n        ></canvas>\n        <div\n          class=\"grid-image grid\"\n          @mousedown=\"${(e) => this.mouseDown(e)}\"\n          @mousemove=\"${(e) => !this._coliderCanvas.isMouseDown ? this.mouseMove(e) : null}\"\n          @contextmenu=\"${(e) => this.preventDefaultContextMenu && e.preventDefault()}\"\n        ></div>\n        <div class=\"cursor\"></div>\n      </div>\n    `;\n    }\n    static get styles() {\n        return lit__WEBPACK_IMPORTED_MODULE_0__.css `\n      .grid-image {\n        position: absolute;\n        top: 0;\n        left: 0;\n        background-repeat: repeat;\n        width: 100%;\n        height: 100%;\n      }\n\n      .cursor {\n        position: absolute;\n        border-style: solid;\n        box-sizing: border-box;\n        border-color: red;\n        pointer-events: none;\n      }\n\n      #boundary {\n        position: relative;\n      }\n\n      #secondary-canvas, #colider-canvas {\n        pointer-events: none;\n        position: absolute;\n        top: 0;\n        left: 0;\n      }\n    `;\n    }\n    disconnectedCallback() {\n        super.disconnectedCallback();\n        this._coliderCanvas.unsubscribeProjectEvent();\n    }\n    connectedCallback() {\n        super.connectedCallback();\n        if (this._coliderCanvas.hasProject && !this._coliderCanvas.isSubscribedProjectEvent)\n            this._coliderCanvas.subscribeProjectEvent();\n    }\n}\n__decorate([\n    (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({ type: Number })\n], ColiderMarkerComponent.prototype, \"cursorChipX\", void 0);\n__decorate([\n    (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({ type: Number })\n], ColiderMarkerComponent.prototype, \"cursorChipY\", void 0);\n__decorate([\n    (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({ type: Boolean })\n], ColiderMarkerComponent.prototype, \"preventDefaultContextMenu\", void 0);\n__decorate([\n    (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({ type: String })\n], ColiderMarkerComponent.prototype, \"gridColor\", null);\n__decorate([\n    (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({ type: Number })\n], ColiderMarkerComponent.prototype, \"projectId\", null);\n__decorate([\n    (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({ type: String })\n], ColiderMarkerComponent.prototype, \"brush\", null);\n__decorate([\n    (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({ type: Number })\n], ColiderMarkerComponent.prototype, \"coliderType\", null);\n__decorate([\n    (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({ type: Number })\n], ColiderMarkerComponent.prototype, \"subColiderType\", null);\n\n\n/***/ }),\n/* 23 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_240732__) => {\n\n\"use strict\";\n__nested_webpack_require_240732__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_240732__.d(__webpack_exports__, {\n/* harmony export */   \"MapGridComponent\": () => (/* binding */ MapGridComponent)\n/* harmony export */ });\n/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_240732__(2);\n/* harmony import */ var lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_240732__(7);\n/* harmony import */ var _Helpers_CursorPositionCalculator__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_240732__(18);\n/* harmony import */ var _piyoppi_pico2map_editor__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_240732__(17);\n/* harmony import */ var _piyoppi_pico2map_editor__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__nested_webpack_require_240732__.n(_piyoppi_pico2map_editor__WEBPACK_IMPORTED_MODULE_3__);\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\nclass MapGridComponent extends lit__WEBPACK_IMPORTED_MODULE_0__.LitElement {\n    constructor() {\n        super(...arguments);\n        this.gridImageSrc = '';\n        this.gridImageGenerator = new _piyoppi_pico2map_editor__WEBPACK_IMPORTED_MODULE_3__.GridImageGenerator();\n        this.cursorPositionCalculator = new _Helpers_CursorPositionCalculator__WEBPACK_IMPORTED_MODULE_2__.CursorPositionCalculator();\n        this.gridWidth = 0;\n        this.gridHeight = 0;\n        this.chipCountX = 0;\n        this.chipCountY = 0;\n        this.cursorHidden = false;\n        this.cursorX = 0;\n        this.cursorY = 0;\n    }\n    get gridColor() {\n        return this.gridImageGenerator.gridColor;\n    }\n    set gridColor(value) {\n        const oldValue = this.gridImageGenerator.gridColor;\n        this.gridImageGenerator.gridColor = value;\n        this.requestUpdate('gridColor', oldValue);\n    }\n    get width() {\n        return this.chipCountX * this.gridWidth;\n    }\n    get height() {\n        return this.chipCountY * this.gridHeight;\n    }\n    get cursorPosition() {\n        return {\n            x: this.cursorX * this.gridWidth,\n            y: this.cursorY * this.gridHeight\n        };\n    }\n    firstUpdated() {\n        var _a;\n        const element = (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.getElementById('boundary');\n        if (element)\n            this.cursorPositionCalculator.setElement(element);\n    }\n    mouseMove(e) {\n        if (this.cursorHidden)\n            return;\n        const mouseCursorPosition = this.cursorPositionCalculator.getMouseCursorPosition(e.pageX, e.pageY);\n        const cursor = (0,_piyoppi_pico2map_editor__WEBPACK_IMPORTED_MODULE_3__.convertFromCursorPositionToChipPosition)(mouseCursorPosition.x, mouseCursorPosition.y, this.gridWidth, this.gridHeight, this.chipCountX, this.chipCountY);\n        this.cursorX = cursor.x;\n        this.cursorY = cursor.y;\n    }\n    render() {\n        this.gridImageGenerator.setGridSize(this.gridWidth, this.gridHeight);\n        if (this.gridImageGenerator.changed) {\n            this.gridImageSrc = this.gridImageGenerator.generateLinePart().toDataURL();\n        }\n        return lit__WEBPACK_IMPORTED_MODULE_0__.html `\n      <style>\n        .grid {\n          background-image: url(\"${this.gridImageSrc}\");\n        }\n\n        #boundary {\n          width: ${this.width + 1}px;\n          height: ${this.height + 1}px;\n        }\n\n        .cursor {\n          width: ${this.gridWidth}px;\n          height: ${this.gridHeight}px;\n          left: ${this.cursorPosition.x}px;\n          top: ${this.cursorPosition.y}px;\n        }\n\n        .grid-image {\n          background-position: 1px 1px\n        }\n      </style>\n\n      <div id=\"boundary\">\n        <div\n          class=\"grid-image grid\"\n          @mousemove=\"${(e) => this.mouseMove(e)}\"\n        ></div>\n        ${!this.cursorHidden ? lit__WEBPACK_IMPORTED_MODULE_0__.html `<div class=\"cursor\"></div>` : null}\n      </div>\n    `;\n    }\n    static get styles() {\n        return lit__WEBPACK_IMPORTED_MODULE_0__.css `\n      .grid-image {\n        position: absolute;\n        top: 0;\n        left: 0;\n        background-repeat: repeat;\n        width: 100%;\n        height: 100%;\n      }\n\n      #boundary {\n        position: relative;\n      }\n\n      .cursor {\n        position: absolute;\n        border-style: solid;\n        box-sizing: border-box;\n        border-color: red;\n        pointer-events: none;\n      }\n    `;\n    }\n}\n__decorate([\n    (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({ type: Number })\n], MapGridComponent.prototype, \"gridWidth\", void 0);\n__decorate([\n    (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({ type: Number })\n], MapGridComponent.prototype, \"gridHeight\", void 0);\n__decorate([\n    (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({ type: Number })\n], MapGridComponent.prototype, \"chipCountX\", void 0);\n__decorate([\n    (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({ type: Number })\n], MapGridComponent.prototype, \"chipCountY\", void 0);\n__decorate([\n    (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({ type: Boolean })\n], MapGridComponent.prototype, \"cursorHidden\", void 0);\n__decorate([\n    (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({ type: Number })\n], MapGridComponent.prototype, \"cursorX\", void 0);\n__decorate([\n    (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({ type: Number })\n], MapGridComponent.prototype, \"cursorY\", void 0);\n__decorate([\n    (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({ type: String })\n], MapGridComponent.prototype, \"gridColor\", null);\n\n\n/***/ }),\n/* 24 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_246876__) => {\n\n\"use strict\";\n__nested_webpack_require_246876__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_246876__.d(__webpack_exports__, {\n/* harmony export */   \"MapChipSelectedEvent\": () => (/* binding */ MapChipSelectedEvent),\n/* harmony export */   \"AutoTileSelectedEvent\": () => (/* binding */ AutoTileSelectedEvent),\n/* harmony export */   \"PickedMapChipEvent\": () => (/* binding */ PickedMapChipEvent)\n/* harmony export */ });\nclass MapChipSelectedEvent extends CustomEvent {\n    constructor(detail) {\n        super('mapchip-selected', { detail });\n    }\n}\nclass AutoTileSelectedEvent extends CustomEvent {\n    constructor(detail) {\n        super('autotile-selected', { detail });\n    }\n}\nclass PickedMapChipEvent extends CustomEvent {\n    constructor(detail) {\n        super('mapchip-picked', { detail });\n    }\n}\n\n\n/***/ }),\n/* 25 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_247785__) => {\n\n\"use strict\";\n__nested_webpack_require_247785__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_247785__.d(__webpack_exports__, {\n/* harmony export */   \"PickedArrangementSelector\": () => (/* binding */ PickedArrangementSelector)\n/* harmony export */ });\n/* harmony import */ var _piyoppi_pico2map_tiled__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_247785__(20);\n/* harmony import */ var _piyoppi_pico2map_tiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_247785__.n(_piyoppi_pico2map_tiled__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction PickedArrangementSelector(detail) {\n    if ((0,_piyoppi_pico2map_tiled__WEBPACK_IMPORTED_MODULE_0__.isAutoTileMapChip)(detail.picked)) {\n        return 'AutoTileArrangement';\n    }\n    else if (detail.picked) {\n        return 'DefaultArrangement';\n    }\n    else {\n        return 'DefaultEraseArrangement';\n    }\n}\n\n\n/***/ })\n/******/ \t]);\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_248899__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_248899__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/compat get default export */\n/******/ \t(() => {\n/******/ \t\t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t\t__nested_webpack_require_248899__.n = (module) => {\n/******/ \t\t\tvar getter = module && module.__esModule ?\n/******/ \t\t\t\t() => (module['default']) :\n/******/ \t\t\t\t() => (module);\n/******/ \t\t\t__nested_webpack_require_248899__.d(getter, { a: getter });\n/******/ \t\t\treturn getter;\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/define property getters */\n/******/ \t(() => {\n/******/ \t\t// define getter functions for harmony exports\n/******/ \t\t__nested_webpack_require_248899__.d = (exports, definition) => {\n/******/ \t\t\tfor(var key in definition) {\n/******/ \t\t\t\tif(__nested_webpack_require_248899__.o(definition, key) && !__nested_webpack_require_248899__.o(exports, key)) {\n/******/ \t\t\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n/******/ \t\t\t\t}\n/******/ \t\t\t}\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/hasOwnProperty shorthand */\n/******/ \t(() => {\n/******/ \t\t__nested_webpack_require_248899__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/make namespace object */\n/******/ \t(() => {\n/******/ \t\t// define __esModule on exports\n/******/ \t\t__nested_webpack_require_248899__.r = (exports) => {\n/******/ \t\t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t\t}\n/******/ \t\t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/************************************************************************/\nvar __webpack_exports__ = {};\n// This entry need to be wrapped in an IIFE because it need to be in strict mode.\n(() => {\n\"use strict\";\n__nested_webpack_require_248899__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_248899__.d(__webpack_exports__, {\n/* harmony export */   \"defineComponent\": () => (/* binding */ defineComponent),\n/* harmony export */   \"Projects\": () => (/* reexport safe */ _piyoppi_pico2map_editor__WEBPACK_IMPORTED_MODULE_5__.Projects),\n/* harmony export */   \"MapChipSelectedEvent\": () => (/* reexport safe */ _Events__WEBPACK_IMPORTED_MODULE_6__.MapChipSelectedEvent),\n/* harmony export */   \"AutoTileSelectedEvent\": () => (/* reexport safe */ _Events__WEBPACK_IMPORTED_MODULE_6__.AutoTileSelectedEvent),\n/* harmony export */   \"PickedMapChipEvent\": () => (/* reexport safe */ _Events__WEBPACK_IMPORTED_MODULE_6__.PickedMapChipEvent),\n/* harmony export */   \"PickedArrangementSelector\": () => (/* reexport safe */ _PickedArrangementSelector__WEBPACK_IMPORTED_MODULE_7__.PickedArrangementSelector)\n/* harmony export */ });\n/* harmony import */ var _MapChipSelectorComponent__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_248899__(1);\n/* harmony import */ var _MapCanvasComponent__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_248899__(19);\n/* harmony import */ var _AutoTileSelectorComponent__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_248899__(21);\n/* harmony import */ var _ColisionMarkerComponent__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_248899__(22);\n/* harmony import */ var _MapGridComponent__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_248899__(23);\n/* harmony import */ var _piyoppi_pico2map_editor__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_248899__(17);\n/* harmony import */ var _piyoppi_pico2map_editor__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__nested_webpack_require_248899__.n(_piyoppi_pico2map_editor__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _Events__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_248899__(24);\n/* harmony import */ var _PickedArrangementSelector__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_248899__(25);\n\n\n\n\n\nfunction defineComponent() {\n    customElements.define('map-canvas-component', _MapCanvasComponent__WEBPACK_IMPORTED_MODULE_1__.MapCanvasComponent);\n    customElements.define('auto-tile-selector-component', _AutoTileSelectorComponent__WEBPACK_IMPORTED_MODULE_2__.AutoTileSelectorComponent);\n    customElements.define('map-chip-selector-component', _MapChipSelectorComponent__WEBPACK_IMPORTED_MODULE_0__.MapChipSelectorComponent);\n    customElements.define('colider-marker-component', _ColisionMarkerComponent__WEBPACK_IMPORTED_MODULE_3__.ColiderMarkerComponent);\n    customElements.define('map-grid-component', _MapGridComponent__WEBPACK_IMPORTED_MODULE_4__.MapGridComponent);\n}\n\n\n\n\n})();\n\n/******/ \treturn __webpack_exports__;\n/******/ })()\n;\n});\n\n//# sourceURL=webpack://@piyoppi/pico2map-samples/../map-editor-components/dist/main.js?");

/***/ }),

/***/ "../tiled-map/dist/main.js":
/*!*********************************!*\
  !*** ../tiled-map/dist/main.js ***!
  \*********************************/
/***/ ((module) => {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(self, function() {\nreturn /******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ([\n/* 0 */,\n/* 1 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_541__) => {\n\n__nested_webpack_require_541__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_541__.d(__webpack_exports__, {\n/* harmony export */   \"TiledMap\": () => (/* binding */ TiledMap)\n/* harmony export */ });\n/* harmony import */ var _MapChipsCollection__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_541__(2);\n/* harmony import */ var _AutoTile_AutoTiles__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_541__(4);\n/* harmony import */ var _MapData_TiledMapData__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_541__(7);\n/* harmony import */ var _MapData_ColiderMap__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_541__(11);\n\n\n\n\nclass TiledMap {\n    constructor(_chipCountX, _chipCountY, _chipWidth, _chipHeight) {\n        this._chipCountX = _chipCountX;\n        this._chipCountY = _chipCountY;\n        this._chipWidth = _chipWidth;\n        this._chipHeight = _chipHeight;\n        this._mapChipImages = new _MapChipsCollection__WEBPACK_IMPORTED_MODULE_0__.MapChipsCollection();\n        this._autoTiles = new _AutoTile_AutoTiles__WEBPACK_IMPORTED_MODULE_1__.AutoTiles();\n        this._datas = [];\n        this._coliders = new _MapData_ColiderMap__WEBPACK_IMPORTED_MODULE_3__.ColiderMap(this._chipCountX, this._chipCountY);\n        this.addLayer();\n    }\n    get chipWidth() {\n        return this._chipWidth;\n    }\n    get chipHeight() {\n        return this._chipHeight;\n    }\n    get chipCountX() {\n        return this._chipCountX;\n    }\n    get chipCountY() {\n        return this._chipCountY;\n    }\n    get mapChipsCollection() {\n        return this._mapChipImages;\n    }\n    get autoTiles() {\n        return this._autoTiles;\n    }\n    get datas() {\n        return this._datas;\n    }\n    get coliders() {\n        return this._coliders;\n    }\n    convertChipPositionToPixel(chipX, chipY) {\n        return {\n            x: chipX * this.chipWidth,\n            y: chipY * this.chipHeight\n        };\n    }\n    put(mapChip, chipX, chipY, index) {\n        this._datas[index].put(mapChip, chipX, chipY);\n    }\n    toObject() {\n        return {\n            chipCountX: this._chipCountX,\n            chipCountY: this._chipCountY,\n            chipWidth: this._chipWidth,\n            chipHeight: this._chipHeight,\n            mapChipImages: this._mapChipImages.toObject(),\n            autoTiles: this._autoTiles.toObject(),\n            tiledMapDatas: this._datas.map(data => data.toObject()),\n            coliders: this._coliders.toObject()\n        };\n    }\n    addLayer() {\n        this._datas.push(new _MapData_TiledMapData__WEBPACK_IMPORTED_MODULE_2__.TiledMapData(this._chipCountX, this._chipCountY));\n    }\n    convertMapNumberToPosition(num) {\n        return {\n            x: num % this._chipCountX,\n            y: Math.floor(num / this._chipCountX)\n        };\n    }\n    resize(chipCountX, chipCountY) {\n        this._chipCountX = chipCountX;\n        this._chipCountY = chipCountY;\n        this._datas.forEach(item => item.resize(chipCountX, chipCountY, null));\n        this._coliders.resize(chipCountX, chipCountY, 0);\n    }\n    setSerializedProperties(val) {\n        this._mapChipImages.fromObject(val.mapChipImages);\n        this._autoTiles.fromObject(val.autoTiles);\n        this._datas = val.tiledMapDatas.map(tiledMapData => _MapData_TiledMapData__WEBPACK_IMPORTED_MODULE_2__.TiledMapData.fromObject(tiledMapData));\n        this._coliders = _MapData_ColiderMap__WEBPACK_IMPORTED_MODULE_3__.ColiderMap.fromObject(val.coliders);\n    }\n    static fromObject(val) {\n        const tiledMap = new TiledMap(val.chipCountX, val.chipCountY, val.chipWidth, val.chipHeight);\n        tiledMap.setSerializedProperties({ mapChipImages: val.mapChipImages, autoTiles: val.autoTiles, tiledMapDatas: val.tiledMapDatas, coliders: val.coliders });\n        return tiledMap;\n    }\n}\n\n\n/***/ }),\n/* 2 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_4382__) => {\n\n__nested_webpack_require_4382__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_4382__.d(__webpack_exports__, {\n/* harmony export */   \"MapChipsCollection\": () => (/* binding */ MapChipsCollection)\n/* harmony export */ });\n/* harmony import */ var _MapChipImage__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_4382__(3);\n\nclass MapChipsCollection {\n    constructor() {\n        this._items = new Map();\n    }\n    push(item) {\n        this._items.set(item.id, item);\n    }\n    remove(item) {\n        this._items.delete(item.id);\n    }\n    replace(replacement) {\n        const target = this.findById(replacement.id);\n        if (!target)\n            throw new Error('Target MapChipImage cannot be found.');\n        this.remove(target);\n        this.push(replacement);\n    }\n    findById(chipId) {\n        return this._items.get(chipId) || null;\n    }\n    getItems() {\n        return Array.from(this._items.values());\n    }\n    async waitWhileLoading() {\n        await Promise.all(Array.from(this._items.values()).map(item => item.waitWhileLoading()));\n    }\n    toObject() {\n        const objectedMapChipImage = [];\n        const valuesItr = this._items.values();\n        for (const val of valuesItr) {\n            objectedMapChipImage.push(val.toObject());\n        }\n        return {\n            items: objectedMapChipImage\n        };\n    }\n    fromObject(val) {\n        this._items.clear();\n        val.items.forEach(objectedVal => {\n            this.push(_MapChipImage__WEBPACK_IMPORTED_MODULE_0__.MapChipImage.fromObject(objectedVal));\n        });\n    }\n}\n\n\n/***/ }),\n/* 3 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_6034__) => {\n\n__nested_webpack_require_6034__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_6034__.d(__webpack_exports__, {\n/* harmony export */   \"MapChipImage\": () => (/* binding */ MapChipImage)\n/* harmony export */ });\nclass MapChipImage {\n    constructor(_src, _id) {\n        this._src = _src;\n        this._id = _id;\n        this._image = new Image();\n        this._hasImage = false;\n        this._hasError = false;\n        this.loadImage();\n    }\n    get id() {\n        return this._id;\n    }\n    get src() {\n        return this._src;\n    }\n    get hasImage() {\n        return this._hasImage;\n    }\n    get hasError() {\n        return this._hasError;\n    }\n    get image() {\n        return this._image;\n    }\n    getChipCount(chipWidth, chipHeight) {\n        if (!this._hasImage)\n            throw new Error('Image loading is not complete.');\n        return {\n            width: Math.floor(this._image.width / chipWidth),\n            height: Math.floor(this._image.height / chipHeight)\n        };\n    }\n    _loadImageHandler() {\n        this._hasImage = true;\n    }\n    _errorImaegHandler() {\n        this._hasError = true;\n    }\n    loadImage() {\n        this._hasImage = false;\n        this._hasError = false;\n        this._image.onload = () => this._loadImageHandler();\n        this._image.onerror = () => this._errorImaegHandler();\n        this._image.src = this._src;\n    }\n    waitWhileLoading() {\n        const loadingPromise = new Promise((resolve, reject) => {\n            this._image.onload = () => {\n                this._loadImageHandler();\n                resolve();\n            };\n            this._image.onerror = () => {\n                this._errorImaegHandler();\n                reject(new Error('Failed to load the image.'));\n            };\n        });\n        if (this._hasImage)\n            return Promise.resolve();\n        if (this._hasError)\n            return Promise.reject(new Error('Failed to load the image.'));\n        return loadingPromise;\n    }\n    toObject() {\n        return {\n            id: this._id,\n            src: this._src\n        };\n    }\n    static fromObject(val) {\n        return new MapChipImage(val.src, val.id);\n    }\n}\n\n\n/***/ }),\n/* 4 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_8296__) => {\n\n__nested_webpack_require_8296__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_8296__.d(__webpack_exports__, {\n/* harmony export */   \"AutoTiles\": () => (/* binding */ AutoTiles)\n/* harmony export */ });\n/* harmony import */ var _AutoTile__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_8296__(5);\n\nclass AutoTiles {\n    constructor() {\n        this._autoTiles = new Map();\n        this._maxId = 0;\n    }\n    get length() {\n        return this._autoTiles.size;\n    }\n    push(item) {\n        this._autoTiles.set(item.id, item);\n        this._maxId = Math.max(this._maxId, item.id);\n    }\n    remove(item) {\n        this._autoTiles.delete(item.id);\n    }\n    findByImage(image) {\n        const valuesItr = this._autoTiles.values();\n        return Array.from(valuesItr).filter(autoTile => autoTile.mapChipFragments.some(fragment => fragment.chipId === image.id));\n    }\n    fromId(id) {\n        return this._autoTiles.get(id) || null;\n    }\n    values() {\n        return this._autoTiles.values();\n    }\n    import(strategy) {\n        const mapChipFragmentGroups = strategy.getMapChipFragments();\n        return mapChipFragmentGroups.map(group => {\n            const autoTile = new _AutoTile__WEBPACK_IMPORTED_MODULE_0__.AutoTile(group, ++this._maxId);\n            this.push(autoTile);\n            return autoTile;\n        });\n    }\n    toObject() {\n        const objectedAutoTiles = [];\n        const valuesItr = this._autoTiles.values();\n        for (const val of valuesItr) {\n            objectedAutoTiles.push(val.toObject());\n        }\n        return {\n            autoTiles: objectedAutoTiles\n        };\n    }\n    fromObject(val) {\n        this._autoTiles.clear();\n        val.autoTiles.forEach(objectedAutoTile => {\n            const autoTile = _AutoTile__WEBPACK_IMPORTED_MODULE_0__.AutoTile.fromObject(objectedAutoTile);\n            this.push(autoTile);\n            this._maxId = Math.max(this._maxId, autoTile.id);\n        });\n    }\n}\n\n\n/***/ }),\n/* 5 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_10334__) => {\n\n__nested_webpack_require_10334__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_10334__.d(__webpack_exports__, {\n/* harmony export */   \"AutoTile\": () => (/* binding */ AutoTile)\n/* harmony export */ });\n/* harmony import */ var _MapChip__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_10334__(6);\n\nclass AutoTile {\n    constructor(_mapChipFragments, _id) {\n        this._mapChipFragments = _mapChipFragments;\n        this._id = _id;\n    }\n    get id() {\n        return this._id;\n    }\n    get mapChipFragments() {\n        return this._mapChipFragments;\n    }\n    getMapChipImageIds() {\n        const chipIds = new Set();\n        this._mapChipFragments.forEach(fragment => chipIds.add(fragment.chipId));\n        return Array.from(chipIds.values());\n    }\n    toObject() {\n        return {\n            id: this._id,\n            mapChipFragments: this._mapChipFragments.map(fragment => fragment.toObject())\n        };\n    }\n    static fromObject(val) {\n        return new AutoTile(val.mapChipFragments.map(fragment => _MapChip__WEBPACK_IMPORTED_MODULE_0__.MapChipFragment.fromObject(fragment)), val.id);\n    }\n}\n\n\n/***/ }),\n/* 6 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_11537__) => {\n\n__nested_webpack_require_11537__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_11537__.d(__webpack_exports__, {\n/* harmony export */   \"MapChipFragment\": () => (/* binding */ MapChipFragment),\n/* harmony export */   \"MapChip\": () => (/* binding */ MapChip),\n/* harmony export */   \"isAutoTileMapChipProperties\": () => (/* binding */ isAutoTileMapChipProperties),\n/* harmony export */   \"AutoTileMapChip\": () => (/* binding */ AutoTileMapChip),\n/* harmony export */   \"isAutoTileMapChip\": () => (/* binding */ isAutoTileMapChip)\n/* harmony export */ });\nclass MapChipFragment {\n    constructor(_x, _y, _chipId, \n    /**\n     *  _renderingArea indicates the area where this map-chip is to be drawn.\n     *  It is represented by a OR of the following area-numbers.\n     *\n     * |<- 1chip ->|\n     * *-----*-----* ---\n     * |  1  |  2  |  ↑\n     * *-----*-----* 1chip\n     * |  4  |  8  |  ↓\n     * *-----*-----* ---\n     */\n    _renderingArea = 15) {\n        this._x = _x;\n        this._y = _y;\n        this._chipId = _chipId;\n        this._renderingArea = _renderingArea;\n        this._identifyKey = '';\n        this._identifyKey = `${_x},${_y},${_chipId}`;\n    }\n    get x() {\n        return this._x;\n    }\n    get y() {\n        return this._y;\n    }\n    get chipId() {\n        return this._chipId;\n    }\n    get identifyKey() {\n        return this._identifyKey;\n    }\n    get renderingArea() {\n        return this._renderingArea;\n    }\n    withParameter(parameters) {\n        if (parameters.x)\n            this._x = parameters.x;\n        if (parameters.y)\n            this._y = parameters.y;\n        if (parameters.renderingArea)\n            this._renderingArea = parameters.renderingArea;\n        return this;\n    }\n    clone() {\n        return new MapChipFragment(this._x, this._y, this._chipId);\n    }\n    compare(others) {\n        return this.identifyKey === others.identifyKey;\n    }\n    toObject() {\n        return {\n            x: this._x,\n            y: this._y,\n            chipId: this._chipId,\n            renderingArea: this._renderingArea\n        };\n    }\n    static fromObject(val) {\n        return new MapChipFragment(val.x, val.y, val.chipId, val.renderingArea);\n    }\n}\nclass MapChip {\n    constructor(_items = [], _arrangementName = '') {\n        this._items = _items;\n        this._arrangementName = _arrangementName;\n        this._identifyKey = '';\n        this._buildIdentifyKey();\n    }\n    get items() {\n        return this._items;\n    }\n    get identifyKey() {\n        return this._identifyKey;\n    }\n    get length() {\n        return this._items.length;\n    }\n    get arrangementName() {\n        return this._arrangementName;\n    }\n    _buildIdentifyKey() {\n        this._identifyKey = this._items.map(item => item.identifyKey).join('|');\n    }\n    setArrangementName(name) {\n        this._arrangementName = name;\n    }\n    push(mapChip) {\n        this._items.push(mapChip);\n        this._buildIdentifyKey();\n    }\n    clear() {\n        this._items.length = 0;\n        this._buildIdentifyKey();\n    }\n    clone() {\n        const cloned = new MapChip();\n        cloned._items = this._items.map(mapChip => mapChip.clone());\n        return cloned;\n    }\n    compare(others) {\n        return this.identifyKey === others.identifyKey;\n    }\n    toObject() {\n        return {\n            items: this._items.map(item => item.toObject()),\n            arrangementName: this._arrangementName\n        };\n    }\n    static fromObject(val) {\n        return new MapChip(val.items.map(item => MapChipFragment.fromObject(item)), val.arrangementName);\n    }\n}\nfunction isAutoTileMapChipProperties(obj) {\n    return obj &&\n        typeof obj.autoTileId === 'number' &&\n        obj.boundary !== undefined &&\n        obj.cross !== undefined;\n}\nclass AutoTileMapChip extends MapChip {\n    constructor(_autoTileId, items = [], _arrangementName = '', _boundary = {\n        top: false,\n        bottom: false,\n        left: false,\n        right: false\n    }, _cross = {\n        topLeft: false,\n        topRight: false,\n        bottomLeft: false,\n        bottomRight: false\n    }) {\n        super(items, _arrangementName);\n        this._autoTileId = _autoTileId;\n        this._boundary = _boundary;\n        this._cross = _cross;\n    }\n    get boundary() {\n        return this._boundary;\n    }\n    get cross() {\n        return this._cross;\n    }\n    get autoTileId() {\n        return this._autoTileId;\n    }\n    setBoundary(boundary) {\n        this._boundary = boundary;\n    }\n    setCross(cross) {\n        this._cross = cross;\n    }\n    toObject() {\n        return {\n            ...super.toObject(),\n            boundary: this._boundary,\n            cross: this._cross,\n            autoTileId: this._autoTileId\n        };\n    }\n    static fromObject(val) {\n        return new AutoTileMapChip(val.autoTileId, val.items.map(item => MapChipFragment.fromObject(item)), val.arrangementName, val.boundary, val.cross);\n    }\n}\nfunction isAutoTileMapChip(obj) {\n    return obj &&\n        typeof obj.boundary === 'object' &&\n        typeof obj.cross === 'object';\n}\n\n\n/***/ }),\n/* 7 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_16692__) => {\n\n__nested_webpack_require_16692__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_16692__.d(__webpack_exports__, {\n/* harmony export */   \"TiledMapData\": () => (/* binding */ TiledMapData)\n/* harmony export */ });\n/* harmony import */ var _MapChip__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_16692__(6);\n/* harmony import */ var _MapPaletteMatrix__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_16692__(8);\n\n\nclass TiledMapData extends _MapPaletteMatrix__WEBPACK_IMPORTED_MODULE_1__.MapPaletteMatrix {\n    filter(needles) {\n        const filtered = this.items.map(chip => needles.some(needle => !!chip && needle.compare(chip)) ? chip : null);\n        return new TiledMapData(this.width, this.height, filtered);\n    }\n    findByImage(image) {\n        const registeredChips = new Set();\n        return this.items.filter(chip => {\n            if (!chip)\n                return false;\n            const found = chip.items.find(fragment => fragment.chipId === image.id) && !registeredChips.has(chip.identifyKey);\n            if (found) {\n                registeredChips.add(chip.identifyKey);\n            }\n            return found;\n        });\n    }\n    toObject() {\n        return {\n            chipCountX: this.width,\n            chipCountY: this.height,\n            values: this.values.items,\n            palette: this.palette.map(data => data ? data.toObject() : null)\n        };\n    }\n    static fromObject(val) {\n        const palette = val.palette.map(data => {\n            if (!data)\n                return null;\n            if ((0,_MapChip__WEBPACK_IMPORTED_MODULE_0__.isAutoTileMapChipProperties)(data)) {\n                return _MapChip__WEBPACK_IMPORTED_MODULE_0__.AutoTileMapChip.fromObject(data);\n            }\n            return _MapChip__WEBPACK_IMPORTED_MODULE_0__.MapChip.fromObject(data);\n        });\n        const tiledMapData = new TiledMapData(val.chipCountX, val.chipCountY, []);\n        tiledMapData.setValuePalette(val.values, palette);\n        return tiledMapData;\n    }\n}\n\n\n/***/ }),\n/* 8 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_18777__) => {\n\n__nested_webpack_require_18777__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_18777__.d(__webpack_exports__, {\n/* harmony export */   \"MapPaletteMatrix\": () => (/* binding */ MapPaletteMatrix)\n/* harmony export */ });\n/* harmony import */ var _TransferEach__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_18777__(9);\n/* harmony import */ var _MapMatrix__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_18777__(10);\n\n\nclass MapPaletteMatrix {\n    constructor(chipCountX, chipCountY, items = []) {\n        this._paletteIndexes = new Map();\n        this._values = new _MapMatrix__WEBPACK_IMPORTED_MODULE_1__.MapMatrix(0, 0, []);\n        this._palette = [];\n        this._values = new _MapMatrix__WEBPACK_IMPORTED_MODULE_1__.MapMatrix(chipCountX, chipCountY, new Array(chipCountY * chipCountX).fill(-1));\n        if (items.length > 0) {\n            this.set(items);\n        }\n    }\n    get size() {\n        return this._values.size;\n    }\n    get width() {\n        return this._values.width;\n    }\n    get height() {\n        return this._values.height;\n    }\n    get items() {\n        return this._values.items.map(value => value >= 0 ? this._palette[value] : null);\n    }\n    get palette() {\n        return this._palette;\n    }\n    get values() {\n        return this._values;\n    }\n    set(items) {\n        if (items.length !== this._values.items.length)\n            throw new Error();\n        this._values.set(items.map(value => this._getOrGeneratePaletteIndex(value)));\n    }\n    setValuePalette(values, palette) {\n        if (values.length !== this._values.items.length)\n            throw new Error();\n        this._values.set([...values]);\n        this._palette = [...palette];\n        this._paletteIndexes.clear();\n        for (const [index, paletteItem] of this._palette.entries()) {\n            if (!paletteItem)\n                continue;\n            if (this._paletteIndexes.has(paletteItem.identifyKey)) {\n                this.rebuild();\n                break;\n            }\n            this._paletteIndexes.set(paletteItem.identifyKey, index);\n        }\n    }\n    transferFromTiledMapData(src, srcX, srcY, width, height, destX, destY) {\n        (0,_TransferEach__WEBPACK_IMPORTED_MODULE_0__.transferEach)(srcX, srcY, width, height, destX, destY, src.width, src.height, this.width, this.height, (pickupX, pickupY, putX, putY) => {\n            const item = src.getFromChipPosition(pickupX, pickupY);\n            this._values.put(this._getOrGeneratePaletteIndex(item), putX, putY);\n        });\n    }\n    resize(chipCountX, chipCountY, emptyValue) {\n        this._values.resize(chipCountX, chipCountY, this._getOrGeneratePaletteIndex(emptyValue));\n    }\n    getFromChipPosition(x, y) {\n        const paletteIndex = this._values.getFromChipPosition(x, y);\n        return paletteIndex >= 0 ? this._palette[paletteIndex] : null;\n    }\n    put(item, x, y) {\n        this._values.put(this._getOrGeneratePaletteIndex(item), x, y);\n    }\n    clone() {\n        const cloned = new MapPaletteMatrix(this.width, this.height);\n        cloned.setValuePalette(this._values.items, this._palette);\n        return cloned;\n    }\n    rebuild() {\n        const items = this.items;\n        this._palette = [];\n        this._paletteIndexes.clear();\n        this.set(items);\n    }\n    remove(target) {\n        if (!target)\n            return false;\n        const removePaletteId = this.palette.findIndex(item => (item === null || item === void 0 ? void 0 : item.identifyKey) === target.identifyKey);\n        if (removePaletteId < 0)\n            return false;\n        this.palette.splice(removePaletteId, 1);\n        this.values.items.forEach((paletteIndex, valueIndex) => {\n            if (paletteIndex === removePaletteId)\n                this.values.items[valueIndex] = -1;\n            if (paletteIndex > removePaletteId)\n                this.values.items[valueIndex] = this.values.items[valueIndex] - 1;\n        });\n        for (const [k, v] of this._paletteIndexes.entries()) {\n            if (v > removePaletteId)\n                this._paletteIndexes.set(k, v - 1);\n        }\n        this._paletteIndexes.delete(target.identifyKey);\n        return true;\n    }\n    getPaletteIndex(value) {\n        if (value === null)\n            return -1;\n        return this._paletteIndexes.get(value.identifyKey);\n    }\n    _getOrGeneratePaletteIndex(value) {\n        if (value === null)\n            return -1;\n        const index = this.getPaletteIndex(value);\n        if (index !== undefined)\n            return index;\n        this._palette.push(value);\n        const addedIndex = this._palette.length - 1;\n        this._paletteIndexes.set(value.identifyKey, addedIndex);\n        return addedIndex;\n    }\n}\n\n\n/***/ }),\n/* 9 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_23546__) => {\n\n__nested_webpack_require_23546__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_23546__.d(__webpack_exports__, {\n/* harmony export */   \"transferEach\": () => (/* binding */ transferEach)\n/* harmony export */ });\nfunction transferEach(srcX, srcY, width, height, destX, destY, srcWidth, srcHeight, destWidth, destHeight, callback) {\n    for (let x = 0; x < width; x++) {\n        const putX = destX + x;\n        const pickupX = srcX + x;\n        if (putX < 0 || putX >= destWidth)\n            continue;\n        if (pickupX < 0 || pickupX >= srcWidth)\n            continue;\n        for (let y = 0; y < height; y++) {\n            const putY = destY + y;\n            const pickupY = srcY + y;\n            if (putY < 0 || putY >= destHeight)\n                continue;\n            if (pickupY < 0 || pickupY >= srcHeight)\n                continue;\n            callback(pickupX, pickupY, putX, putY);\n        }\n    }\n}\n\n\n/***/ }),\n/* 10 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_24555__) => {\n\n__nested_webpack_require_24555__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_24555__.d(__webpack_exports__, {\n/* harmony export */   \"MapMatrix\": () => (/* binding */ MapMatrix)\n/* harmony export */ });\n/* harmony import */ var _TransferEach__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_24555__(9);\n\nclass MapMatrix {\n    constructor(_chipCountX, _chipCountY, items = []) {\n        this._chipCountX = _chipCountX;\n        this._chipCountY = _chipCountY;\n        this._items = [];\n        if (items.length > 0 && this.size !== items.length) {\n            throw new Error();\n        }\n        if (items.length === 0) {\n            this.allocate();\n        }\n        else {\n            this._items = items;\n        }\n    }\n    get size() {\n        return this._chipCountX * this._chipCountY;\n    }\n    get width() {\n        return this._chipCountX;\n    }\n    get height() {\n        return this._chipCountY;\n    }\n    get items() {\n        return this._items;\n    }\n    set(items) {\n        if (items.length !== this._items.length)\n            throw new Error();\n        this._items = items;\n    }\n    transferFromTiledMapData(src, srcX, srcY, width, height, destX, destY) {\n        (0,_TransferEach__WEBPACK_IMPORTED_MODULE_0__.transferEach)(srcX, srcY, width, height, destX, destY, src.width, src.height, this.width, this.height, (pickupX, pickupY, putX, putY) => {\n            const item = src.getFromChipPosition(pickupX, pickupY);\n            this.put(item, putX, putY);\n        });\n    }\n    resize(chipCountX, chipCountY, emptyValue) {\n        const src = this.clone();\n        this._chipCountX = chipCountX;\n        this._chipCountY = chipCountY;\n        this.allocate(emptyValue);\n        this.transferFromTiledMapData(src, 0, 0, src.width, src.height, 0, 0);\n    }\n    getFromChipPosition(x, y) {\n        if (this.isOutOfRange(x, y))\n            throw new Error('The position is out of range.');\n        const mapNumber = this.convertPositionToMapNumber(x, y);\n        return this._items[mapNumber];\n    }\n    put(item, x, y) {\n        const mapNumber = this.convertPositionToMapNumber(x, y);\n        this._items[mapNumber] = item;\n    }\n    clone() {\n        return new MapMatrix(this._chipCountX, this._chipCountY, this._items);\n    }\n    convertPositionToMapNumber(x, y) {\n        return y * this._chipCountX + x;\n    }\n    isOutOfRange(x, y) {\n        return (x < 0) || (y < 0) || (x >= this._chipCountX) || (y >= this._chipCountY);\n    }\n    allocate(defaultValue = null) {\n        this._items = new Array(this._chipCountY * this._chipCountX).fill(defaultValue);\n    }\n}\n\n\n/***/ }),\n/* 11 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_27237__) => {\n\n__nested_webpack_require_27237__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_27237__.d(__webpack_exports__, {\n/* harmony export */   \"ColiderMap\": () => (/* binding */ ColiderMap)\n/* harmony export */ });\n/* harmony import */ var _MapMatrix__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_27237__(10);\n\nclass ColiderMap extends _MapMatrix__WEBPACK_IMPORTED_MODULE_0__.MapMatrix {\n    toObject() {\n        return {\n            chipCountX: this._chipCountX,\n            chipCountY: this._chipCountY,\n            coliders: this._items\n        };\n    }\n    static fromObject(val) {\n        return new ColiderMap(val.chipCountX, val.chipCountY, val.coliders);\n    }\n    allocate() {\n        super.allocate(0);\n    }\n}\n\n\n/***/ }),\n/* 12 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_28047__) => {\n\n__nested_webpack_require_28047__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_28047__.d(__webpack_exports__, {\n/* harmony export */   \"DefaultAutoTileImportStrategy\": () => (/* binding */ DefaultAutoTileImportStrategy)\n/* harmony export */ });\n/* harmony import */ var _MapChip__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_28047__(6);\n\nclass DefaultAutoTileImportStrategy {\n    constructor(_mapChipImage, _chipWidth, _chipHeight) {\n        this._mapChipImage = _mapChipImage;\n        this._chipWidth = _chipWidth;\n        this._chipHeight = _chipHeight;\n    }\n    getMapChipFragments() {\n        const heightChipCountPerUnit = 5;\n        const countX = Math.floor(this._mapChipImage.image.width / this._chipWidth);\n        const countY = Math.floor(Math.floor(this._mapChipImage.image.height / this._chipHeight) / heightChipCountPerUnit);\n        const mapChipFragmentGroups = [];\n        for (let cy = 0; cy < countY; cy++) {\n            const y = cy * heightChipCountPerUnit;\n            for (let x = 0; x < countX; x++) {\n                const mapChipFragments = [];\n                mapChipFragments.push(new _MapChip__WEBPACK_IMPORTED_MODULE_0__.MapChipFragment(x, y, this._mapChipImage.id));\n                mapChipFragments.push(new _MapChip__WEBPACK_IMPORTED_MODULE_0__.MapChipFragment(x, y + 1, this._mapChipImage.id));\n                mapChipFragments.push(new _MapChip__WEBPACK_IMPORTED_MODULE_0__.MapChipFragment(x, y + 2, this._mapChipImage.id));\n                mapChipFragments.push(new _MapChip__WEBPACK_IMPORTED_MODULE_0__.MapChipFragment(x, y + 3, this._mapChipImage.id));\n                mapChipFragments.push(new _MapChip__WEBPACK_IMPORTED_MODULE_0__.MapChipFragment(x, y + 4, this._mapChipImage.id));\n                mapChipFragmentGroups.push(mapChipFragments);\n            }\n        }\n        return mapChipFragmentGroups;\n    }\n}\n\n\n/***/ }),\n/* 13 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_29999__) => {\n\n__nested_webpack_require_29999__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_29999__.d(__webpack_exports__, {\n/* harmony export */   \"MapRenderer\": () => (/* binding */ MapRenderer)\n/* harmony export */ });\nclass MapRenderer {\n    constructor(_tiledMap) {\n        this._tiledMap = _tiledMap;\n        this._backgroundRgba = { r: 255, g: 255, b: 255, a: 1.0 };\n    }\n    setTiledMap(tiledMap) {\n        this._tiledMap = tiledMap;\n    }\n    renderAll(ctx) {\n        this._tiledMap.datas.forEach(data => this.render(data, ctx));\n    }\n    renderLayer(index, ctx) {\n        this.render(this._tiledMap.datas[index], ctx);\n    }\n    render(data, ctx) {\n        data.items.forEach((value, index) => {\n            const position = this._tiledMap.convertMapNumberToPosition(index);\n            this.putOrClearChipToCanvas(ctx, value, position.x, position.y);\n        });\n    }\n    putOrClearChipToCanvas(ctx, mapChip, chipX, chipY, isTemporaryRendering = false) {\n        if (!mapChip) {\n            this._clearChipToCanvas(ctx, chipX, chipY, isTemporaryRendering);\n        }\n        else {\n            mapChip.items.forEach(item => {\n                this._putChipToCanvas(ctx, item, chipX, chipY);\n            });\n        }\n    }\n    _clearChipToCanvas(ctx, chipX, chipY, isTemporaryRendering) {\n        const position = this._tiledMap.convertChipPositionToPixel(chipX, chipY);\n        ctx.clearRect(position.x, position.y, this._tiledMap.chipWidth, this._tiledMap.chipHeight);\n        if (isTemporaryRendering) {\n            ctx.fillStyle = `rgba(${this._backgroundRgba.r},${this._backgroundRgba.g},${this._backgroundRgba.b},${this._backgroundRgba.a})`;\n            ctx.fillRect(position.x, position.y, this._tiledMap.chipWidth, this._tiledMap.chipHeight);\n        }\n    }\n    _putChipToCanvas(ctx, mapChip, chipX, chipY) {\n        const mapChips = this._tiledMap.mapChipsCollection.findById(mapChip.chipId);\n        const image = mapChips === null || mapChips === void 0 ? void 0 : mapChips.image;\n        if (!image)\n            return;\n        const renderingArea = this._getRenderingArea(mapChip);\n        const position = this._tiledMap.convertChipPositionToPixel(chipX, chipY);\n        position.x += renderingArea.destOffsetX;\n        position.y += renderingArea.destOffsetY;\n        ctx.clearRect(position.x, position.y, renderingArea.width, renderingArea.height);\n        ctx.drawImage(image, renderingArea.x, renderingArea.y, renderingArea.width, renderingArea.height, position.x, position.y, renderingArea.width, renderingArea.height);\n    }\n    _getRenderingArea(mapChip) {\n        const width = this._tiledMap.chipWidth;\n        const height = this._tiledMap.chipHeight;\n        const x = mapChip.x * width;\n        const y = mapChip.y * height;\n        if (mapChip.renderingArea === 15) {\n            return { x, y, width, height, destOffsetX: 0, destOffsetY: 0 };\n        }\n        const halfWidth = Math.round(width / 2);\n        const halfHeight = Math.round(height / 2);\n        switch (mapChip.renderingArea) {\n            case 1:\n                return { x, y, width: halfWidth, height: halfHeight, destOffsetX: 0, destOffsetY: 0 };\n            case 2:\n                return { x: x + halfWidth, y, width: halfWidth, height: halfHeight, destOffsetX: halfWidth, destOffsetY: 0 };\n            case 3:\n                return { x, y, width, height: halfHeight, destOffsetX: 0, destOffsetY: 0 };\n            case 4:\n                return { x, y: y + halfHeight, width: halfWidth, height: halfHeight, destOffsetX: 0, destOffsetY: halfHeight };\n            case 5:\n                return { x, y, width: halfWidth, height, destOffsetX: 0, destOffsetY: 0 };\n            case 8:\n                return { x: x + halfWidth, y: y + halfHeight, width: halfWidth, height: halfHeight, destOffsetX: halfWidth, destOffsetY: halfHeight };\n            case 10:\n                return { x: x + halfWidth, y, width: halfWidth, height, destOffsetX: halfWidth, destOffsetY: 0 };\n            case 12:\n                return { x, y: y + halfHeight, width, height: halfHeight, destOffsetX: 0, destOffsetY: halfHeight };\n        }\n    }\n}\n\n\n/***/ })\n/******/ \t]);\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_34379__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_34379__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/define property getters */\n/******/ \t(() => {\n/******/ \t\t// define getter functions for harmony exports\n/******/ \t\t__nested_webpack_require_34379__.d = (exports, definition) => {\n/******/ \t\t\tfor(var key in definition) {\n/******/ \t\t\t\tif(__nested_webpack_require_34379__.o(definition, key) && !__nested_webpack_require_34379__.o(exports, key)) {\n/******/ \t\t\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n/******/ \t\t\t\t}\n/******/ \t\t\t}\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/hasOwnProperty shorthand */\n/******/ \t(() => {\n/******/ \t\t__nested_webpack_require_34379__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/make namespace object */\n/******/ \t(() => {\n/******/ \t\t// define __esModule on exports\n/******/ \t\t__nested_webpack_require_34379__.r = (exports) => {\n/******/ \t\t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t\t}\n/******/ \t\t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/************************************************************************/\nvar __webpack_exports__ = {};\n// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.\n(() => {\n__nested_webpack_require_34379__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_34379__.d(__webpack_exports__, {\n/* harmony export */   \"TiledMap\": () => (/* reexport safe */ _TiledMap__WEBPACK_IMPORTED_MODULE_0__.TiledMap),\n/* harmony export */   \"TiledMapData\": () => (/* reexport safe */ _MapData_TiledMapData__WEBPACK_IMPORTED_MODULE_1__.TiledMapData),\n/* harmony export */   \"MapChipImage\": () => (/* reexport safe */ _MapChipImage__WEBPACK_IMPORTED_MODULE_2__.MapChipImage),\n/* harmony export */   \"MapChipsCollection\": () => (/* reexport safe */ _MapChipsCollection__WEBPACK_IMPORTED_MODULE_3__.MapChipsCollection),\n/* harmony export */   \"MapChipFragment\": () => (/* reexport safe */ _MapChip__WEBPACK_IMPORTED_MODULE_4__.MapChipFragment),\n/* harmony export */   \"MapChip\": () => (/* reexport safe */ _MapChip__WEBPACK_IMPORTED_MODULE_4__.MapChip),\n/* harmony export */   \"AutoTileMapChip\": () => (/* reexport safe */ _MapChip__WEBPACK_IMPORTED_MODULE_4__.AutoTileMapChip),\n/* harmony export */   \"isAutoTileMapChip\": () => (/* reexport safe */ _MapChip__WEBPACK_IMPORTED_MODULE_4__.isAutoTileMapChip),\n/* harmony export */   \"AutoTiles\": () => (/* reexport safe */ _AutoTile_AutoTiles__WEBPACK_IMPORTED_MODULE_5__.AutoTiles),\n/* harmony export */   \"AutoTile\": () => (/* reexport safe */ _AutoTile_AutoTile__WEBPACK_IMPORTED_MODULE_6__.AutoTile),\n/* harmony export */   \"DefaultAutoTileImportStrategy\": () => (/* reexport safe */ _AutoTile_DefaultAutoTileImportStrategy__WEBPACK_IMPORTED_MODULE_7__.DefaultAutoTileImportStrategy),\n/* harmony export */   \"ColiderMap\": () => (/* reexport safe */ _MapData_ColiderMap__WEBPACK_IMPORTED_MODULE_8__.ColiderMap),\n/* harmony export */   \"MapRenderer\": () => (/* reexport safe */ _MapRenderer__WEBPACK_IMPORTED_MODULE_9__.MapRenderer)\n/* harmony export */ });\n/* harmony import */ var _TiledMap__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_34379__(1);\n/* harmony import */ var _MapData_TiledMapData__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_34379__(7);\n/* harmony import */ var _MapChipImage__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_34379__(3);\n/* harmony import */ var _MapChipsCollection__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_34379__(2);\n/* harmony import */ var _MapChip__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_34379__(6);\n/* harmony import */ var _AutoTile_AutoTiles__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_34379__(4);\n/* harmony import */ var _AutoTile_AutoTile__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_34379__(5);\n/* harmony import */ var _AutoTile_DefaultAutoTileImportStrategy__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_34379__(12);\n/* harmony import */ var _MapData_ColiderMap__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_34379__(11);\n/* harmony import */ var _MapRenderer__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_34379__(13);\n\n\n\n\n\n\n\n\n\n\n\n})();\n\n/******/ \treturn __webpack_exports__;\n/******/ })()\n;\n});\n//# sourceMappingURL=main.js.map\n\n//# sourceURL=webpack://@piyoppi/pico2map-samples/../tiled-map/dist/main.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./simple_map_editor/src/simple_map_editor.ts");
/******/ 	
/******/ })()
;